diff --git a/CMakeLists.txt b/CMakeLists.txt
index 7b5fe520d..bda555dc1 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -89,6 +89,7 @@ find_package(KF5 ${KF5_MIN_VERSION} REQUIRED COMPONENTS
     Completion
     Declarative
     KCMUtils
+    KIO
     NewStuff
     Service
     TextWidgets
diff --git a/autotests/integration/effects/desktop_switching_animation_test.cpp b/autotests/integration/effects/desktop_switching_animation_test.cpp
index 5c5348d71..30118107b 100644
--- a/autotests/integration/effects/desktop_switching_animation_test.cpp
+++ b/autotests/integration/effects/desktop_switching_animation_test.cpp
@@ -93,6 +93,7 @@ void DesktopSwitchingAnimationTest::testSwitchDesktops_data()
 {
     QTest::addColumn<QString>("effectName");
 
+    QTest::newRow("Desktop Cube Animation") << QStringLiteral("cubeslide");
     QTest::newRow("Fade Desktop")           << QStringLiteral("kwin4_effect_fadedesktop");
     QTest::newRow("Slide")                  << QStringLiteral("slide");
 }
diff --git a/autotests/test_builtin_effectloader.cpp b/autotests/test_builtin_effectloader.cpp
index 905ea07f7..b42058f19 100644
--- a/autotests/test_builtin_effectloader.cpp
+++ b/autotests/test_builtin_effectloader.cpp
@@ -73,9 +73,13 @@ void TestBuiltInEffectLoader::testHasEffect_data()
     QTest::newRow("case sensitive")                 << QStringLiteral("BlUR")              << true;
     QTest::newRow("Colorpicker")                    << QStringLiteral("colorpicker")       << true;
     QTest::newRow("Contrast")                       << QStringLiteral("contrast")          << true;
+    QTest::newRow("CoverSwitch")                    << QStringLiteral("coverswitch")       << true;
+    QTest::newRow("Cube")                           << QStringLiteral("cube")              << true;
+    QTest::newRow("CubeSlide")                      << QStringLiteral("cubeslide")         << true;
     QTest::newRow("DesktopGrid")                    << QStringLiteral("desktopgrid")       << true;
     QTest::newRow("DimInactive")                    << QStringLiteral("diminactive")       << true;
     QTest::newRow("FallApart")                      << QStringLiteral("fallapart")         << true;
+    QTest::newRow("FlipSwitch")                     << QStringLiteral("flipswitch")        << true;
     QTest::newRow("Glide")                          << QStringLiteral("glide")             << true;
     QTest::newRow("HighlightWindow")                << QStringLiteral("highlightwindow")   << true;
     QTest::newRow("Invert")                         << QStringLiteral("invert")            << true;
@@ -123,9 +127,13 @@ void TestBuiltInEffectLoader::testKnownEffects()
     expectedEffects << QStringLiteral("blur")
                     << QStringLiteral("colorpicker")
                     << QStringLiteral("contrast")
+                    << QStringLiteral("coverswitch")
+                    << QStringLiteral("cube")
+                    << QStringLiteral("cubeslide")
                     << QStringLiteral("desktopgrid")
                     << QStringLiteral("diminactive")
                     << QStringLiteral("fallapart")
+                    << QStringLiteral("flipswitch")
                     << QStringLiteral("glide")
                     << QStringLiteral("highlightwindow")
                     << QStringLiteral("invert")
@@ -183,10 +191,21 @@ void TestBuiltInEffectLoader::testSupported_data()
     QTest::newRow("Contrast")                       << QStringLiteral("contrast")          << false << qc << true;
     // fails for GL as it does proper tests on what's supported and doesn't just check whether it's GL
     QTest::newRow("Contrast-GL")                    << QStringLiteral("contrast")          << false << oc << true;
+    QTest::newRow("CoverSwitch")                    << QStringLiteral("coverswitch")       << false << qc << true;
+    QTest::newRow("CoverSwitch-GL")                 << QStringLiteral("coverswitch")       << true  << oc << true;
+    QTest::newRow("CoverSwitch-GL-no-anim")         << QStringLiteral("coverswitch")       << false << oc << false;
+    QTest::newRow("Cube")                           << QStringLiteral("cube")              << false << qc << true;
+    QTest::newRow("Cube-GL")                        << QStringLiteral("cube")              << true  << oc << true;
+    QTest::newRow("CubeSlide")                      << QStringLiteral("cubeslide")         << false << qc << true;
+    QTest::newRow("CubeSlide-GL")                   << QStringLiteral("cubeslide")         << true  << oc << true;
+    QTest::newRow("CubeSlide-GL-no-anim")           << QStringLiteral("cubeslide")         << false << oc << false;
     QTest::newRow("DesktopGrid")                    << QStringLiteral("desktopgrid")       << true  << qc << true;
     QTest::newRow("DimInactive")                    << QStringLiteral("diminactive")       << true  << qc << true;
     QTest::newRow("FallApart")                      << QStringLiteral("fallapart")         << false << qc << true;
     QTest::newRow("FallApart-GL")                   << QStringLiteral("fallapart")         << true  << oc << true;
+    QTest::newRow("FlipSwitch")                     << QStringLiteral("flipswitch")        << false << qc << true;
+    QTest::newRow("FlipSwitch-GL")                  << QStringLiteral("flipswitch")        << true  << oc << true;
+    QTest::newRow("FlipSwitch-GL-no-anim")          << QStringLiteral("flipswitch")        << false << oc << false;
     QTest::newRow("Glide")                          << QStringLiteral("glide")             << false << qc << true;
     QTest::newRow("Glide-GL")                       << QStringLiteral("glide")             << true  << oc << true;
     QTest::newRow("Glide-GL-no-anim")               << QStringLiteral("glide")             << false << oc << false;
@@ -264,10 +283,20 @@ void TestBuiltInEffectLoader::testLoadEffect_data()
     QTest::newRow("Contrast")                       << QStringLiteral("contrast")          << false << qc;
     // fails for GL as it does proper tests on what's supported and doesn't just check whether it's GL
     QTest::newRow("Contrast-GL")                    << QStringLiteral("contrast")          << false << oc;
+    QTest::newRow("CoverSwitch")                    << QStringLiteral("coverswitch")       << false << xc;
+    // TODO: needs GL mocking
+//     QTest::newRow("CoverSwitch-GL")                 << QStringLiteral("coverswitch")       << true  << oc;
+    QTest::newRow("Cube")                           << QStringLiteral("cube")              << false << xc;
+    // TODO: needs GL mocking
+//     QTest::newRow("Cube-GL")                        << QStringLiteral("cube")              << true  << oc;
+    QTest::newRow("CubeSlide")                      << QStringLiteral("cubeslide")         << false << qc;
+    QTest::newRow("CubeSlide-GL")                   << QStringLiteral("cubeslide")         << true  << oc;
     QTest::newRow("DesktopGrid")                    << QStringLiteral("desktopgrid")       << true  << qc;
     QTest::newRow("DimInactive")                    << QStringLiteral("diminactive")       << true  << qc;
     QTest::newRow("FallApart")                      << QStringLiteral("fallapart")         << false << qc;
     QTest::newRow("FallApart-GL")                   << QStringLiteral("fallapart")         << true  << oc;
+    QTest::newRow("FlipSwitch")                     << QStringLiteral("flipswitch")        << false << qc;
+    QTest::newRow("FlipSwitch-GL")                  << QStringLiteral("flipswitch")        << true  << oc;
     QTest::newRow("Glide")                          << QStringLiteral("glide")             << false << qc;
     QTest::newRow("Glide-GL")                       << QStringLiteral("glide")             << true  << oc;
     QTest::newRow("HighlightWindow")                << QStringLiteral("highlightwindow")   << true  << qc;
diff --git a/autotests/test_plugin_effectloader.cpp b/autotests/test_plugin_effectloader.cpp
index fd63279bc..4ec8140bd 100644
--- a/autotests/test_plugin_effectloader.cpp
+++ b/autotests/test_plugin_effectloader.cpp
@@ -64,9 +64,13 @@ void TestPluginEffectLoader::testHasEffect_data()
     QTest::newRow("blur")              << QStringLiteral("blur")                      << false;
     QTest::newRow("ColorPicker")       << QStringLiteral("colorpicker")               << false;
     QTest::newRow("Contrast")          << QStringLiteral("contrast")                  << false;
+    QTest::newRow("CoverSwitch")       << QStringLiteral("coverswitch")               << false;
+    QTest::newRow("Cube")              << QStringLiteral("cube")                      << false;
+    QTest::newRow("CubeSlide")         << QStringLiteral("cubeslide")                 << false;
     QTest::newRow("DesktopGrid")       << QStringLiteral("desktopgrid")               << false;
     QTest::newRow("DimInactive")       << QStringLiteral("diminactive")               << false;
     QTest::newRow("FallApart")         << QStringLiteral("fallapart")                 << false;
+    QTest::newRow("FlipSwitch")        << QStringLiteral("flipswitch")                << false;
     QTest::newRow("Glide")             << QStringLiteral("glide")                     << false;
     QTest::newRow("HighlightWindow")   << QStringLiteral("highlightwindow")           << false;
     QTest::newRow("Invert")            << QStringLiteral("invert")                    << false;
diff --git a/autotests/test_scripted_effectloader.cpp b/autotests/test_scripted_effectloader.cpp
index e9863cabe..a615f9a97 100644
--- a/autotests/test_scripted_effectloader.cpp
+++ b/autotests/test_scripted_effectloader.cpp
@@ -85,9 +85,13 @@ void TestScriptedEffectLoader::testHasEffect_data()
     QTest::newRow("blur")                        << QStringLiteral("blur")                      << false;
     QTest::newRow("Colorpicker")                 << QStringLiteral("colorpicker")               << false;
     QTest::newRow("Contrast")                    << QStringLiteral("contrast")                  << false;
+    QTest::newRow("CoverSwitch")                 << QStringLiteral("coverswitch")               << false;
+    QTest::newRow("Cube")                        << QStringLiteral("cube")                      << false;
+    QTest::newRow("CubeSlide")                   << QStringLiteral("cubeslide")                 << false;
     QTest::newRow("DesktopGrid")                 << QStringLiteral("desktopgrid")               << false;
     QTest::newRow("DimInactive")                 << QStringLiteral("diminactive")               << false;
     QTest::newRow("FallApart")                   << QStringLiteral("fallapart")                 << false;
+    QTest::newRow("FlipSwitch")                  << QStringLiteral("flipswitch")                << false;
     QTest::newRow("Glide")                       << QStringLiteral("glide")                     << false;
     QTest::newRow("HighlightWindow")             << QStringLiteral("highlightwindow")           << false;
     QTest::newRow("Invert")                      << QStringLiteral("invert")                    << false;
diff --git a/kconf_update/kwin-5.23-remove-cover-switch.py b/kconf_update/kwin-5.23-remove-cover-switch.py
deleted file mode 100644
index 53e60a799..000000000
--- a/kconf_update/kwin-5.23-remove-cover-switch.py
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env python3
-
-import fileinput
-
-for line in fileinput.input():
-    if not line.startswith("LayoutName="):
-        continue
-    value = line[len("LayoutName="):].strip()
-    if value != "coverswitch":
-        continue
-    print("# DELETE LayoutName") # will use the default layout
diff --git a/kconf_update/kwin-5.23-remove-cubeslide.py b/kconf_update/kwin-5.23-remove-cubeslide.py
deleted file mode 100644
index f3756e396..000000000
--- a/kconf_update/kwin-5.23-remove-cubeslide.py
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env python3
-
-import fileinput
-
-for line in fileinput.input():
-    if not line.startswith("cubeslideEnabled="):
-        continue
-    value = line[len("cubeslideEnabled="):].strip()
-    if value == "true":
-        print("# DELETE cubeslideEnabled")
-        print("# DELETE slideEnabled") # make slide effect enabled, it's off now
diff --git a/kconf_update/kwin-5.23-remove-flip-switch.py b/kconf_update/kwin-5.23-remove-flip-switch.py
deleted file mode 100644
index b2bb30118..000000000
--- a/kconf_update/kwin-5.23-remove-flip-switch.py
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/usr/bin/env python3
-
-import fileinput
-
-for line in fileinput.input():
-    if not line.startswith("LayoutName="):
-        continue
-    value = line[len("LayoutName="):].strip()
-    if value != "flipswitch":
-        continue
-    print("# DELETE LayoutName") # will use the default layout
diff --git a/kconf_update/kwin.upd b/kconf_update/kwin.upd
index ef033cfb6..50b12295a 100644
--- a/kconf_update/kwin.upd
+++ b/kconf_update/kwin.upd
@@ -56,24 +56,6 @@ File=kwinrc
 Group=Plugins
 Script=kwin-5.23-disable-translucency-effect.sh,sh
 
-# Remove the Flip Switch effect
-Id=remove-flip-switch-effect
-File=kwinrc
-Group=TabBox,TabBoxAlternative
-Script=kwin-5.23-remove-flip-switch.py,python3
-
-# Remove the Cover Switch effect
-Id=remove-cover-switch-effect
-File=kwinrc
-Group=TabBox,TabBoxAlternative
-Script=kwin-5.23-remove-cover-switch.py,python3
-
-# Remove the Desktop Cube Animation effect
-Id=remove-cubeslide-effect
-File=kwinrc
-Group=Plugins
-Script=kwin-5.23-remove-cubeslide.py,python3
-
 # Remove Backend if it has a value of "XRender"
 Id=remove-xrender-backend
 File=kwinrc
diff --git a/src/effects/CMakeLists.txt b/src/effects/CMakeLists.txt
index f15f6cb4a..a1230996a 100644
--- a/src/effects/CMakeLists.txt
+++ b/src/effects/CMakeLists.txt
@@ -75,9 +75,14 @@ set(kwin4_effect_builtins_sources
     blur/blur.cpp
     blur/blurshader.cpp
     colorpicker/colorpicker.cpp
+    coverswitch/coverswitch.cpp
+    cube/cube.cpp
+    cube/cube_proxy.cpp
+    cubeslide/cubeslide.cpp
     desktopgrid/desktopgrid.cpp
     diminactive/diminactive.cpp
     effect_builtins.cpp
+    flipswitch/flipswitch.cpp
     glide/glide.cpp
     invert/invert.cpp
     logging.cpp
@@ -115,9 +120,13 @@ qt5_add_resources(kwin4_effect_builtins_sources shaders.qrc)
 
 kconfig_add_kcfg_files(kwin4_effect_builtins_sources
     blur/blurconfig.kcfgc
+    coverswitch/coverswitchconfig.kcfgc
+    cube/cubeconfig.kcfgc
+    cubeslide/cubeslideconfig.kcfgc
     desktopgrid/desktopgridconfig.kcfgc
     diminactive/diminactiveconfig.kcfgc
     fallapart/fallapartconfig.kcfgc
+    flipswitch/flipswitchconfig.kcfgc
     glide/glideconfig.kcfgc
     lookingglass/lookingglassconfig.kcfgc
     magiclamp/magiclampconfig.kcfgc
@@ -189,6 +198,10 @@ add_subdirectory(zoom)
 # OpenGL-specific effects
 add_subdirectory(blur)
 include(backgroundcontrast/CMakeLists.txt)
+add_subdirectory(coverswitch)
+add_subdirectory(cube)
+add_subdirectory(cubeslide)
+add_subdirectory(flipswitch)
 add_subdirectory(glide)
 add_subdirectory(invert)
 add_subdirectory(lookingglass)
diff --git a/src/effects/coverswitch/CMakeLists.txt b/src/effects/coverswitch/CMakeLists.txt
new file mode 100644
index 000000000..059c0d7c5
--- /dev/null
+++ b/src/effects/coverswitch/CMakeLists.txt
@@ -0,0 +1,26 @@
+#######################################
+# Effect
+
+#######################################
+# Config
+set(kwin_coverswitch_config_SRCS coverswitch_config.cpp)
+ki18n_wrap_ui(kwin_coverswitch_config_SRCS coverswitch_config.ui)
+kconfig_add_kcfg_files(kwin_coverswitch_config_SRCS coverswitchconfig.kcfgc)
+
+add_library(kwin_coverswitch_config MODULE ${kwin_coverswitch_config_SRCS})
+
+target_link_libraries(kwin_coverswitch_config
+    KF5::ConfigWidgets
+    KF5::I18n
+    Qt::DBus
+    KWinEffectsInterface
+)
+
+kcoreaddons_desktop_to_json(kwin_coverswitch_config coverswitch_config.desktop SERVICE_TYPES kcmodule.desktop)
+
+install(
+    TARGETS
+        kwin_coverswitch_config
+    DESTINATION
+        ${KDE_INSTALL_PLUGINDIR}/kwin/effects/configs
+)
diff --git a/src/effects/coverswitch/coverswitch.cpp b/src/effects/coverswitch/coverswitch.cpp
new file mode 100644
index 000000000..f95cf8455
--- /dev/null
+++ b/src/effects/coverswitch/coverswitch.cpp
@@ -0,0 +1,1001 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#include "coverswitch.h"
+// KConfigSkeleton
+#include "coverswitchconfig.h"
+
+#include <kwinconfig.h>
+#include <QFile>
+#include <QIcon>
+#include <QMatrix4x4>
+#include <QMouseEvent>
+#include <QFontMetrics>
+#include <KLocalizedString>
+#include <kcolorscheme.h>
+
+#include <kwinglplatform.h>
+
+#include <cmath>
+
+namespace KWin
+{
+
+CoverSwitchEffect::CoverSwitchEffect()
+    : mActivated(0)
+    , angle(60.0)
+    , animation(false)
+    , start(false)
+    , stop(false)
+    , stopRequested(false)
+    , startRequested(false)
+    , lastPresentTime(std::chrono::milliseconds::zero())
+    , zPosition(900.0)
+    , scaleFactor(0.0)
+    , direction(Left)
+    , selected_window(nullptr)
+    , captionFrame(nullptr)
+    , primaryTabBox(false)
+    , secondaryTabBox(false)
+{
+    initConfig<CoverSwitchConfig>();
+    reconfigure(ReconfigureAll);
+
+    // Caption frame
+    captionFont.setBold(true);
+    captionFont.setPointSize(captionFont.pointSize() * 2);
+
+    if (effects->compositingType() == OpenGLCompositing) {
+        m_reflectionShader = ShaderManager::instance()->generateShaderFromResources(ShaderTrait::MapTexture, QString(), QStringLiteral("coverswitch-reflection.glsl"));
+    } else {
+        m_reflectionShader = nullptr;
+    }
+    connect(effects, &EffectsHandler::windowClosed, this, &CoverSwitchEffect::slotWindowClosed);
+    connect(effects, &EffectsHandler::tabBoxAdded, this, &CoverSwitchEffect::slotTabBoxAdded);
+    connect(effects, &EffectsHandler::tabBoxClosed, this, &CoverSwitchEffect::slotTabBoxClosed);
+    connect(effects, &EffectsHandler::tabBoxUpdated, this, &CoverSwitchEffect::slotTabBoxUpdated);
+    connect(effects, &EffectsHandler::tabBoxKeyEvent, this, &CoverSwitchEffect::slotTabBoxKeyEvent);
+}
+
+CoverSwitchEffect::~CoverSwitchEffect()
+{
+    delete captionFrame;
+    delete m_reflectionShader;
+}
+
+bool CoverSwitchEffect::supported()
+{
+    return effects->isOpenGLCompositing() && effects->animationsSupported();
+}
+
+void CoverSwitchEffect::reconfigure(ReconfigureFlags)
+{
+    CoverSwitchConfig::self()->read();
+    animationDuration = std::chrono::milliseconds(
+        animationTime<CoverSwitchConfig>(200));
+    animateSwitch     = CoverSwitchConfig::animateSwitch();
+    animateStart      = CoverSwitchConfig::animateStart();
+    animateStop       = CoverSwitchConfig::animateStop();
+    reflection        = CoverSwitchConfig::reflection();
+    windowTitle       = CoverSwitchConfig::windowTitle();
+    zPosition         = CoverSwitchConfig::zPosition();
+    timeLine.setEasingCurve(QEasingCurve::InOutSine);
+    timeLine.setDuration(animationDuration);
+
+    // Defined outside the ui
+    primaryTabBox     = CoverSwitchConfig::tabBox();
+    secondaryTabBox   = CoverSwitchConfig::tabBoxAlternative();
+
+    QColor tmp        = CoverSwitchConfig::mirrorFrontColor();
+    mirrorColor[0][0] = tmp.redF();
+    mirrorColor[0][1] = tmp.greenF();
+    mirrorColor[0][2] = tmp.blueF();
+    mirrorColor[0][3] = 1.0;
+    tmp               = CoverSwitchConfig::mirrorRearColor();
+    mirrorColor[1][0] = tmp.redF();
+    mirrorColor[1][1] = tmp.greenF();
+    mirrorColor[1][2] = tmp.blueF();
+    mirrorColor[1][3] = -1.0;
+
+}
+
+void CoverSwitchEffect::prePaintScreen(ScreenPrePaintData& data, std::chrono::milliseconds presentTime)
+{
+    if (mActivated || stop || stopRequested) {
+        data.mask |= Effect::PAINT_SCREEN_WITH_TRANSFORMED_WINDOWS;
+        if (animation || start || stop) {
+            std::chrono::milliseconds delta = std::chrono::milliseconds::zero();
+            if (lastPresentTime.count()) {
+                delta = presentTime - lastPresentTime;
+            }
+            lastPresentTime = presentTime;
+            timeLine.update(delta);
+        }
+        if (selected_window == nullptr)
+            abort();
+    }
+    effects->prePaintScreen(data, presentTime);
+}
+
+void CoverSwitchEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
+{
+    effects->paintScreen(mask, region, data);
+
+    if (mActivated || stop || stopRequested) {
+
+        QList< EffectWindow* > tempList = currentWindowList;
+        int index = tempList.indexOf(selected_window);
+        if (animation || start || stop) {
+            if (!start && !stop) {
+                if (direction == Right)
+                    index++;
+                else
+                    index--;
+                if (index < 0)
+                    index = tempList.count() + index;
+                if (index >= tempList.count())
+                    index = index % tempList.count();
+            }
+            Q_FOREACH (Direction direction, scheduled_directions) {
+                if (direction == Right)
+                    index++;
+                else
+                    index--;
+                if (index < 0)
+                    index = tempList.count() + index;
+                if (index >= tempList.count())
+                    index = index % tempList.count();
+            }
+        }
+        int leftIndex = index - 1;
+        if (leftIndex < 0)
+            leftIndex = tempList.count() - 1;
+        int rightIndex = index + 1;
+        if (rightIndex == tempList.count())
+            rightIndex = 0;
+
+        EffectWindow* frontWindow = tempList[ index ];
+        leftWindows.clear();
+        rightWindows.clear();
+
+        bool evenWindows = (tempList.count() % 2 == 0) ? true : false;
+        int leftWindowCount = 0;
+        if (evenWindows)
+            leftWindowCount = tempList.count() / 2 - 1;
+        else
+            leftWindowCount = (tempList.count() - 1) / 2;
+        for (int i = 0; i < leftWindowCount; i++) {
+            int tempIndex = (leftIndex - i);
+            if (tempIndex < 0)
+                tempIndex = tempList.count() + tempIndex;
+            leftWindows.prepend(tempList[ tempIndex ]);
+        }
+        int rightWindowCount = 0;
+        if (evenWindows)
+            rightWindowCount = tempList.count() / 2;
+        else
+            rightWindowCount = (tempList.count() - 1) / 2;
+        for (int i = 0; i < rightWindowCount; i++) {
+            int tempIndex = (rightIndex + i) % tempList.count();
+            rightWindows.prepend(tempList[ tempIndex ]);
+        }
+
+        if (reflection) {
+            // no reflections during start and stop animation
+            // except when using a shader
+            if ((!start && !stop) || effects->compositingType() == OpenGLCompositing)
+                paintScene(frontWindow, leftWindows, rightWindows, true);
+            glEnable(GL_BLEND);
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            // we can use a huge scale factor (needed to calculate the rearground vertices)
+            // as we restrict with a PaintClipper painting on the current screen
+            float reflectionScaleFactor = 100000 * tan(60.0 * M_PI / 360.0f) / area.width();
+            const float width = area.width();
+            const float height = area.height();
+            float vertices[] = {
+                -width * 0.5f, height, 0.0,
+                width * 0.5f, height, 0.0,
+                width*reflectionScaleFactor, height, -5000,
+                -width*reflectionScaleFactor, height, -5000
+            };
+            // foreground
+            if (start) {
+                mirrorColor[0][3] = timeLine.value();
+            } else if (stop) {
+                mirrorColor[0][3] = 1.0 - timeLine.value();
+            } else {
+                mirrorColor[0][3] = 1.0;
+            }
+
+            int y = 0;
+            // have to adjust the y values to fit OpenGL
+            // in OpenGL y==0 is at bottom, in Qt at top
+            if (effects->numScreens() > 1) {
+                QRect fullArea = effects->clientArea(FullArea, 0, 1);
+                if (fullArea.height() != area.height()) {
+                    if (area.y() == 0)
+                        y = fullArea.height() - area.height();
+                    else
+                        y = fullArea.height() - area.y() - area.height();
+                }
+            }
+            // use scissor to restrict painting of the reflection plane to current screen
+            glScissor(area.x(), y, area.width(), area.height());
+            glEnable(GL_SCISSOR_TEST);
+
+            if (m_reflectionShader && m_reflectionShader->isValid()) {
+                ShaderManager::instance()->pushShader(m_reflectionShader);
+                QMatrix4x4 windowTransformation = data.projectionMatrix();
+                windowTransformation.translate(area.x() + area.width() * 0.5f, 0.0, 0.0);
+                m_reflectionShader->setUniform(GLShader::ModelViewProjectionMatrix, windowTransformation);
+                m_reflectionShader->setUniform("u_frontColor", QVector4D(mirrorColor[0][0], mirrorColor[0][1], mirrorColor[0][2], mirrorColor[0][3]));
+                m_reflectionShader->setUniform("u_backColor", QVector4D(mirrorColor[1][0], mirrorColor[1][1], mirrorColor[1][2], mirrorColor[1][3]));
+                // TODO: make this one properly
+                QVector<float> verts;
+                QVector<float> texcoords;
+                verts.reserve(18);
+                texcoords.reserve(12);
+                texcoords << 1.0 << 0.0;
+                verts << vertices[6] << vertices[7] << vertices[8];
+                texcoords << 1.0 << 0.0;
+                verts << vertices[9] << vertices[10] << vertices[11];
+                texcoords << 0.0 << 0.0;
+                verts << vertices[0] << vertices[1] << vertices[2];
+                texcoords << 0.0 << 0.0;
+                verts << vertices[0] << vertices[1] << vertices[2];
+                texcoords << 0.0 << 0.0;
+                verts << vertices[3] << vertices[4] << vertices[5];
+                texcoords << 1.0 << 0.0;
+                verts << vertices[6] << vertices[7] << vertices[8];
+                GLVertexBuffer *vbo = GLVertexBuffer::streamingBuffer();
+                vbo->reset();
+                vbo->setData(6, 3, verts.data(), texcoords.data());
+                vbo->render(GL_TRIANGLES);
+
+                ShaderManager::instance()->popShader();
+            }
+            glDisable(GL_SCISSOR_TEST);
+            glDisable(GL_BLEND);
+        }
+        paintScene(frontWindow, leftWindows, rightWindows);
+
+        // Render the caption frame
+        if (windowTitle) {
+            double opacity = 1.0;
+            if (start)
+                opacity = timeLine.value();
+            else if (stop)
+                opacity = 1.0 - timeLine.value();
+            if (animation)
+                captionFrame->setCrossFadeProgress(timeLine.value());
+            captionFrame->render(region, opacity);
+        }
+    }
+}
+
+void CoverSwitchEffect::postPaintScreen()
+{
+    if ((mActivated && (animation || start)) || stop || stopRequested) {
+        if (timeLine.done()) {
+            timeLine.reset();
+            lastPresentTime = std::chrono::milliseconds::zero();
+            if (stop) {
+                stop = false;
+                effects->setActiveFullScreenEffect(nullptr);
+                Q_FOREACH (EffectWindow * window, referrencedWindows) {
+                    window->unrefWindow();
+                }
+                referrencedWindows.clear();
+                currentWindowList.clear();
+                if (startRequested) {
+                    startRequested = false;
+                    mActivated = true;
+                    effects->refTabBox();
+                    currentWindowList = effects->currentTabBoxWindowList();
+                    if (animateStart) {
+                        start = true;
+                    }
+                }
+            } else if (!scheduled_directions.isEmpty()) {
+                direction = scheduled_directions.dequeue();
+                if (start) {
+                    animation = true;
+                    start = false;
+                }
+            } else {
+                animation = false;
+                start = false;
+                if (stopRequested) {
+                    stopRequested = false;
+                    stop = true;
+                }
+            }
+        }
+        effects->addRepaintFull();
+    }
+    effects->postPaintScreen();
+}
+
+void CoverSwitchEffect::paintScene(EffectWindow* frontWindow, const EffectWindowList& leftWindows,
+                                   const EffectWindowList& rightWindows, bool reflectedWindows)
+{
+    // LAYOUT
+    // one window in the front. Other windows left and right rotated
+    // for odd number of windows: left: (n-1)/2; front: 1; right: (n-1)/2
+    // for even number of windows: left: n/2; front: 1; right: n/2 -1
+    //
+    // ANIMATION
+    // forward (alt+tab)
+    // all left windows are moved to next position
+    // top most left window is rotated and moved to front window position
+    // front window is rotated and moved to next right window position
+    // right windows are moved to next position
+    // last right window becomes totally transparent in half the time
+    // appears transparent on left side and becomes totally opaque again
+    // backward (alt+shift+tab) same as forward but opposite direction
+    int width = area.width();
+    int leftWindowCount = leftWindows.count();
+    int rightWindowCount = rightWindows.count();
+
+
+    // Problem during animation: a window which is painted after another window
+    // appears in front of the other
+    // so during animation the painting order has to be rearreanged
+    // paint sequence no animation: left, right, front
+    // paint sequence forward animation: right, front, left
+
+    if (!animation) {
+        paintWindows(leftWindows, true, reflectedWindows);
+        paintWindows(rightWindows, false, reflectedWindows);
+        paintFrontWindow(frontWindow, width, leftWindowCount, rightWindowCount, reflectedWindows);
+    } else {
+        if (direction == Right) {
+            if (timeLine.value() < 0.5) {
+                // paint in normal way
+                paintWindows(leftWindows, true, reflectedWindows);
+                paintWindows(rightWindows, false, reflectedWindows);
+                paintFrontWindow(frontWindow, width, leftWindowCount, rightWindowCount, reflectedWindows);
+            } else {
+                paintWindows(rightWindows, false, reflectedWindows);
+                paintFrontWindow(frontWindow, width, leftWindowCount, rightWindowCount, reflectedWindows);
+                paintWindows(leftWindows, true, reflectedWindows, rightWindows.at(0));
+            }
+        } else {
+            paintWindows(leftWindows, true, reflectedWindows);
+            if (timeLine.value() < 0.5) {
+                paintWindows(rightWindows, false, reflectedWindows);
+                paintFrontWindow(frontWindow, width, leftWindowCount, rightWindowCount, reflectedWindows);
+            } else {
+                EffectWindow* leftWindow;
+                if (leftWindowCount > 0) {
+                    leftWindow = leftWindows.at(0);
+                    paintFrontWindow(frontWindow, width, leftWindowCount, rightWindowCount, reflectedWindows);
+                } else
+                    leftWindow = frontWindow;
+                paintWindows(rightWindows, false, reflectedWindows, leftWindow);
+            }
+        }
+    }
+}
+
+void CoverSwitchEffect::paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data)
+{
+    if (mActivated || stop || stopRequested) {
+        if (!(mask & PAINT_WINDOW_TRANSFORMED) && !w->isDesktop()) {
+            if ((start || stop) && w->isDock()) {
+                data.setOpacity(1.0 - timeLine.value());
+                if (stop)
+                    data.setOpacity(timeLine.value());
+            } else
+                return;
+        }
+    }
+    if ((start || stop) && (!w->isOnCurrentDesktop() || w->isMinimized())) {
+        if (stop)  // Fade out windows not on the current desktop
+            data.setOpacity(1.0 - timeLine.value());
+        else // Fade in Windows from other desktops when animation is started
+            data.setOpacity(timeLine.value());
+    }
+    effects->paintWindow(w, mask, region, data);
+}
+
+void CoverSwitchEffect::slotTabBoxAdded(int mode)
+{
+    if (effects->activeFullScreenEffect() && effects->activeFullScreenEffect() != this)
+        return;
+    if (!mActivated) {
+        effects->setShowingDesktop(false);
+        // only for windows mode
+        if (((mode == TabBoxWindowsMode && primaryTabBox) ||
+                (mode == TabBoxWindowsAlternativeMode && secondaryTabBox) ||
+                (mode == TabBoxCurrentAppWindowsMode && primaryTabBox) ||
+                (mode == TabBoxCurrentAppWindowsAlternativeMode && secondaryTabBox))
+                && effects->currentTabBoxWindowList().count() > 0) {
+            effects->startMouseInterception(this, Qt::ArrowCursor);
+            activeScreen = effects->activeScreen();
+            if (!stop && !stopRequested) {
+                effects->refTabBox();
+                effects->setActiveFullScreenEffect(this);
+                scheduled_directions.clear();
+                selected_window = effects->currentTabBoxWindow();
+                currentWindowList = effects->currentTabBoxWindowList();
+                direction = Left;
+                mActivated = true;
+                if (animateStart) {
+                    start = true;
+                }
+
+                // Calculation of correct area
+                area = effects->clientArea(FullScreenArea, activeScreen, effects->currentDesktop());
+                const QSize screenSize = effects->virtualScreenSize();
+                scaleFactor = (zPosition + 1100) * 2.0 * tan(60.0 * M_PI / 360.0f) / screenSize.width();
+                if (screenSize.width() - area.width() != 0) {
+                    // one of the screens is smaller than the other (horizontal)
+                    if (area.width() < screenSize.width() - area.width())
+                        scaleFactor *= (float)area.width() / (float)(screenSize.width() - area.width());
+                    else if (area.width() != screenSize.width() - area.width()) {
+                        // vertical layout with different width
+                        // but we don't want to catch screens with same width and different height
+                        if (screenSize.height() != area.height())
+                            scaleFactor *= (float)area.width() / (float)(screenSize.width());
+                    }
+                }
+
+                if (effects->numScreens() > 1) {
+                    // unfortunatelly we have to change the projection matrix in dual screen mode
+                    // code is adapted from SceneOpenGL2::createProjectionMatrix()
+                    QRect fullRect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+                    float fovy = 60.0f;
+                    float aspect = 1.0f;
+                    float zNear = 0.1f;
+                    float zFar = 100.0f;
+
+                    float ymax = zNear * std::tan(fovy * M_PI / 360.0f);
+                    float ymin = -ymax;
+                    float xmin =  ymin * aspect;
+                    float xmax = ymax * aspect;
+
+                    if (area.width() != fullRect.width()) {
+                        if (area.x() == 0) {
+                            // horizontal layout: left screen
+                            xmin *= (float)area.width() / (float)fullRect.width();
+                            xmax *= (fullRect.width() - 0.5f * area.width()) / (0.5f * fullRect.width());
+                        } else {
+                            // horizontal layout: right screen
+                            xmin *= (fullRect.width() - 0.5f * area.width()) / (0.5f * fullRect.width());
+                            xmax *= (float)area.width() / (float)fullRect.width();
+                        }
+                    }
+                    if (area.height() != fullRect.height()) {
+                        if (area.y() == 0) {
+                            // vertical layout: top screen
+                            ymin *= (fullRect.height() - 0.5f * area.height()) / (0.5f * fullRect.height());
+                            ymax *= (float)area.height() / (float)fullRect.height();
+                        } else {
+                            // vertical layout: bottom screen
+                            ymin *= (float)area.height() / (float)fullRect.height();
+                            ymax *= (fullRect.height() - 0.5f * area.height()) / (0.5f * fullRect.height());
+                        }
+                    }
+
+                    m_projectionMatrix = QMatrix4x4();
+                    m_projectionMatrix.frustum(xmin, xmax, ymin, ymax, zNear, zFar);
+
+                    const float scaleFactor = 1.1f / zNear;
+
+                    // Create a second matrix that transforms screen coordinates
+                    // to world coordinates.
+                    QMatrix4x4 matrix;
+                    matrix.translate(xmin * scaleFactor, ymax * scaleFactor, -1.1);
+                    matrix.scale( (xmax - xmin) * scaleFactor / fullRect.width(),
+                                -(ymax - ymin) * scaleFactor / fullRect.height(),
+                                0.001);
+                    // Combine the matrices
+                    m_projectionMatrix *= matrix;
+
+                    m_modelviewMatrix = QMatrix4x4();
+                    m_modelviewMatrix.translate(area.x(), area.y(), 0.0);
+                }
+
+                // Setup caption frame geometry
+                if (windowTitle) {
+                    QRect frameRect = QRect(area.width() * 0.25f + area.x(),
+                                            area.height() * 0.9f + area.y(),
+                                            area.width() * 0.5f,
+                                            QFontMetrics(captionFont).height());
+                    if (!captionFrame) {
+                        captionFrame = effects->effectFrame(EffectFrameStyled);
+                        captionFrame->setFont(captionFont);
+                        captionFrame->enableCrossFade(true);
+                    }
+                    captionFrame->setGeometry(frameRect);
+                    captionFrame->setIconSize(QSize(frameRect.height(), frameRect.height()));
+                    // And initial contents
+                    updateCaption();
+                }
+
+                effects->addRepaintFull();
+            } else {
+                startRequested = true;
+            }
+        }
+    }
+}
+
+void CoverSwitchEffect::slotTabBoxClosed()
+{
+    if (mActivated) {
+        if (animateStop) {
+            if (!animation && !start) {
+                stop = true;
+            } else if (start && scheduled_directions.isEmpty()) {
+                start = false;
+                stop = true;
+                timeLine.setElapsed(timeLine.duration() - timeLine.elapsed());
+            } else {
+                stopRequested = true;
+            }
+        } else {
+            effects->setActiveFullScreenEffect(nullptr);
+            start = false;
+            animation = false;
+            timeLine.reset();
+            lastPresentTime = std::chrono::milliseconds::zero();
+        }
+        mActivated = false;
+        effects->unrefTabBox();
+        effects->stopMouseInterception(this);
+        effects->addRepaintFull();
+    }
+}
+
+void CoverSwitchEffect::slotTabBoxUpdated()
+{
+    if (mActivated) {
+        if (animateSwitch && currentWindowList.count() > 1) {
+            // determine the switch direction
+            if (selected_window != effects->currentTabBoxWindow()) {
+                if (selected_window != nullptr) {
+                    int old_index = currentWindowList.indexOf(selected_window);
+                    int new_index = effects->currentTabBoxWindowList().indexOf(effects->currentTabBoxWindow());
+                    Direction new_direction;
+                    int distance = new_index - old_index;
+                    if (distance > 0)
+                        new_direction = Left;
+                    if (distance < 0)
+                        new_direction = Right;
+                    if (effects->currentTabBoxWindowList().count() == 2) {
+                        new_direction = Left;
+                        distance = 1;
+                    }
+                    if (distance != 0) {
+                        distance = abs(distance);
+                        int tempDistance = effects->currentTabBoxWindowList().count() - distance;
+                        if (tempDistance < abs(distance)) {
+                            distance = tempDistance;
+                            if (new_direction == Left)
+                                new_direction = Right;
+                            else
+                                new_direction = Left;
+                        }
+                        if (!animation && !start) {
+                            animation = true;
+                            direction = new_direction;
+                            distance--;
+                        }
+                        for (int i = 0; i < distance; i++) {
+                            if (!scheduled_directions.isEmpty() && scheduled_directions.last() != new_direction)
+                                scheduled_directions.pop_back();
+                            else
+                                scheduled_directions.enqueue(new_direction);
+                            if (scheduled_directions.count() == effects->currentTabBoxWindowList().count())
+                                scheduled_directions.clear();
+                        }
+                    }
+                }
+                selected_window = effects->currentTabBoxWindow();
+                currentWindowList = effects->currentTabBoxWindowList();
+                updateCaption();
+            }
+        }
+        effects->addRepaintFull();
+    }
+}
+
+void CoverSwitchEffect::paintWindowCover(EffectWindow* w, bool reflectedWindow, WindowPaintData& data)
+{
+    QRect windowRect = w->frameGeometry();
+    data.setYTranslation(area.height() - windowRect.y() - windowRect.height());
+    data.setZTranslation(-zPosition);
+    if (start) {
+        if (w->isMinimized()) {
+            data.multiplyOpacity(timeLine.value());
+        } else {
+            const QVector3D translation = data.translation() * timeLine.value();
+            data.setXTranslation(translation.x());
+            data.setYTranslation(translation.y());
+            data.setZTranslation(translation.z());
+            if (effects->numScreens() > 1) {
+                QRect clientRect = effects->clientArea(FullScreenArea, w->screen(), effects->currentDesktop());
+                QRect fullRect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+                if (w->screen() == activeScreen) {
+                    if (clientRect.width() != fullRect.width() && clientRect.x() != fullRect.x()) {
+                        data.translate(- clientRect.x() * (1.0f - timeLine.value()));
+                    }
+                    if (clientRect.height() != fullRect.height() && clientRect.y() != fullRect.y()) {
+                        data.translate(0.0, - clientRect.y() * (1.0f - timeLine.value()));
+                    }
+                } else {
+                    if (clientRect.width() != fullRect.width() && clientRect.x() < area.x()) {
+                        data.translate(- clientRect.width() * (1.0f - timeLine.value()));
+                    }
+                    if (clientRect.height() != fullRect.height() && clientRect.y() < area.y()) {
+                        data.translate(0.0, - clientRect.height() * (1.0f - timeLine.value()));
+                    }
+                }
+            }
+            data.setRotationAngle(data.rotationAngle() * timeLine.value());
+        }
+    }
+    if (stop) {
+        if (w->isMinimized() && w != effects->activeWindow()) {
+            data.multiplyOpacity(1.0 - timeLine.value());
+        } else {
+            const QVector3D translation = data.translation() * (1.0 - timeLine.value());
+            data.setXTranslation(translation.x());
+            data.setYTranslation(translation.y());
+            data.setZTranslation(translation.z());
+            if (effects->numScreens() > 1) {
+                QRect clientRect = effects->clientArea(FullScreenArea, w->screen(), effects->currentDesktop());
+                QRect rect = effects->clientArea(FullScreenArea, activeScreen, effects->currentDesktop());
+                QRect fullRect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+                if (w->screen() == activeScreen) {
+                    if (clientRect.width() != fullRect.width() && clientRect.x() != fullRect.x()) {
+                        data.translate(- clientRect.x() * timeLine.value());
+                    }
+                    if (clientRect.height() != fullRect.height() && clientRect.y() != fullRect.y()) {
+                        data.translate(0.0, - clientRect.y() * timeLine.value());
+                    }
+                } else {
+                    if (clientRect.width() != fullRect.width() && clientRect.x() < rect.x()) {
+                        data.translate(- clientRect.width() * timeLine.value());
+                    }
+                    if (clientRect.height() != fullRect.height() && clientRect.y() < area.y()) {
+                        data.translate(0.0, - clientRect.height() * timeLine.value());
+                    }
+                }
+            }
+            data.setRotationAngle(data.rotationAngle() * (1.0 - timeLine.value()));
+        }
+    }
+
+    if (reflectedWindow) {
+        QMatrix4x4 reflectionMatrix;
+        reflectionMatrix.scale(1.0, -1.0, 1.0);
+        data.setModelViewMatrix(reflectionMatrix*data.modelViewMatrix());
+        data.setYTranslation(- area.height() - windowRect.y() - windowRect.height());
+        if (start) {
+            data.multiplyOpacity(timeLine.value());
+        } else if (stop) {
+            data.multiplyOpacity(1.0 - timeLine.value());
+        }
+        effects->drawWindow(w,
+                                PAINT_WINDOW_TRANSFORMED,
+                                infiniteRegion(), data);
+    } else {
+        effects->paintWindow(w,
+                             PAINT_WINDOW_TRANSFORMED,
+                             infiniteRegion(), data);
+    }
+}
+
+void CoverSwitchEffect::paintFrontWindow(EffectWindow* frontWindow, int width, int leftWindows, int rightWindows, bool reflectedWindow)
+{
+    if (frontWindow == nullptr)
+        return;
+    bool specialHandlingForward = false;
+    WindowPaintData data(frontWindow);
+    if (effects->numScreens() > 1) {
+        data.setProjectionMatrix(m_projectionMatrix);
+        data.setModelViewMatrix(m_modelviewMatrix);
+    }
+    data.setXTranslation(area.width() * 0.5 - frontWindow->frameGeometry().x() - frontWindow->frameGeometry().width() * 0.5);
+    if (leftWindows == 0) {
+        leftWindows = 1;
+        if (!start && !stop)
+            specialHandlingForward = true;
+    }
+    if (rightWindows == 0) {
+        rightWindows = 1;
+    }
+    if (animation) {
+      float distance = 0.0;
+      const QSize screenSize = effects->virtualScreenSize();
+      if (direction == Right) {
+            // move to right
+            distance = -frontWindow->frameGeometry().width() * 0.5f + area.width() * 0.5f +
+                       (((float)screenSize.width() * 0.5 * scaleFactor) - (float)area.width() * 0.5f) / rightWindows;
+            data.translate(distance * timeLine.value());
+            data.setRotationAxis(Qt::YAxis);
+            data.setRotationAngle(-angle * timeLine.value());
+            data.setRotationOrigin(QVector3D(frontWindow->frameGeometry().width(), 0.0, 0.0));
+        } else {
+            // move to left
+            distance = frontWindow->frameGeometry().width() * 0.5f - area.width() * 0.5f +
+                       ((float)width * 0.5f - ((float)screenSize.width() * 0.5 * scaleFactor)) / leftWindows;
+            float factor = 1.0;
+            if (specialHandlingForward)
+                factor = 2.0;
+            data.translate(distance * timeLine.value() * factor);
+            data.setRotationAxis(Qt::YAxis);
+            data.setRotationAngle(angle * timeLine.value());
+        }
+    }
+    if (specialHandlingForward && timeLine.value() < 0.5) {
+        data.multiplyOpacity(1.0 - timeLine.value() * 2.0);
+    }
+    paintWindowCover(frontWindow, reflectedWindow, data);
+}
+
+void CoverSwitchEffect::paintWindows(const EffectWindowList& windows, bool left, bool reflectedWindows, EffectWindow* additionalWindow)
+{
+    int width = area.width();
+    int windowCount = windows.count();
+    EffectWindow* window;
+
+    int rotateFactor = 1;
+    if (!left) {
+        rotateFactor = -1;
+    }
+
+    const QSize screenSize = effects->virtualScreenSize();
+    float xTranslate = -((float)(width) * 0.5f - ((float)screenSize.width() * 0.5 * scaleFactor));
+    if (!left)
+        xTranslate = ((float)screenSize.width() * 0.5 * scaleFactor) - (float)width * 0.5f;
+    // handling for additional window from other side
+    // has to appear on this side after half of the time
+    if (animation && timeLine.value() >= 0.5 && additionalWindow != nullptr) {
+        WindowPaintData data(additionalWindow);
+        if (effects->numScreens() > 1) {
+            data.setProjectionMatrix(m_projectionMatrix);
+            data.setModelViewMatrix(m_modelviewMatrix);
+        }
+        data.setRotationAxis(Qt::YAxis);
+        data.setRotationAngle(angle * rotateFactor);
+        if (left) {
+            data.translate(-xTranslate - additionalWindow->frameGeometry().x());
+        }
+        else {
+            data.translate(xTranslate + area.width() -
+                           additionalWindow->frameGeometry().x() - additionalWindow->frameGeometry().width());
+            data.setRotationOrigin(QVector3D(additionalWindow->frameGeometry().width(), 0.0, 0.0));
+        }
+        data.multiplyOpacity((timeLine.value() - 0.5) * 2.0);
+        paintWindowCover(additionalWindow, reflectedWindows, data);
+    }
+    // normal behaviour
+    for (int i = 0; i < windows.count(); i++) {
+        window = windows.at(i);
+        if (window == nullptr || window->isDeleted()) {
+            continue;
+        }
+        WindowPaintData data(window);
+        if (effects->numScreens() > 1) {
+            data.setProjectionMatrix(m_projectionMatrix);
+            data.setModelViewMatrix(m_modelviewMatrix);
+        }
+        data.setRotationAxis(Qt::YAxis);
+        data.setRotationAngle(angle);
+        if (left)
+            data.translate(-xTranslate + xTranslate * i / windowCount - window->frameGeometry().x());
+        else
+            data.translate(xTranslate + width - xTranslate * i / windowCount - window->frameGeometry().x() - window->frameGeometry().width());
+        if (animation) {
+            if (direction == Right) {
+                if ((i == windowCount - 1) && left) {
+                    // right most window on left side -> move to front
+                    // have to move one window distance plus half the difference between the window and the desktop size
+                    data.translate((xTranslate / windowCount + (width - window->frameGeometry().width()) * 0.5f) * timeLine.value());
+                    data.setRotationAngle(angle - angle * timeLine.value());
+                }
+                // right most window does not have to be moved
+                else if (!left && (i == 0));     // do nothing
+                else {
+                    // all other windows - move to next position
+                    data.translate(xTranslate / windowCount * timeLine.value());
+                }
+            } else {
+                if ((i == windowCount - 1) && !left) {
+                    // left most window on right side -> move to front
+                    data.translate(- (xTranslate / windowCount + (width - window->frameGeometry().width()) * 0.5f) * timeLine.value());
+                    data.setRotationAngle(angle - angle * timeLine.value());
+                }
+                // left most window does not have to be moved
+                else if (i == 0 && left); // do nothing
+                else {
+                    // all other windows - move to next position
+                    data.translate(- xTranslate / windowCount * timeLine.value());
+                }
+            }
+        }
+        if (!left)
+            data.setRotationOrigin(QVector3D(window->frameGeometry().width(), 0.0, 0.0));
+        data.setRotationAngle(data.rotationAngle() * rotateFactor);
+        // make window most to edge transparent if animation
+        if (animation && i == 0 && ((direction == Left && left) || (direction == Right && !left))) {
+            // only for the first half of the animation
+            if (timeLine.value() < 0.5) {
+                data.multiplyOpacity((1.0 - timeLine.value() * 2.0));
+                paintWindowCover(window, reflectedWindows, data);
+            }
+        } else {
+            paintWindowCover(window, reflectedWindows, data);
+        }
+    }
+}
+
+void CoverSwitchEffect::windowInputMouseEvent(QEvent* e)
+{
+    if (e->type() != QEvent::MouseButtonPress)
+        return;
+    // we don't want click events during animations
+    if (animation)
+        return;
+    QMouseEvent* event = static_cast< QMouseEvent* >(e);
+
+    switch (event->button()) {
+    case Qt::XButton1: // wheel up
+        selectPreviousWindow();
+        break;
+    case Qt::XButton2: // wheel down
+        selectNextWindow();
+        break;
+    case Qt::LeftButton:
+    case Qt::RightButton:
+    case Qt::MiddleButton:
+    default:
+        QPoint pos = event->pos();
+
+        // determine if a window has been clicked
+        // not interested in events above a fullscreen window (ignoring panel size)
+        if (pos.y() < (area.height()*scaleFactor - area.height()) * 0.5f *(1.0f / scaleFactor))
+            return;
+
+        // if there is no selected window (that is no window at all) we cannot click it
+        if (!selected_window)
+            return;
+
+        if (pos.x() < (area.width()*scaleFactor - selected_window->width()) * 0.5f *(1.0f / scaleFactor)) {
+            float availableSize = (area.width() * scaleFactor - area.width()) * 0.5f * (1.0f / scaleFactor);
+            for (int i = 0; i < leftWindows.count(); i++) {
+                int windowPos = availableSize / leftWindows.count() * i;
+                if (pos.x() < windowPos)
+                    continue;
+                if (i + 1 < leftWindows.count()) {
+                    if (pos.x() > availableSize / leftWindows.count()*(i + 1))
+                        continue;
+                }
+
+                effects->setTabBoxWindow(leftWindows[i]);
+                return;
+            }
+        }
+
+        if (pos.x() > area.width() - (area.width()*scaleFactor - selected_window->width()) * 0.5f *(1.0f / scaleFactor)) {
+            float availableSize = (area.width() * scaleFactor - area.width()) * 0.5f * (1.0f / scaleFactor);
+            for (int i = 0; i < rightWindows.count(); i++) {
+                int windowPos = area.width() - availableSize / rightWindows.count() * i;
+                if (pos.x() > windowPos)
+                    continue;
+                if (i + 1 < rightWindows.count()) {
+                    if (pos.x() < area.width() - availableSize / rightWindows.count()*(i + 1))
+                        continue;
+                }
+
+                effects->setTabBoxWindow(rightWindows[i]);
+                return;
+            }
+        }
+        break;
+    }
+}
+
+void CoverSwitchEffect::abort()
+{
+    // it's possible that abort is called after tabbox has been closed
+    // in this case the cleanup is already done (see bug 207554)
+    if (mActivated) {
+        effects->unrefTabBox();
+        effects->stopMouseInterception(this);
+    }
+    effects->setActiveFullScreenEffect(nullptr);
+    timeLine.reset();
+    lastPresentTime = std::chrono::milliseconds::zero();
+    mActivated = false;
+    stop = false;
+    stopRequested = false;
+    effects->addRepaintFull();
+    captionFrame->free();
+}
+
+void CoverSwitchEffect::slotWindowClosed(EffectWindow* c)
+{
+    if (c == selected_window)
+        selected_window = nullptr;
+    // if the list is not empty, the effect is active
+    if (!currentWindowList.isEmpty()) {
+        c->refWindow();
+        referrencedWindows.append(c);
+        currentWindowList.removeAll(c);
+        leftWindows.removeAll(c);
+        rightWindows.removeAll(c);
+    }
+}
+
+bool CoverSwitchEffect::isActive() const
+{
+    return (mActivated || stop || stopRequested) && !effects->isScreenLocked();
+}
+
+void CoverSwitchEffect::updateCaption()
+{
+    if (!selected_window || !windowTitle) {
+        return;
+    }
+    if (selected_window->isDesktop()) {
+        captionFrame->setText(i18nc("Special entry in alt+tab list for minimizing all windows",
+                     "Show Desktop"));
+        static QPixmap pix = QIcon::fromTheme(QStringLiteral("user-desktop")).pixmap(captionFrame->iconSize());
+        captionFrame->setIcon(pix);
+    } else {
+        captionFrame->setText(selected_window->caption());
+        captionFrame->setIcon(selected_window->icon());
+    }
+}
+
+void CoverSwitchEffect::slotTabBoxKeyEvent(QKeyEvent *event)
+{
+    if (event->type() == QEvent::KeyPress) {
+        switch (event->key()) {
+        case Qt::Key_Left:
+            selectPreviousWindow();
+            break;
+        case Qt::Key_Right:
+            selectNextWindow();
+            break;
+        default:
+            // nothing
+            break;
+        }
+    }
+}
+
+void CoverSwitchEffect::selectNextOrPreviousWindow(bool forward)
+{
+    if (!mActivated || !selected_window) {
+        return;
+    }
+    const int index = effects->currentTabBoxWindowList().indexOf(selected_window);
+    int newIndex = index;
+    if (forward) {
+        ++newIndex;
+    } else {
+        --newIndex;
+    }
+    if (newIndex == effects->currentTabBoxWindowList().size()) {
+        newIndex = 0;
+    } else if (newIndex < 0) {
+        newIndex = effects->currentTabBoxWindowList().size() -1;
+    }
+    if (index == newIndex) {
+        return;
+    }
+    effects->setTabBoxWindow(effects->currentTabBoxWindowList().at(newIndex));
+}
+
+} // namespace
diff --git a/src/effects/coverswitch/coverswitch.h b/src/effects/coverswitch/coverswitch.h
new file mode 100644
index 000000000..a3202f0f2
--- /dev/null
+++ b/src/effects/coverswitch/coverswitch.h
@@ -0,0 +1,156 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_COVERSWITCH_H
+#define KWIN_COVERSWITCH_H
+
+#include <QHash>
+#include <QRect>
+#include <QRegion>
+#include <QSize>
+#include <QFont>
+#include <QQueue>
+
+#include <kwineffects.h>
+#include <kwinglutils.h>
+
+namespace KWin
+{
+
+class CoverSwitchEffect
+    : public Effect
+{
+    Q_OBJECT
+    Q_PROPERTY(int animationDuration READ configuredAnimationDuration)
+    Q_PROPERTY(bool animateSwitch READ isAnimateSwitch)
+    Q_PROPERTY(bool animateStart READ isAnimateStart)
+    Q_PROPERTY(bool animateStop READ isAnimateStop)
+    Q_PROPERTY(bool reflection READ isReflection)
+    Q_PROPERTY(bool windowTitle READ isWindowTitle)
+    Q_PROPERTY(qreal zPosition READ windowZPosition)
+    Q_PROPERTY(bool primaryTabBox READ isPrimaryTabBox)
+    Q_PROPERTY(bool secondaryTabBox READ isSecondaryTabBox)
+    // TODO: mirror colors
+public:
+    CoverSwitchEffect();
+    ~CoverSwitchEffect() override;
+
+    void reconfigure(ReconfigureFlags) override;
+    void prePaintScreen(ScreenPrePaintData &data, std::chrono::milliseconds presentTime) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData &data) override;
+    void postPaintScreen() override;
+    void paintWindow(EffectWindow *w, int mask, QRegion region, WindowPaintData &data) override;
+    void windowInputMouseEvent(QEvent *e) override;
+    bool isActive() const override;
+
+    static bool supported();
+
+    // for properties
+    int configuredAnimationDuration() const {
+        return animationDuration.count();
+    }
+    bool isAnimateSwitch() const {
+        return animateSwitch;
+    }
+    bool isAnimateStart() const {
+        return animateStart;
+    }
+    bool isAnimateStop() const {
+        return animateStop;
+    }
+    bool isReflection() const {
+        return reflection;
+    }
+    bool isWindowTitle() const {
+        return windowTitle;
+    }
+    qreal windowZPosition() const {
+        return zPosition;
+    }
+    bool isPrimaryTabBox() const {
+        return primaryTabBox;
+    }
+    bool isSecondaryTabBox() const {
+        return secondaryTabBox;
+    }
+
+    int requestedEffectChainPosition() const override {
+        return 50;
+    }
+
+public Q_SLOTS:
+    void slotWindowClosed(KWin::EffectWindow *c);
+    void slotTabBoxAdded(int mode);
+    void slotTabBoxClosed();
+    void slotTabBoxUpdated();
+    void slotTabBoxKeyEvent(QKeyEvent* event);
+
+private:
+    void paintScene(EffectWindow* frontWindow, const EffectWindowList& leftWindows, const EffectWindowList& rightWindows,
+                    bool reflectedWindows = false);
+    void paintWindowCover(EffectWindow* w, bool reflectedWindow, WindowPaintData& data);
+    void paintFrontWindow(EffectWindow* frontWindow, int width, int leftWindows, int rightWindows, bool reflectedWindow);
+    void paintWindows(const EffectWindowList& windows, bool left, bool reflectedWindows, EffectWindow* additionalWindow = nullptr);
+    void selectNextOrPreviousWindow(bool forward);
+    inline void selectNextWindow() { selectNextOrPreviousWindow(true); }
+    inline void selectPreviousWindow() { selectNextOrPreviousWindow(false); }
+    void abort();
+    /**
+     * Updates the caption of the caption frame.
+     * Taking care of rewording the desktop client.
+     * As well sets the icon for the caption frame.
+     */
+    void updateCaption();
+
+    bool mActivated;
+    float angle;
+    bool animateSwitch;
+    bool animateStart;
+    bool animateStop;
+    bool animation;
+    bool start;
+    bool stop;
+    bool reflection;
+    float mirrorColor[2][4];
+    bool windowTitle;
+    std::chrono::milliseconds animationDuration;
+    bool stopRequested;
+    bool startRequested;
+    TimeLine timeLine;
+    std::chrono::milliseconds lastPresentTime;
+    QRect area;
+    float zPosition;
+    float scaleFactor;
+    enum Direction {
+        Left,
+        Right
+    };
+    Direction direction;
+    QQueue<Direction> scheduled_directions;
+    EffectWindow* selected_window;
+    int activeScreen;
+    QList< EffectWindow* > leftWindows;
+    QList< EffectWindow* > rightWindows;
+    EffectWindowList currentWindowList;
+    EffectWindowList referrencedWindows;
+
+    EffectFrame* captionFrame;
+    QFont captionFont;
+
+    bool primaryTabBox;
+    bool secondaryTabBox;
+
+    GLShader *m_reflectionShader;
+    QMatrix4x4 m_projectionMatrix;
+    QMatrix4x4 m_modelviewMatrix;
+};
+
+} // namespace
+
+#endif
diff --git a/src/effects/coverswitch/coverswitch.kcfg b/src/effects/coverswitch/coverswitch.kcfg
new file mode 100644
index 000000000..77db6d29b
--- /dev/null
+++ b/src/effects/coverswitch/coverswitch.kcfg
@@ -0,0 +1,42 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<kcfg xmlns="http://www.kde.org/standards/kcfg/1.0"
+      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+      xsi:schemaLocation="http://www.kde.org/standards/kcfg/1.0
+                          http://www.kde.org/standards/kcfg/1.0/kcfg.xsd" >
+    <kcfgfile arg="true"/>
+    <group name="Effect-CoverSwitch">
+        <entry name="Duration" type="UInt">
+            <default>0</default>
+        </entry>
+        <entry name="AnimateSwitch" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="AnimateStart" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="AnimateStop" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="Reflection" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="MirrorFrontColor" type="Color">
+            <default code="true">QColor(0, 0, 0)</default>
+        </entry>
+        <entry name="MirrorRearColor" type="Color">
+            <default code="true">QColor(0, 0, 0)</default>
+        </entry>
+        <entry name="WindowTitle" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="zPosition" type="UInt">
+            <default>900</default>
+        </entry>
+        <entry name="TabBox" type="Bool">
+            <default>false</default>
+        </entry>
+        <entry name="TabBoxAlternative" type="Bool">
+            <default>false</default>
+        </entry>
+    </group>
+</kcfg>
diff --git a/src/effects/coverswitch/coverswitch_config.cpp b/src/effects/coverswitch/coverswitch_config.cpp
new file mode 100644
index 000000000..9e581b3c8
--- /dev/null
+++ b/src/effects/coverswitch/coverswitch_config.cpp
@@ -0,0 +1,56 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#include "coverswitch_config.h"
+// KConfigSkeleton
+#include "coverswitchconfig.h"
+#include <config-kwin.h>
+
+#include <kwineffects_interface.h>
+#include <KAboutData>
+#include <KPluginFactory>
+
+#include <QVBoxLayout>
+
+K_PLUGIN_FACTORY_WITH_JSON(CoverSwitchEffectConfigFactory,
+                           "coverswitch_config.json",
+                           registerPlugin<KWin::CoverSwitchEffectConfig>();)
+
+namespace KWin
+{
+
+CoverSwitchEffectConfigForm::CoverSwitchEffectConfigForm(QWidget* parent) : QWidget(parent)
+{
+    setupUi(this);
+}
+
+CoverSwitchEffectConfig::CoverSwitchEffectConfig(QWidget* parent, const QVariantList& args) :
+    KCModule(parent, args)
+{
+    m_ui = new CoverSwitchEffectConfigForm(this);
+
+    QVBoxLayout* layout = new QVBoxLayout(this);
+
+    layout->addWidget(m_ui);
+
+    CoverSwitchConfig::instance(KWIN_CONFIG);
+    addConfig(CoverSwitchConfig::self(), m_ui);
+}
+
+void CoverSwitchEffectConfig::save()
+{
+    KCModule::save();
+    OrgKdeKwinEffectsInterface interface(QStringLiteral("org.kde.KWin"),
+                                         QStringLiteral("/Effects"),
+                                         QDBusConnection::sessionBus());
+    interface.reconfigureEffect(QStringLiteral("coverswitch"));
+}
+
+} // namespace
+
+#include "coverswitch_config.moc"
diff --git a/src/effects/coverswitch/coverswitch_config.desktop b/src/effects/coverswitch/coverswitch_config.desktop
new file mode 100644
index 000000000..27ba8e79a
--- /dev/null
+++ b/src/effects/coverswitch/coverswitch_config.desktop
@@ -0,0 +1,76 @@
+[Desktop Entry]
+Type=Service
+X-KDE-ServiceTypes=KCModule
+
+X-KDE-Library=kwin_coverswitch_config
+X-KDE-ParentComponents=coverswitch
+
+Name=Cover Switch
+Name[ar]=تبديل الأغلفة
+Name[az]=Karusel
+Name[bg]=Прелистване на страници
+Name[bn]=আবরণ বদল
+Name[bs]=Protočno prebacivanje
+Name[ca]=Canvi de capa
+Name[ca@valencia]=Canvi de capa
+Name[cs]=Přehlídka oken
+Name[da]=Cover-skifter
+Name[de]=3D-Fenstergalerie
+Name[el]=Εναλλαγή εξωφύλλου
+Name[en_GB]=Cover Switch
+Name[eo]=Kovra ŝanĝilo
+Name[es]=Selección de ventana en modo carátula
+Name[et]=Aknalülitaja
+Name[eu]=Leiho-argazkien aldaketa
+Name[fi]=Levykansivaihtaja
+Name[fr]=Défilement circulaire
+Name[fy]=Foarplaat wiksel
+Name[ga]=Cover Switch
+Name[gl]=Cambio en capas
+Name[gu]=ફેરફાર ઢાંકો
+Name[he]=מחליף כיסויים
+Name[hi]=कवर स्विच
+Name[hne]=कवर स्विच
+Name[hr]=Pokrivač – promjena
+Name[hu]=Fedett váltódoboz
+Name[ia]=Commutator de copertura
+Name[id]=Beralih Sampul
+Name[is]=Síðuskiptir
+Name[it]=Scambiafinestre circolare
+Name[ja]=カバースイッチ
+Name[kk]=Cover Switch
+Name[km]=ប្ដូរ​​គម្រប​
+Name[kn]=ಕವರ್ ಸ್ವಿಚ್
+Name[ko]=커버 전환기
+Name[lt]=Viršelių perjungiklis
+Name[lv]=Vāku pārslēdzējs
+Name[ml]=കവര്‍ സ്വിച്ച്
+Name[mr]=कव्हर स्विच
+Name[nb]=Omslagsbytter
+Name[nds]=Cover Switch
+Name[nl]=Omslagtonen
+Name[nn]=Omslagvekslar
+Name[pa]=ਕਵਰ ਸਵਿੱਚ
+Name[pl]=Przełączanie okładek
+Name[pt]=Mudança de Capas
+Name[pt_BR]=Seleção em capas
+Name[ro]=Comutare copertă
+Name[ru]=Карусель
+Name[si]=කවර මාරුව 
+Name[sk]=Prepínať s gáleriou
+Name[sl]=Preklapljanje - ovitki
+Name[sr]=Проточно пребацивање
+Name[sr@ijekavian]=Проточно пребацивање
+Name[sr@ijekavianlatin]=Protočno prebacivanje
+Name[sr@latin]=Protočno prebacivanje
+Name[sv]=Omslagsbyte
+Name[ta]=Cover Switch
+Name[te]=కవర్ స్విచ్
+Name[th]=สลับหน้าต่างแบบปกเทป
+Name[tr]=Kapak Pencere Seçici
+Name[ug]=قاپنى ئالماشتۇر
+Name[uk]=Перемикач обкладинок
+Name[wa]=Discandjeu d' coviete
+Name[x-test]=xxCover Switchxx
+Name[zh_CN]=3D 封面切换
+Name[zh_TW]=覆蓋切換
diff --git a/src/effects/coverswitch/coverswitch_config.h b/src/effects/coverswitch/coverswitch_config.h
new file mode 100644
index 000000000..91d7649ee
--- /dev/null
+++ b/src/effects/coverswitch/coverswitch_config.h
@@ -0,0 +1,43 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_COVERSWITCH_CONFIG_H
+#define KWIN_COVERSWITCH_CONFIG_H
+
+#include <kcmodule.h>
+
+#include "ui_coverswitch_config.h"
+
+
+namespace KWin
+{
+
+class CoverSwitchEffectConfigForm : public QWidget, public Ui::CoverSwitchEffectConfigForm
+{
+    Q_OBJECT
+public:
+    explicit CoverSwitchEffectConfigForm(QWidget* parent);
+};
+
+class CoverSwitchEffectConfig : public KCModule
+{
+    Q_OBJECT
+public:
+    explicit CoverSwitchEffectConfig(QWidget* parent = nullptr, const QVariantList& args = QVariantList());
+
+public Q_SLOTS:
+    void save() override;
+
+private:
+    CoverSwitchEffectConfigForm* m_ui;
+};
+
+} // namespace
+
+#endif
diff --git a/src/effects/coverswitch/coverswitch_config.ui b/src/effects/coverswitch/coverswitch_config.ui
new file mode 100644
index 000000000..982caf6d1
--- /dev/null
+++ b/src/effects/coverswitch/coverswitch_config.ui
@@ -0,0 +1,307 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>KWin::CoverSwitchEffectConfigForm</class>
+ <widget class="QWidget" name="KWin::CoverSwitchEffectConfigForm">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>453</width>
+    <height>270</height>
+   </rect>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout_5">
+   <item>
+    <widget class="QCheckBox" name="kcfg_WindowTitle">
+     <property name="text">
+      <string>Display window &amp;titles</string>
+     </property>
+     <property name="shortcut">
+      <string/>
+     </property>
+    </widget>
+   </item>
+   <item>
+    <layout class="QVBoxLayout" name="verticalLayout_4">
+     <item>
+      <widget class="QLabel" name="label_4">
+       <property name="text">
+        <string>Zoom</string>
+       </property>
+       <property name="alignment">
+        <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <widget class="QSlider" name="kcfg_zPosition">
+       <property name="toolTip">
+        <string>Define how far away the windows should appear</string>
+       </property>
+       <property name="maximum">
+        <number>3000</number>
+       </property>
+       <property name="singleStep">
+        <number>100</number>
+       </property>
+       <property name="pageStep">
+        <number>500</number>
+       </property>
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="tickPosition">
+        <enum>QSlider::TicksBelow</enum>
+       </property>
+       <property name="tickInterval">
+        <number>200</number>
+       </property>
+      </widget>
+     </item>
+     <item>
+      <layout class="QHBoxLayout" name="horizontalLayout">
+       <item>
+        <widget class="QLabel" name="label_8">
+         <property name="text">
+          <string>Near</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <spacer name="horizontalSpacer">
+         <property name="orientation">
+          <enum>Qt::Horizontal</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>40</width>
+           <height>20</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+       <item>
+        <widget class="QLabel" name="label_9">
+         <property name="text">
+          <string>Far</string>
+         </property>
+         <property name="alignment">
+          <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+         </property>
+        </widget>
+       </item>
+      </layout>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <widget class="QTabWidget" name="tabWidget">
+     <property name="sizePolicy">
+      <sizepolicy hsizetype="MinimumExpanding" vsizetype="Expanding">
+       <horstretch>0</horstretch>
+       <verstretch>0</verstretch>
+      </sizepolicy>
+     </property>
+     <property name="currentIndex">
+      <number>0</number>
+     </property>
+     <widget class="QWidget" name="tab">
+      <attribute name="title">
+       <string>Animation</string>
+      </attribute>
+      <layout class="QVBoxLayout" name="verticalLayout">
+       <item>
+        <widget class="QCheckBox" name="kcfg_AnimateSwitch">
+         <property name="text">
+          <string>Animate switch</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QCheckBox" name="kcfg_AnimateStart">
+         <property name="text">
+          <string>Animation on tab box open</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QCheckBox" name="kcfg_AnimateStop">
+         <property name="text">
+          <string>Animation on tab box close</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <layout class="QFormLayout" name="formLayout_2">
+         <item row="0" column="0">
+          <widget class="QLabel" name="label_3">
+           <property name="text">
+            <string>Animation duration:</string>
+           </property>
+           <property name="alignment">
+            <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+           </property>
+           <property name="buddy">
+            <cstring>kcfg_Duration</cstring>
+           </property>
+          </widget>
+         </item>
+         <item row="0" column="1">
+          <widget class="QSpinBox" name="kcfg_Duration">
+           <property name="sizePolicy">
+            <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+             <horstretch>0</horstretch>
+             <verstretch>0</verstretch>
+            </sizepolicy>
+           </property>
+           <property name="specialValueText">
+            <string comment="Duration of rotation">Default</string>
+           </property>
+           <property name="suffix">
+            <string> milliseconds</string>
+           </property>
+           <property name="maximum">
+            <number>9999</number>
+           </property>
+           <property name="singleStep">
+            <number>10</number>
+           </property>
+          </widget>
+         </item>
+        </layout>
+       </item>
+      </layout>
+     </widget>
+     <widget class="QWidget" name="tab_3">
+      <attribute name="title">
+       <string>Reflections</string>
+      </attribute>
+      <layout class="QVBoxLayout" name="verticalLayout_3">
+       <item>
+        <widget class="QCheckBox" name="kcfg_Reflection">
+         <property name="text">
+          <string>Reflections</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <layout class="QFormLayout" name="formLayout_3">
+         <property name="fieldGrowthPolicy">
+          <enum>QFormLayout::FieldsStayAtSizeHint</enum>
+         </property>
+         <item row="0" column="0">
+          <widget class="QLabel" name="label_2">
+           <property name="text">
+            <string>Rear color</string>
+           </property>
+          </widget>
+         </item>
+         <item row="0" column="1">
+          <widget class="KColorButton" name="kcfg_MirrorRearColor"/>
+         </item>
+         <item row="1" column="0">
+          <widget class="QLabel" name="label">
+           <property name="text">
+            <string>Front color</string>
+           </property>
+          </widget>
+         </item>
+         <item row="1" column="1">
+          <widget class="KColorButton" name="kcfg_MirrorFrontColor"/>
+         </item>
+        </layout>
+       </item>
+      </layout>
+     </widget>
+    </widget>
+   </item>
+   <item>
+    <spacer name="verticalSpacer_2">
+     <property name="orientation">
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeHint" stdset="0">
+      <size>
+       <width>20</width>
+       <height>0</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+  </layout>
+ </widget>
+ <customwidgets>
+  <customwidget>
+   <class>KColorButton</class>
+   <extends>QPushButton</extends>
+   <header>kcolorbutton.h</header>
+  </customwidget>
+ </customwidgets>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>kcfg_Reflection</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>kcfg_MirrorFrontColor</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>60</x>
+     <y>49</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>282</x>
+     <y>110</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>kcfg_Reflection</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>kcfg_MirrorRearColor</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>102</x>
+     <y>51</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>284</x>
+     <y>72</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>kcfg_Reflection</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label_2</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>136</x>
+     <y>47</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>202</x>
+     <y>78</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>kcfg_Reflection</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>label</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>175</x>
+     <y>49</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>209</x>
+     <y>102</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
diff --git a/src/effects/coverswitch/coverswitchconfig.kcfgc b/src/effects/coverswitch/coverswitchconfig.kcfgc
new file mode 100644
index 000000000..c23d13a33
--- /dev/null
+++ b/src/effects/coverswitch/coverswitchconfig.kcfgc
@@ -0,0 +1,5 @@
+File=coverswitch.kcfg
+ClassName=CoverSwitchConfig
+NameSpace=KWin
+Singleton=true
+Mutators=true
diff --git a/src/effects/coverswitch/shaders/1.10/coverswitch-reflection.glsl b/src/effects/coverswitch/shaders/1.10/coverswitch-reflection.glsl
new file mode 100644
index 000000000..2d67397b6
--- /dev/null
+++ b/src/effects/coverswitch/shaders/1.10/coverswitch-reflection.glsl
@@ -0,0 +1,9 @@
+uniform vec4 u_frontColor;
+uniform vec4 u_backColor;
+
+varying vec2 texcoord0;
+
+void main()
+{
+    gl_FragColor = u_frontColor*(1.0-texcoord0.s) + u_backColor*texcoord0.s;
+}
diff --git a/src/effects/coverswitch/shaders/1.40/coverswitch-reflection.glsl b/src/effects/coverswitch/shaders/1.40/coverswitch-reflection.glsl
new file mode 100644
index 000000000..720d24a11
--- /dev/null
+++ b/src/effects/coverswitch/shaders/1.40/coverswitch-reflection.glsl
@@ -0,0 +1,12 @@
+#version 140
+uniform vec4 u_frontColor;
+uniform vec4 u_backColor;
+
+in vec2 texcoord0;
+
+out vec4 fragColor;
+
+void main()
+{
+    fragColor = u_frontColor*(1.0-texcoord0.s) + u_backColor*texcoord0.s;
+}
diff --git a/src/effects/cube/CMakeLists.txt b/src/effects/cube/CMakeLists.txt
new file mode 100644
index 000000000..58b666489
--- /dev/null
+++ b/src/effects/cube/CMakeLists.txt
@@ -0,0 +1,32 @@
+#######################################
+# Effect
+
+# Data files
+install(FILES data/cubecap.png DESTINATION ${KDE_INSTALL_DATADIR}/kwin)
+
+#######################################
+# Config
+
+set(kwin_cube_config_SRCS cube_config.cpp)
+ki18n_wrap_ui(kwin_cube_config_SRCS cube_config.ui)
+kconfig_add_kcfg_files(kwin_cube_config_SRCS cubeconfig.kcfgc)
+
+add_library(kwin_cube_config MODULE ${kwin_cube_config_SRCS})
+
+target_link_libraries(kwin_cube_config
+    KF5::ConfigWidgets
+    KF5::GlobalAccel
+    KF5::I18n
+    KF5::XmlGui
+    KF5::KIOWidgets
+    KWinEffectsInterface
+)
+
+kcoreaddons_desktop_to_json(kwin_cube_config cube_config.desktop SERVICE_TYPES kcmodule.desktop)
+
+install(
+    TARGETS
+        kwin_cube_config
+    DESTINATION
+        ${KDE_INSTALL_PLUGINDIR}/kwin/effects/configs
+)
diff --git a/src/effects/cube/cube.cpp b/src/effects/cube/cube.cpp
new file mode 100644
index 000000000..1a4b21e58
--- /dev/null
+++ b/src/effects/cube/cube.cpp
@@ -0,0 +1,1747 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#include "cube.h"
+// KConfigSkeleton
+#include "cubeconfig.h"
+
+
+#include <QAction>
+#include <KGlobalAccel>
+#include <KLocalizedString>
+#include <kwinconfig.h>
+
+#include <QApplication>
+#include <QColor>
+#include <QElapsedTimer>
+#include <QRect>
+#include <QEvent>
+#include <QFutureWatcher>
+#include <QKeyEvent>
+#include <QtConcurrentRun>
+#include <QVector2D>
+#include <QVector3D>
+
+#include <cmath>
+
+#include <kwinglplatform.h>
+
+namespace KWin
+{
+
+CubeEffect::CubeEffect()
+    : activated(false)
+    , cube_painting(false)
+    , keyboard_grab(false)
+    , painting_desktop(1)
+    , frontDesktop(0)
+    , cubeOpacity(1.0)
+    , opacityDesktopOnly(true)
+    , displayDesktopName(false)
+    , desktopNameFrame(nullptr)
+    , reflection(true)
+    , desktopChangedWhileRotating(false)
+    , paintCaps(true)
+    , wallpaper(nullptr)
+    , texturedCaps(true)
+    , capTexture(nullptr)
+    , lastPresentTime(std::chrono::milliseconds::zero())
+    , reflectionPainting(false)
+    , activeScreen(0)
+    , bottomCap(false)
+    , closeOnMouseRelease(false)
+    , zoom(0.0)
+    , zPosition(0.0)
+    , useForTabBox(false)
+    , tabBoxMode(false)
+    , shortcutsRegistered(false)
+    , mode(Cube)
+    , useShaders(false)
+    , cylinderShader(nullptr)
+    , sphereShader(nullptr)
+    , zOrderingFactor(0.0f)
+    , mAddedHeightCoeff1(0.0f)
+    , mAddedHeightCoeff2(0.0f)
+    , m_cubeCapBuffer(nullptr)
+    , m_proxy(this)
+    , m_cubeAction(new QAction(this))
+    , m_cylinderAction(new QAction(this))
+    , m_sphereAction(new QAction(this))
+{
+    initConfig<CubeConfig>();
+    desktopNameFont.setBold(true);
+    desktopNameFont.setPointSize(14);
+
+    if (effects->compositingType() == OpenGLCompositing) {
+        m_reflectionShader = ShaderManager::instance()->generateShaderFromResources(ShaderTrait::MapTexture, QString(), QStringLiteral("cube-reflection.glsl"));
+        m_capShader = ShaderManager::instance()->generateShaderFromResources(ShaderTrait::MapTexture, QString(), QStringLiteral("cube-cap.glsl"));
+    } else {
+        m_reflectionShader = nullptr;
+        m_capShader = nullptr;
+    }
+    m_textureMirrorMatrix.scale(1.0, -1.0, 1.0);
+    m_textureMirrorMatrix.translate(0.0, -1.0, 0.0);
+    connect(effects, &EffectsHandler::tabBoxAdded, this, &CubeEffect::slotTabBoxAdded);
+    connect(effects, &EffectsHandler::tabBoxClosed, this, &CubeEffect::slotTabBoxClosed);
+    connect(effects, &EffectsHandler::tabBoxUpdated, this, &CubeEffect::slotTabBoxUpdated);
+    connect(effects, &EffectsHandler::screenAboutToLock, this, [this]() {
+        // Set active(false) does not release key grabs until the animation completes
+        // As we know the lockscreen is trying to grab them, release them early
+        // all other grabs are released in the normal way
+        setActive(false);
+        if (keyboard_grab) {
+            effects->ungrabKeyboard();
+            keyboard_grab = false;
+        }
+    });
+
+    reconfigure(ReconfigureAll);
+}
+
+bool CubeEffect::supported()
+{
+    return effects->isOpenGLCompositing();
+}
+
+void CubeEffect::reconfigure(ReconfigureFlags)
+{
+    CubeConfig::self()->read();
+    Q_FOREACH (ElectricBorder border, borderActivate) {
+        effects->unreserveElectricBorder(border, this);
+    }
+    Q_FOREACH (ElectricBorder border, borderActivateCylinder) {
+        effects->unreserveElectricBorder(border, this);
+    }
+    Q_FOREACH (ElectricBorder border, borderActivateSphere) {
+        effects->unreserveElectricBorder(border, this);
+    }
+    borderActivate.clear();
+    borderActivateCylinder.clear();
+    borderActivateSphere.clear();
+    QList<int> borderList = QList<int>();
+    borderList.append(int(ElectricNone));
+    borderList = CubeConfig::borderActivate();
+    Q_FOREACH (int i, borderList) {
+        borderActivate.append(ElectricBorder(i));
+        effects->reserveElectricBorder(ElectricBorder(i), this);
+    }
+    borderList.clear();
+    borderList.append(int(ElectricNone));
+    borderList = CubeConfig::borderActivateCylinder();
+    Q_FOREACH (int i, borderList) {
+        borderActivateCylinder.append(ElectricBorder(i));
+        effects->reserveElectricBorder(ElectricBorder(i), this);
+    }
+    borderList.clear();
+    borderList.append(int(ElectricNone));
+    borderList = CubeConfig::borderActivateSphere();
+    Q_FOREACH (int i, borderList) {
+        borderActivateSphere.append(ElectricBorder(i));
+        effects->reserveElectricBorder(ElectricBorder(i), this);
+    }
+
+    cubeOpacity = (float)CubeConfig::opacity() / 100.0f;
+    opacityDesktopOnly = CubeConfig::opacityDesktopOnly();
+    displayDesktopName = CubeConfig::displayDesktopName();
+    reflection = CubeConfig::reflection();
+    // TODO: Rename rotationDuration to duration so we
+    // can use animationTime<CubeConfig>(500).
+    const int d = CubeConfig::rotationDuration() != 0
+        ? CubeConfig::rotationDuration()
+        : 500;
+    rotationDuration = std::chrono::milliseconds(static_cast<int>(animationTime(d)));
+    backgroundColor = CubeConfig::backgroundColor();
+    capColor = CubeConfig::capColor();
+    paintCaps = CubeConfig::caps();
+    closeOnMouseRelease = CubeConfig::closeOnMouseRelease();
+    zPosition = CubeConfig::zPosition();
+
+    useForTabBox = CubeConfig::tabBox();
+    invertKeys = CubeConfig::invertKeys();
+    invertMouse = CubeConfig::invertMouse();
+    capDeformationFactor = (float)CubeConfig::capDeformation() / 100.0f;
+    useZOrdering = CubeConfig::zOrdering();
+    delete wallpaper;
+    wallpaper = nullptr;
+    delete capTexture;
+    capTexture = nullptr;
+    texturedCaps = CubeConfig::texturedCaps();
+
+    timeLine.setEasingCurve(QEasingCurve::InOutSine);
+    timeLine.setDuration(rotationDuration);
+
+    verticalTimeLine.setEasingCurve(QEasingCurve::InOutSine);
+    verticalTimeLine.setDuration(rotationDuration);
+
+    // do not connect the shortcut if we use cylinder or sphere
+    if (!shortcutsRegistered) {
+        QAction* cubeAction = m_cubeAction;
+        cubeAction->setObjectName(QStringLiteral("Cube"));
+        cubeAction->setText(i18n("Desktop Cube"));
+        KGlobalAccel::self()->setDefaultShortcut(cubeAction, QList<QKeySequence>() << Qt::CTRL + Qt::Key_F11);
+        KGlobalAccel::self()->setShortcut(cubeAction, QList<QKeySequence>() << Qt::CTRL + Qt::Key_F11);
+        effects->registerGlobalShortcut(Qt::CTRL + Qt::Key_F11, cubeAction);
+        effects->registerPointerShortcut(Qt::ControlModifier | Qt::AltModifier, Qt::LeftButton, cubeAction);
+        cubeShortcut = KGlobalAccel::self()->shortcut(cubeAction);
+        QAction* cylinderAction = m_cylinderAction;
+        cylinderAction->setObjectName(QStringLiteral("Cylinder"));
+        cylinderAction->setText(i18n("Desktop Cylinder"));
+        KGlobalAccel::self()->setShortcut(cylinderAction, QList<QKeySequence>());
+        effects->registerGlobalShortcut(QKeySequence(), cylinderAction);
+        cylinderShortcut = KGlobalAccel::self()->shortcut(cylinderAction);
+        QAction* sphereAction = m_sphereAction;
+        sphereAction->setObjectName(QStringLiteral("Sphere"));
+        sphereAction->setText(i18n("Desktop Sphere"));
+        KGlobalAccel::self()->setShortcut(sphereAction, QList<QKeySequence>());
+        sphereShortcut = KGlobalAccel::self()->shortcut(sphereAction);
+        effects->registerGlobalShortcut(QKeySequence(), sphereAction);
+        connect(cubeAction, &QAction::triggered, this, &CubeEffect::toggleCube);
+        connect(cylinderAction, &QAction::triggered, this, &CubeEffect::toggleCylinder);
+        connect(sphereAction, &QAction::triggered, this, &CubeEffect::toggleSphere);
+        connect(KGlobalAccel::self(), &KGlobalAccel::globalShortcutChanged, this, &CubeEffect::globalShortcutChanged);
+        shortcutsRegistered = true;
+    }
+
+    // set the cap color on the shader
+    if (m_capShader && m_capShader->isValid()) {
+        ShaderBinder binder(m_capShader);
+        m_capShader->setUniform(GLShader::Color, capColor);
+    }
+
+    // touch borders
+    const QVector<ElectricBorder> relevantBorders{ElectricLeft, ElectricTop, ElectricRight, ElectricBottom};
+    for (auto e : relevantBorders) {
+        effects->unregisterTouchBorder(e, m_cubeAction);
+        effects->unregisterTouchBorder(e, m_sphereAction);
+        effects->unregisterTouchBorder(e, m_cylinderAction);
+    }
+    auto touchEdge = [&relevantBorders] (const QList<int> touchBorders, QAction *action) {
+        for (int i : touchBorders) {
+            if (!relevantBorders.contains(ElectricBorder(i))) {
+                continue;
+            }
+            effects->registerTouchBorder(ElectricBorder(i), action);
+        }
+    };
+    touchEdge(CubeConfig::touchBorderActivate(), m_cubeAction);
+    touchEdge(CubeConfig::touchBorderActivateCylinder(), m_cylinderAction);
+    touchEdge(CubeConfig::touchBorderActivateSphere(), m_sphereAction);
+}
+
+CubeEffect::~CubeEffect()
+{
+    delete wallpaper;
+    delete capTexture;
+    delete cylinderShader;
+    delete sphereShader;
+    delete desktopNameFrame;
+    delete m_reflectionShader;
+    delete m_capShader;
+    delete m_cubeCapBuffer;
+}
+
+QImage CubeEffect::loadCubeCap(const QString &capPath)
+{
+    if (!texturedCaps) {
+        return QImage();
+    }
+    return QImage(capPath);
+}
+
+void CubeEffect::slotCubeCapLoaded()
+{
+    QFutureWatcher<QImage> *watcher = dynamic_cast<QFutureWatcher<QImage>*>(sender());
+    if (!watcher) {
+        // not invoked from future watcher
+        return;
+    }
+    QImage img = watcher->result();
+    if (!img.isNull()) {
+        effects->makeOpenGLContextCurrent();
+        capTexture = new GLTexture(img);
+        capTexture->setFilter(GL_LINEAR);
+        if (!GLPlatform::instance()->isGLES()) {
+            capTexture->setWrapMode(GL_CLAMP_TO_BORDER);
+        }
+        // need to recreate the VBO for the cube cap
+        delete m_cubeCapBuffer;
+        m_cubeCapBuffer = nullptr;
+        effects->addRepaintFull();
+    }
+    watcher->deleteLater();
+}
+
+QImage CubeEffect::loadWallPaper(const QString &file)
+{
+    return QImage(file);
+}
+
+void CubeEffect::slotWallPaperLoaded()
+{
+    QFutureWatcher<QImage> *watcher = dynamic_cast<QFutureWatcher<QImage>*>(sender());
+    if (!watcher) {
+        // not invoked from future watcher
+        return;
+    }
+    QImage img = watcher->result();
+    if (!img.isNull()) {
+        effects->makeOpenGLContextCurrent();
+        wallpaper = new GLTexture(img);
+        effects->addRepaintFull();
+    }
+    watcher->deleteLater();
+}
+
+bool CubeEffect::loadShader()
+{
+    effects->makeOpenGLContextCurrent();
+    if (!(GLPlatform::instance()->supports(GLSL) &&
+            (effects->compositingType() == OpenGLCompositing)))
+        return false;
+
+    cylinderShader = ShaderManager::instance()->generateShaderFromResources(ShaderTrait::MapTexture | ShaderTrait::AdjustSaturation | ShaderTrait::Modulate, QStringLiteral("cylinder.vert"), QString());
+    if (!cylinderShader->isValid()) {
+        qCCritical(KWINEFFECTS) << "The cylinder shader failed to load!";
+        return false;
+    } else {
+        ShaderBinder binder(cylinderShader);
+        cylinderShader->setUniform("sampler", 0);
+        QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+        cylinderShader->setUniform("width", (float)rect.width() * 0.5f);
+    }
+
+    sphereShader = ShaderManager::instance()->generateShaderFromResources(ShaderTrait::MapTexture | ShaderTrait::AdjustSaturation | ShaderTrait::Modulate, QStringLiteral("sphere.vert"), QString());
+    if (!sphereShader->isValid()) {
+        qCCritical(KWINEFFECTS) << "The sphere shader failed to load!";
+        return false;
+    } else {
+        ShaderBinder binder(sphereShader);
+        sphereShader->setUniform("sampler", 0);
+        QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+        sphereShader->setUniform("width", (float)rect.width() * 0.5f);
+        sphereShader->setUniform("height", (float)rect.height() * 0.5f);
+        sphereShader->setUniform("u_offset", QVector2D(0, 0));
+    }
+    return true;
+}
+
+void CubeEffect::startAnimation(AnimationState state)
+{
+    QEasingCurve curve;
+    /* If this is first and only animation -> EaseInOut
+     *                      there is more  -> EaseIn
+     * If there was an animation before, and this is the last one -> EaseOut
+     *                                       there is more        -> Linear */
+    if (animationState == AnimationState::None) {
+        curve.setType(animations.empty() ? QEasingCurve::InOutSine : QEasingCurve::InCurve);
+    } else {
+        curve.setType(animations.empty() ? QEasingCurve::OutCurve : QEasingCurve::Linear);
+    }
+    timeLine.reset();
+    timeLine.setEasingCurve(curve);
+    startAngle = currentAngle;
+    startFrontDesktop = frontDesktop;
+    animationState = state;
+}
+
+void CubeEffect::startVerticalAnimation(VerticalAnimationState state)
+{
+    /* Ignore if there is nowhere to rotate */
+    if ((qFuzzyIsNull(verticalCurrentAngle - 90.0f) && state == VerticalAnimationState::Upwards) ||
+        (qFuzzyIsNull(verticalCurrentAngle + 90.0f) && state == VerticalAnimationState::Downwards)) {
+        return;
+    }
+    verticalTimeLine.reset();
+    verticalStartAngle = verticalCurrentAngle;
+    verticalAnimationState = state;
+}
+
+void CubeEffect::prePaintScreen(ScreenPrePaintData& data, std::chrono::milliseconds presentTime)
+{
+    std::chrono::milliseconds delta = std::chrono::milliseconds::zero();
+    if (lastPresentTime.count()) {
+        delta = presentTime - lastPresentTime;
+    }
+    lastPresentTime = presentTime;
+
+    if (activated) {
+        data.mask |= PAINT_SCREEN_TRANSFORMED | Effect::PAINT_SCREEN_WITH_TRANSFORMED_WINDOWS | PAINT_SCREEN_BACKGROUND_FIRST;
+        if (animationState == AnimationState::None && !animations.empty()) {
+            startAnimation(animations.dequeue());
+        }
+        if (verticalAnimationState == VerticalAnimationState::None && !verticalAnimations.empty()) {
+            startVerticalAnimation(verticalAnimations.dequeue());
+        }
+
+        if (animationState != AnimationState::None || verticalAnimationState != VerticalAnimationState::None) {
+            if (animationState != AnimationState::None) {
+                timeLine.update(delta);
+            }
+            if (verticalAnimationState != VerticalAnimationState::None) {
+                verticalTimeLine.update(delta);
+            }
+            rotateCube();
+        }
+    }
+    effects->prePaintScreen(data, presentTime);
+}
+
+void CubeEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
+{
+    if (activated) {
+        QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+
+        // background
+        float clearColor[4];
+        glGetFloatv(GL_COLOR_CLEAR_VALUE, clearColor);
+        glClearColor(backgroundColor.redF(), backgroundColor.greenF(), backgroundColor.blueF(), 1.0);
+        glClear(GL_COLOR_BUFFER_BIT);
+        glClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
+
+        // wallpaper
+        if (wallpaper) {
+            ShaderBinder binder(ShaderTrait::MapTexture);
+            binder.shader()->setUniform(GLShader::ModelViewProjectionMatrix, data.projectionMatrix());
+            wallpaper->bind();
+            wallpaper->render(region, rect);
+            wallpaper->unbind();
+        }
+
+        glEnable(GL_BLEND);
+        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+        // some veriables needed for painting the caps
+        float cubeAngle = (float)((float)(effects->numberOfDesktops() - 2) / (float)effects->numberOfDesktops() * 180.0f);
+        float point = rect.width() / 2 * tan(cubeAngle * 0.5f * M_PI / 180.0f);
+        float zTranslate = zPosition + zoom;
+        if (animationState == AnimationState::Start) {
+            zTranslate *= timeLine.value();
+        } else if (animationState == AnimationState::Stop) {
+            zTranslate *= (1.0 - timeLine.value());
+        }
+        // reflection
+        if (reflection) {
+            // we can use a huge scale factor (needed to calculate the rearground vertices)
+            float scaleFactor = 1000000 * tan(60.0 * M_PI / 360.0f) / rect.height();
+            m_reflectionMatrix.setToIdentity();
+            m_reflectionMatrix.scale(1.0, -1.0, 1.0);
+
+            double translate = 0.0;
+            if (mode == Cube) {
+                double addedHeight1 = -rect.height() * cos(verticalCurrentAngle*M_PI/180.0f) - rect.width() * sin(fabs(verticalCurrentAngle)*M_PI/180.0f)/tan(M_PI/effects->numberOfDesktops());
+                double addedHeight2 = -rect.width() * sin(fabs(verticalCurrentAngle)*M_PI/180.0f)*tan(M_PI*0.5f/effects->numberOfDesktops());
+                if (verticalCurrentAngle > 0.0f && effects->numberOfDesktops() & 1)
+                    translate = cos(fabs(currentAngle)*effects->numberOfDesktops()*M_PI/360.0f) * addedHeight2 + addedHeight1 - float(rect.height());
+                else
+                    translate = sin(fabs(currentAngle)*effects->numberOfDesktops()*M_PI/360.0f) * addedHeight2 + addedHeight1 - float(rect.height());
+            } else if (mode == Cylinder) {
+                double addedHeight1 = -rect.height() * cos(verticalCurrentAngle*M_PI/180.0f) - rect.width() * sin(fabs(verticalCurrentAngle)*M_PI/180.0f)/tan(M_PI/effects->numberOfDesktops());
+                translate = addedHeight1 - float(rect.height());
+            } else {
+                float radius = (rect.width() * 0.5) / cos(cubeAngle * 0.5 * M_PI / 180.0);
+                translate = -rect.height()-2*radius;
+            }
+            m_reflectionMatrix.translate(0.0f, translate, 0.0f);
+
+            reflectionPainting = true;
+            glEnable(GL_CULL_FACE);
+            paintCap(true, -point - zTranslate, data.projectionMatrix());
+
+            // cube
+            glCullFace(GL_BACK);
+            paintCube(mask, region, data);
+
+            glCullFace(GL_FRONT);
+            paintCube(mask, region, data);
+
+            paintCap(false, -point - zTranslate, data.projectionMatrix());
+            glDisable(GL_CULL_FACE);
+            reflectionPainting = false;
+
+            const float width = rect.width();
+            const float height = rect.height();
+            float vertices[] = {
+                -width * 0.5f, height, 0.0,
+                width * 0.5f, height, 0.0,
+                width * scaleFactor, height, -5000,
+                -width * scaleFactor, height, -5000
+            };
+            // foreground
+            float alpha = 0.7;
+            if (animationState == AnimationState::Start) {
+                alpha = 0.3 + 0.4 * timeLine.value();
+            } else if (animationState == AnimationState::Stop) {
+                alpha = 0.3 + 0.4 * (1.0 - timeLine.value());
+            }
+            glEnable(GL_BLEND);
+            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+            if (m_reflectionShader && m_reflectionShader->isValid()) {
+                // ensure blending is enabled - no attribute stack
+                ShaderBinder binder(m_reflectionShader);
+                QMatrix4x4 windowTransformation = data.projectionMatrix();
+                windowTransformation.translate(rect.x() + rect.width() * 0.5f, 0.0, 0.0);
+                m_reflectionShader->setUniform(GLShader::ModelViewProjectionMatrix, windowTransformation);
+                m_reflectionShader->setUniform("u_alpha", alpha);
+                QVector<float> verts;
+                QVector<float> texcoords;
+                verts.reserve(18);
+                texcoords.reserve(12);
+                texcoords << 0.0 << 0.0;
+                verts << vertices[6] << vertices[7] << vertices[8];
+                texcoords << 0.0 << 0.0;
+                verts << vertices[9] << vertices[10] << vertices[11];
+                texcoords << 1.0 << 0.0;
+                verts << vertices[0] << vertices[1] << vertices[2];
+                texcoords << 1.0 << 0.0;
+                verts << vertices[0] << vertices[1] << vertices[2];
+                texcoords << 1.0 << 0.0;
+                verts << vertices[3] << vertices[4] << vertices[5];
+                texcoords << 0.0 << 0.0;
+                verts << vertices[6] << vertices[7] << vertices[8];
+                GLVertexBuffer *vbo = GLVertexBuffer::streamingBuffer();
+                vbo->reset();
+                vbo->setData(6, 3, verts.data(), texcoords.data());
+                vbo->render(GL_TRIANGLES);
+            }
+            glDisable(GL_BLEND);
+        }
+        glEnable(GL_CULL_FACE);
+        // caps
+        paintCap(false, -point - zTranslate, data.projectionMatrix());
+
+        // cube
+        glCullFace(GL_FRONT);
+        paintCube(mask, region, data);
+
+        glCullFace(GL_BACK);
+        paintCube(mask, region, data);
+
+        // cap
+        paintCap(true, -point - zTranslate, data.projectionMatrix());
+        glDisable(GL_CULL_FACE);
+
+        glDisable(GL_BLEND);
+
+        // desktop name box - inspired from coverswitch
+        if (displayDesktopName) {
+            double opacity = 1.0;
+            if (animationState == AnimationState::Start) {
+                opacity = timeLine.value();
+            } else if (animationState == AnimationState::Stop) {
+                opacity = 1.0 - timeLine.value();
+            }
+            QRect screenRect = effects->clientArea(ScreenArea, activeScreen, frontDesktop);
+            QRect frameRect = QRect(screenRect.width() * 0.33f + screenRect.x(), screenRect.height() * 0.95f + screenRect.y(),
+                                    screenRect.width() * 0.34f, QFontMetrics(desktopNameFont).height());
+            if (!desktopNameFrame) {
+                desktopNameFrame = effects->effectFrame(EffectFrameStyled);
+                desktopNameFrame->setFont(desktopNameFont);
+            }
+            desktopNameFrame->setGeometry(frameRect);
+            desktopNameFrame->setText(effects->desktopName(frontDesktop));
+            desktopNameFrame->render(region, opacity);
+        }
+    } else {
+        effects->paintScreen(mask, region, data);
+    }
+}
+
+void CubeEffect::rotateCube()
+{
+    QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+    m_rotationMatrix.setToIdentity();
+    float internalCubeAngle = 360.0f / effects->numberOfDesktops();
+    float zTranslate = zPosition + zoom;
+    float cubeAngle = (float)((float)(effects->numberOfDesktops() - 2) / (float)effects->numberOfDesktops() * 180.0f);
+    float point = rect.width() / 2 * tan(cubeAngle * 0.5f * M_PI / 180.0f);
+    /* Animations */
+    if (animationState == AnimationState::Start) {
+        zTranslate *= timeLine.value();
+    } else if (animationState == AnimationState::Stop) {
+        currentAngle = startAngle * (1.0 - timeLine.value());
+        zTranslate *= (1.0 - timeLine.value());
+    } else if (animationState != AnimationState::None) {
+        /* Left or right */
+        float endAngle = animationState == AnimationState::Right ? internalCubeAngle : -internalCubeAngle;
+        currentAngle = startAngle + timeLine.value() * (endAngle - startAngle);
+        frontDesktop = startFrontDesktop;
+    }
+    /* Switching to next desktop: either by mouse or due to animation */
+    if (currentAngle > internalCubeAngle * 0.5f) {
+        currentAngle -= internalCubeAngle;
+        frontDesktop--;
+        if (frontDesktop < 1) {
+            frontDesktop = effects->numberOfDesktops();
+        }
+    }
+    if (currentAngle < -internalCubeAngle * 0.5f) {
+        currentAngle += internalCubeAngle;
+        frontDesktop++;
+        if (frontDesktop > effects->numberOfDesktops()) {
+            frontDesktop = 1;
+        }
+    }
+    /* Vertical animations */
+    if (verticalAnimationState != VerticalAnimationState::None) {
+        float verticalEndAngle = 0.0;
+        if (verticalAnimationState == VerticalAnimationState::Upwards && verticalStartAngle >= 0.0) {
+            verticalEndAngle = 90.0;
+        }
+        if (verticalAnimationState == VerticalAnimationState::Downwards && verticalStartAngle <= 0.0) {
+            verticalEndAngle = -90.0;
+        }
+        // This also handles the "VerticalAnimationState::Stop" correctly, since it has endAngle = 0.0
+        verticalCurrentAngle = verticalStartAngle + verticalTimeLine.value() * (verticalEndAngle - verticalStartAngle);
+    }
+    /* Updating rotation matrix */
+    if (verticalAnimationState != VerticalAnimationState::None || verticalCurrentAngle != 0.0f) {
+        m_rotationMatrix.translate(rect.width() / 2, rect.height() / 2, -point - zTranslate);
+        m_rotationMatrix.rotate(verticalCurrentAngle, 1.0, 0.0, 0.0);
+        m_rotationMatrix.translate(-rect.width() / 2, -rect.height() / 2, point + zTranslate);
+    }
+    if (animationState != AnimationState::None || currentAngle != 0.0f) {
+        m_rotationMatrix.translate(rect.width() / 2, rect.height() / 2, -point - zTranslate);
+        m_rotationMatrix.rotate(currentAngle, 0.0, 1.0, 0.0);
+        m_rotationMatrix.translate(-rect.width() / 2, -rect.height() / 2, point + zTranslate);
+    }
+}
+
+void CubeEffect::paintCube(int mask, QRegion region, ScreenPaintData& data)
+{
+    QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+    float internalCubeAngle = 360.0f / effects->numberOfDesktops();
+    cube_painting = true;
+    float zTranslate = zPosition + zoom;
+    if (animationState == AnimationState::Start) {
+        zTranslate *= timeLine.value();
+    } else if (animationState == AnimationState::Stop) {
+        zTranslate *= (1.0 - timeLine.value());
+    }
+
+    // Rotation of the cube
+    float cubeAngle = (float)((float)(effects->numberOfDesktops() - 2) / (float)effects->numberOfDesktops() * 180.0f);
+    float point = rect.width() / 2 * tan(cubeAngle * 0.5f * M_PI / 180.0f);
+
+    for (int i = 0; i < effects->numberOfDesktops(); i++) {
+        // start painting the cube
+        painting_desktop = (i + frontDesktop) % effects->numberOfDesktops();
+        if (painting_desktop == 0) {
+            painting_desktop = effects->numberOfDesktops();
+        }
+        QMatrix4x4 matrix;
+        matrix.translate(0, 0, -zTranslate);
+        const QVector3D origin(rect.width() / 2, 0.0, -point);
+        matrix.translate(origin);
+        matrix.rotate(internalCubeAngle * i, 0, 1, 0);
+        matrix.translate(-origin);
+        m_currentFaceMatrix = matrix;
+        effects->paintScreen(mask, region, data);
+    }
+    cube_painting = false;
+    painting_desktop = effects->currentDesktop();
+}
+
+void CubeEffect::paintCap(bool frontFirst, float zOffset, const QMatrix4x4 &projection)
+{
+    if ((!paintCaps) || effects->numberOfDesktops() <= 2)
+        return;
+    GLenum firstCull = frontFirst ? GL_FRONT : GL_BACK;
+    GLenum secondCull = frontFirst ? GL_BACK : GL_FRONT;
+    const QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+
+    // create the VBO if not yet created
+    if (!m_cubeCapBuffer) {
+        switch(mode) {
+        case Cube:
+            paintCubeCap();
+            break;
+        case Cylinder:
+            paintCylinderCap();
+            break;
+        case Sphere:
+            paintSphereCap();
+            break;
+        default:
+            // impossible
+            break;
+        }
+    }
+
+    QMatrix4x4 capMvp;
+    QMatrix4x4 capMatrix;
+    capMatrix.translate(rect.width() / 2, 0.0, zOffset);
+    capMatrix.rotate((1 - frontDesktop) * 360.0f / effects->numberOfDesktops(), 0.0, 1.0, 0.0);
+    capMatrix.translate(0.0, rect.height(), 0.0);
+    if (mode == Sphere) {
+        capMatrix.scale(1.0, -1.0, 1.0);
+    }
+
+    bool capShader = false;
+    if (effects->compositingType() == OpenGLCompositing && m_capShader && m_capShader->isValid()) {
+        capShader = true;
+        ShaderManager::instance()->pushShader(m_capShader);
+        float opacity = cubeOpacity;
+        if (animationState == AnimationState::Start) {
+            opacity *= timeLine.value();
+        } else if (animationState == AnimationState::Stop) {
+            opacity *= (1.0 - timeLine.value());
+        }
+        m_capShader->setUniform("u_opacity", opacity);
+        m_capShader->setUniform("u_mirror", 1);
+        if (reflectionPainting) {
+            capMvp = projection * m_reflectionMatrix * m_rotationMatrix;
+        } else {
+            capMvp = projection * m_rotationMatrix;
+        }
+        m_capShader->setUniform(GLShader::ModelViewProjectionMatrix, capMvp * capMatrix);
+        m_capShader->setUniform("u_untextured", texturedCaps ? 0 : 1);
+        if (texturedCaps && effects->numberOfDesktops() > 3 && capTexture) {
+            capTexture->bind();
+        }
+    }
+
+    glEnable(GL_BLEND);
+    glCullFace(firstCull);
+    m_cubeCapBuffer->render(GL_TRIANGLES);
+
+    if (mode == Sphere) {
+        capMatrix.scale(1.0, -1.0, 1.0);
+    }
+    capMatrix.translate(0.0, -rect.height(), 0.0);
+    if (capShader) {
+        m_capShader->setUniform(GLShader::ModelViewProjectionMatrix, capMvp * capMatrix);
+        m_capShader->setUniform("u_mirror", 0);
+    }
+    glCullFace(secondCull);
+    m_cubeCapBuffer->render(GL_TRIANGLES);
+    glDisable(GL_BLEND);
+
+    if (capShader) {
+        ShaderManager::instance()->popShader();
+        if (texturedCaps && effects->numberOfDesktops() > 3 && capTexture) {
+            capTexture->unbind();
+        }
+    }
+}
+
+void CubeEffect::paintCubeCap()
+{
+    QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+    float cubeAngle = (float)((float)(effects->numberOfDesktops() - 2) / (float)effects->numberOfDesktops() * 180.0f);
+    float z = rect.width() / 2 * tan(cubeAngle * 0.5f * M_PI / 180.0f);
+    float zTexture = rect.width() / 2 * tan(45.0f * M_PI / 180.0f);
+    float angle = 360.0f / effects->numberOfDesktops();
+    bool texture = texturedCaps && effects->numberOfDesktops() > 3 && capTexture;
+    QVector<float> verts;
+    QVector<float> texCoords;
+    for (int i = 0; i < effects->numberOfDesktops(); i++) {
+        int triangleRows = effects->numberOfDesktops() * 5;
+        float zTriangleDistance = z / (float)triangleRows;
+        float widthTriangle = tan(angle * 0.5 * M_PI / 180.0) * zTriangleDistance;
+        float currentWidth = 0.0;
+        float cosValue = cos(i * angle  * M_PI / 180.0);
+        float sinValue = sin(i * angle  * M_PI / 180.0);
+        for (int j = 0; j < triangleRows; j++) {
+            float previousWidth = currentWidth;
+            currentWidth = tan(angle * 0.5 * M_PI / 180.0) * zTriangleDistance * (j + 1);
+            int evenTriangles = 0;
+            int oddTriangles = 0;
+            for (int k = 0; k < floor(currentWidth / widthTriangle * 2 - 1 + 0.5f); k++) {
+                float x1 = -previousWidth;
+                float x2 = -currentWidth;
+                float x3 = 0.0;
+                float z1 = 0.0;
+                float z2 = 0.0;
+                float z3 = 0.0;
+                if (k % 2 == 0) {
+                    x1 += evenTriangles * widthTriangle * 2;
+                    x2 += evenTriangles * widthTriangle * 2;
+                    x3 = x2 + widthTriangle * 2;
+                    z1 = j * zTriangleDistance;
+                    z2 = (j + 1) * zTriangleDistance;
+                    z3 = (j + 1) * zTriangleDistance;
+                    float xRot = cosValue * x1 - sinValue * z1;
+                    float zRot = sinValue * x1 + cosValue * z1;
+                    x1 = xRot;
+                    z1 = zRot;
+                    xRot = cosValue * x2 - sinValue * z2;
+                    zRot = sinValue * x2 + cosValue * z2;
+                    x2 = xRot;
+                    z2 = zRot;
+                    xRot = cosValue * x3 - sinValue * z3;
+                    zRot = sinValue * x3 + cosValue * z3;
+                    x3 = xRot;
+                    z3 = zRot;
+                    evenTriangles++;
+                } else {
+                    x1 += oddTriangles * widthTriangle * 2;
+                    x2 += (oddTriangles + 1) * widthTriangle * 2;
+                    x3 = x1 + widthTriangle * 2;
+                    z1 = j * zTriangleDistance;
+                    z2 = (j + 1) * zTriangleDistance;
+                    z3 = j * zTriangleDistance;
+                    float xRot = cosValue * x1 - sinValue * z1;
+                    float zRot = sinValue * x1 + cosValue * z1;
+                    x1 = xRot;
+                    z1 = zRot;
+                    xRot = cosValue * x2 - sinValue * z2;
+                    zRot = sinValue * x2 + cosValue * z2;
+                    x2 = xRot;
+                    z2 = zRot;
+                    xRot = cosValue * x3 - sinValue * z3;
+                    zRot = sinValue * x3 + cosValue * z3;
+                    x3 = xRot;
+                    z3 = zRot;
+                    oddTriangles++;
+                }
+                float texX1 = 0.0;
+                float texX2 = 0.0;
+                float texX3 = 0.0;
+                float texY1 = 0.0;
+                float texY2 = 0.0;
+                float texY3 = 0.0;
+                if (texture) {
+                    if (capTexture->isYInverted()) {
+                        texX1 = x1 / (rect.width()) + 0.5;
+                        texY1 = 0.5 + z1 / zTexture * 0.5;
+                        texX2 = x2 / (rect.width()) + 0.5;
+                        texY2 = 0.5 + z2 / zTexture * 0.5;
+                        texX3 = x3 / (rect.width()) + 0.5;
+                        texY3 = 0.5 + z3 / zTexture * 0.5;
+                        texCoords << texX1 << texY1;
+                    } else {
+                        texX1 = x1 / (rect.width()) + 0.5;
+                        texY1 = 0.5 - z1 / zTexture * 0.5;
+                        texX2 = x2 / (rect.width()) + 0.5;
+                        texY2 = 0.5 - z2 / zTexture * 0.5;
+                        texX3 = x3 / (rect.width()) + 0.5;
+                        texY3 = 0.5 - z3 / zTexture * 0.5;
+                        texCoords << texX1 << texY1;
+                    }
+                }
+                verts << x1 << 0.0 << z1;
+                if (texture) {
+                    texCoords << texX2 << texY2;
+                }
+                verts << x2 << 0.0 << z2;
+                if (texture) {
+                    texCoords << texX3 << texY3;
+                }
+                verts << x3 << 0.0 << z3;
+            }
+        }
+    }
+    delete m_cubeCapBuffer;
+    m_cubeCapBuffer = new GLVertexBuffer(GLVertexBuffer::Static);
+    m_cubeCapBuffer->setData(verts.count() / 3, 3, verts.constData(), texture ? texCoords.constData() : nullptr);
+}
+
+void CubeEffect::paintCylinderCap()
+{
+    QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+    float cubeAngle = (float)((float)(effects->numberOfDesktops() - 2) / (float)effects->numberOfDesktops() * 180.0f);
+
+    float radian = (cubeAngle * 0.5) * M_PI / 180;
+    float radius = (rect.width() * 0.5) * tan(radian);
+    float segment = radius / 30.0f;
+
+    bool texture = texturedCaps && effects->numberOfDesktops() > 3 && capTexture;
+    QVector<float> verts;
+    QVector<float> texCoords;
+    for (int i = 1; i <= 30; i++) {
+        int steps =  72;
+        for (int j = 0; j <= steps; j++) {
+            const float azimuthAngle = (j * (360.0f / steps)) * M_PI / 180.0f;
+            const float azimuthAngle2 = ((j + 1) * (360.0f / steps)) * M_PI / 180.0f;
+            const float x1 = segment * (i - 1) * sin(azimuthAngle);
+            const float x2 = segment * i * sin(azimuthAngle);
+            const float x3 = segment * (i - 1) * sin(azimuthAngle2);
+            const float x4 = segment * i * sin(azimuthAngle2);
+            const float z1 = segment * (i - 1) * cos(azimuthAngle);
+            const float z2 = segment * i * cos(azimuthAngle);
+            const float z3 = segment * (i - 1) * cos(azimuthAngle2);
+            const float z4 = segment * i * cos(azimuthAngle2);
+            if (texture) {
+                if (capTexture->isYInverted()) {
+                    texCoords << (radius + x1) / (radius * 2.0f) << (z1 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x2) / (radius * 2.0f) << (z2 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x3) / (radius * 2.0f) << (z3 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x4) / (radius * 2.0f) << (z4 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x3) / (radius * 2.0f) << (z3 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x2) / (radius * 2.0f) << (z2 + radius) / (radius * 2.0f);
+                } else {
+                    texCoords << (radius + x1) / (radius * 2.0f) << 1.0f - (z1 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x2) / (radius * 2.0f) << 1.0f - (z2 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x3) / (radius * 2.0f) << 1.0f - (z3 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x4) / (radius * 2.0f) << 1.0f - (z4 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x3) / (radius * 2.0f) << 1.0f - (z3 + radius) / (radius * 2.0f);
+                    texCoords << (radius + x2) / (radius * 2.0f) << 1.0f - (z2 + radius) / (radius * 2.0f);
+                }
+            }
+            verts << x1 << 0.0 << z1;
+            verts << x2 << 0.0 << z2;
+            verts << x3 << 0.0 << z3;
+            verts << x4 << 0.0 << z4;
+            verts << x3 << 0.0 << z3;
+            verts << x2 << 0.0 << z2;
+        }
+    }
+    delete m_cubeCapBuffer;
+    m_cubeCapBuffer = new GLVertexBuffer(GLVertexBuffer::Static);
+    m_cubeCapBuffer->setData(verts.count() / 3, 3, verts.constData(), texture ? texCoords.constData() : nullptr);
+}
+
+void CubeEffect::paintSphereCap()
+{
+    QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+    float cubeAngle = (float)((float)(effects->numberOfDesktops() - 2) / (float)effects->numberOfDesktops() * 180.0f);
+    float zTexture = rect.width() / 2 * tan(45.0f * M_PI / 180.0f);
+    float radius = (rect.width() * 0.5) / cos(cubeAngle * 0.5 * M_PI / 180.0);
+    float angle = acos((rect.height() * 0.5) / radius) * 180.0 / M_PI;
+    angle /= 30;
+    bool texture = texturedCaps && effects->numberOfDesktops() > 3 && capTexture;
+    QVector<float> verts;
+    QVector<float> texCoords;
+    for (int i = 0; i < 30; i++) {
+        float topAngle = angle * i * M_PI / 180.0;
+        float bottomAngle = angle * (i + 1) * M_PI / 180.0;
+        float yTop = (rect.height() * 0.5 - radius * cos(topAngle));
+        yTop *= (1.0f-capDeformationFactor);
+        float yBottom = rect.height() * 0.5 - radius * cos(bottomAngle);
+        yBottom *= (1.0f - capDeformationFactor);
+        for (int j = 0; j < 36; j++) {
+            const float x1 = radius * sin(topAngle) * sin((90.0 + j * 10.0) * M_PI / 180.0);
+            const float z1 = radius * sin(topAngle) * cos((90.0 + j * 10.0) * M_PI / 180.0);
+            const float x2 = radius * sin(bottomAngle) * sin((90.0 + j * 10.0) * M_PI / 180.00);
+            const float z2 = radius * sin(bottomAngle) * cos((90.0 + j * 10.0) * M_PI / 180.0);
+            const float x3 = radius * sin(bottomAngle) * sin((90.0 + (j + 1) * 10.0) * M_PI / 180.0);
+            const float z3 = radius * sin(bottomAngle) * cos((90.0 + (j + 1) * 10.0) * M_PI / 180.0);
+            const float x4 = radius * sin(topAngle) * sin((90.0 + (j + 1) * 10.0) * M_PI / 180.0);
+            const float z4 = radius * sin(topAngle) * cos((90.0 + (j + 1) * 10.0) * M_PI / 180.0);
+            if (texture) {
+                if (capTexture->isYInverted()) {
+                    texCoords << x4 / (rect.width()) + 0.5 << 0.5 + z4 / zTexture * 0.5;
+                    texCoords << x1 / (rect.width()) + 0.5 << 0.5 + z1 / zTexture * 0.5;
+                    texCoords << x2 / (rect.width()) + 0.5 << 0.5 + z2 / zTexture * 0.5;
+                    texCoords << x2 / (rect.width()) + 0.5 << 0.5 + z2 / zTexture * 0.5;
+                    texCoords << x3 / (rect.width()) + 0.5 << 0.5 + z3 / zTexture * 0.5;
+                    texCoords << x4 / (rect.width()) + 0.5 << 0.5 + z4 / zTexture * 0.5;
+                } else {
+                    texCoords << x4 / (rect.width()) + 0.5 << 0.5 - z4 / zTexture * 0.5;
+                    texCoords << x1 / (rect.width()) + 0.5 << 0.5 - z1 / zTexture * 0.5;
+                    texCoords << x2 / (rect.width()) + 0.5 << 0.5 - z2 / zTexture * 0.5;
+                    texCoords << x2 / (rect.width()) + 0.5 << 0.5 - z2 / zTexture * 0.5;
+                    texCoords << x3 / (rect.width()) + 0.5 << 0.5 - z3 / zTexture * 0.5;
+                    texCoords << x4 / (rect.width()) + 0.5 << 0.5 - z4 / zTexture * 0.5;
+                }
+            }
+            verts << x4 << yTop    << z4;
+            verts << x1 << yTop    << z1;
+            verts << x2 << yBottom << z2;
+            verts << x2 << yBottom << z2;
+            verts << x3 << yBottom << z3;
+            verts << x4 << yTop    << z4;
+        }
+    }
+    delete m_cubeCapBuffer;
+    m_cubeCapBuffer = new GLVertexBuffer(GLVertexBuffer::Static);
+    m_cubeCapBuffer->setData(verts.count() / 3, 3, verts.constData(), texture ? texCoords.constData() : nullptr);
+}
+
+void CubeEffect::postPaintScreen()
+{
+    effects->postPaintScreen();
+    if (!activated)
+        return;
+
+    bool animation = (animationState != AnimationState::None || verticalAnimationState != VerticalAnimationState::None);
+    if (animationState != AnimationState::None && timeLine.done()) {
+        /* An animation have just finished! */
+        if (animationState == AnimationState::Stop) {
+            /* If the stop animation is finished, we're done */
+            if (keyboard_grab)
+                effects->ungrabKeyboard();
+            keyboard_grab = false;
+            effects->stopMouseInterception(this);
+            effects->setCurrentDesktop(frontDesktop);
+            effects->setActiveFullScreenEffect(nullptr);
+            delete m_cubeCapBuffer;
+            m_cubeCapBuffer = nullptr;
+            if (desktopNameFrame)
+                desktopNameFrame->free();
+            activated = false;
+            // User can press Esc several times, and several Stop animations can be added to queue. We don't want it
+            animationState = AnimationState::None;
+            animations.clear();
+            verticalAnimationState = VerticalAnimationState::None;
+            verticalAnimations.clear();
+            lastPresentTime = std::chrono::milliseconds::zero();
+        } else {
+            if (!animations.empty())
+                startAnimation(animations.dequeue());
+            else
+                animationState = AnimationState::None;
+        }
+    }
+    /* Vertical animation have finished */
+    if (verticalAnimationState != VerticalAnimationState::None && verticalTimeLine.done()) {
+        if (!verticalAnimations.empty()) {
+            startVerticalAnimation(verticalAnimations.dequeue());
+        } else {
+            verticalAnimationState = VerticalAnimationState::None;
+        }
+    }
+    /* Repaint if there is any animation */
+    if (animation) {
+        effects->addRepaintFull();
+    } else {
+        lastPresentTime = std::chrono::milliseconds::zero();
+    }
+}
+
+void CubeEffect::prePaintWindow(EffectWindow* w, WindowPrePaintData& data, std::chrono::milliseconds presentTime)
+{
+    if (activated) {
+        if (cube_painting) {
+            if (mode == Cylinder || mode == Sphere) {
+                int leftDesktop = frontDesktop - 1;
+                int rightDesktop = frontDesktop + 1;
+                if (leftDesktop == 0)
+                    leftDesktop = effects->numberOfDesktops();
+                if (rightDesktop > effects->numberOfDesktops())
+                    rightDesktop = 1;
+                if (painting_desktop == frontDesktop)
+                    data.quads = data.quads.makeGrid(40);
+                else if (painting_desktop == leftDesktop || painting_desktop == rightDesktop)
+                    data.quads = data.quads.makeGrid(100);
+                else
+                    data.quads = data.quads.makeGrid(250);
+            }
+            if (w->isOnDesktop(painting_desktop)) {
+                QRect rect = effects->clientArea(FullArea, activeScreen, painting_desktop);
+                if (w->x() < rect.x()) {
+                    data.quads = data.quads.splitAtX(-w->x());
+                }
+                if (w->x() + w->width() > rect.x() + rect.width()) {
+                    data.quads = data.quads.splitAtX(rect.width() - w->x());
+                }
+                if (w->y() < rect.y()) {
+                    data.quads = data.quads.splitAtY(-w->y());
+                }
+                if (w->y() + w->height() > rect.y() + rect.height()) {
+                    data.quads = data.quads.splitAtY(rect.height() - w->y());
+                }
+                if (useZOrdering && !w->isDesktop() && !w->isDock() && !w->isOnAllDesktops())
+                    data.setTransformed();
+                w->enablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+            } else {
+                // check for windows belonging to the previous desktop
+                int prev_desktop = painting_desktop - 1;
+                if (prev_desktop == 0)
+                    prev_desktop = effects->numberOfDesktops();
+                if (w->isOnDesktop(prev_desktop) && mode == Cube && !useZOrdering) {
+                    QRect rect = effects->clientArea(FullArea, activeScreen, prev_desktop);
+                    if (w->x() + w->width() > rect.x() + rect.width()) {
+                        w->enablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+                        data.quads = data.quads.splitAtX(rect.width() - w->x());
+                        if (w->y() < rect.y()) {
+                            data.quads = data.quads.splitAtY(-w->y());
+                        }
+                        if (w->y() + w->height() > rect.y() + rect.height()) {
+                            data.quads = data.quads.splitAtY(rect.height() - w->y());
+                        }
+                        data.setTransformed();
+                        effects->prePaintWindow(w, data, presentTime);
+                        return;
+                    }
+                }
+                // check for windows belonging to the next desktop
+                int next_desktop = painting_desktop + 1;
+                if (next_desktop > effects->numberOfDesktops())
+                    next_desktop = 1;
+                if (w->isOnDesktop(next_desktop) && mode == Cube && !useZOrdering) {
+                    QRect rect = effects->clientArea(FullArea, activeScreen, next_desktop);
+                    if (w->x() < rect.x()) {
+                        w->enablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+                        data.quads = data.quads.splitAtX(-w->x());
+                        if (w->y() < rect.y()) {
+                            data.quads = data.quads.splitAtY(-w->y());
+                        }
+                        if (w->y() + w->height() > rect.y() + rect.height()) {
+                            data.quads = data.quads.splitAtY(rect.height() - w->y());
+                        }
+                        data.setTransformed();
+                        effects->prePaintWindow(w, data, presentTime);
+                        return;
+                    }
+                }
+                w->disablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+            }
+        }
+    }
+    effects->prePaintWindow(w, data, presentTime);
+}
+
+void CubeEffect::paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data)
+{
+    ShaderManager *shaderManager = ShaderManager::instance();
+    if (activated && cube_painting) {
+        region= infiniteRegion(); // we need to explicitly prevent any clipping, bug #325432
+        //qCDebug(KWINEFFECTS) << w->caption();
+        float opacity = cubeOpacity;
+        if (animationState == AnimationState::Start) {
+            opacity = 1.0 - (1.0 - opacity) * timeLine.value();
+            if (reflectionPainting)
+                opacity = 0.5 + (cubeOpacity - 0.5) * timeLine.value();
+            // fade in windows belonging to different desktops
+            if (painting_desktop == effects->currentDesktop() && (!w->isOnDesktop(painting_desktop)))
+                opacity = timeLine.value() * cubeOpacity;
+        } else if (animationState == AnimationState::Stop) {
+            opacity = 1.0 - (1.0 - opacity) * (1.0 - timeLine.value());
+            if (reflectionPainting)
+                opacity = 0.5 + (cubeOpacity - 0.5) * (1.0 - timeLine.value());
+            // fade out windows belonging to different desktops
+            if (painting_desktop == effects->currentDesktop() && (!w->isOnDesktop(painting_desktop)))
+                opacity = cubeOpacity * (1.0 - timeLine.value());
+        }
+        // z-Ordering
+        if (!w->isDesktop() && !w->isDock() && useZOrdering && !w->isOnAllDesktops()) {
+            float zOrdering = (effects->stackingOrder().indexOf(w) + 1) * zOrderingFactor;
+            if (animationState == AnimationState::Start) {
+                zOrdering *= timeLine.value();
+            } else if (animationState == AnimationState::Stop) {
+                zOrdering *= (1.0 - timeLine.value());
+            }
+            data.translate(0.0, 0.0, zOrdering);
+        }
+        // check for windows belonging to the previous desktop
+        int prev_desktop = painting_desktop - 1;
+        if (prev_desktop == 0)
+            prev_desktop = effects->numberOfDesktops();
+        int next_desktop = painting_desktop + 1;
+        if (next_desktop > effects->numberOfDesktops())
+            next_desktop = 1;
+        if (w->isOnDesktop(prev_desktop) && (mask & PAINT_WINDOW_TRANSFORMED)) {
+            QRect rect = effects->clientArea(FullArea, activeScreen, prev_desktop);
+            WindowQuadList new_quads;
+            Q_FOREACH (const WindowQuad & quad, data.quads) {
+                if (quad.right() > rect.width() - w->x()) {
+                    new_quads.append(quad);
+                }
+            }
+            data.quads = new_quads;
+            data.setXTranslation(-rect.width());
+        }
+        if (w->isOnDesktop(next_desktop) && (mask & PAINT_WINDOW_TRANSFORMED)) {
+            QRect rect = effects->clientArea(FullArea, activeScreen, next_desktop);
+            WindowQuadList new_quads;
+            Q_FOREACH (const WindowQuad & quad, data.quads) {
+                if (w->x() + quad.right() <= rect.x()) {
+                    new_quads.append(quad);
+                }
+            }
+            data.quads = new_quads;
+            data.setXTranslation(rect.width());
+        }
+        QRect rect = effects->clientArea(FullArea, activeScreen, painting_desktop);
+
+        if (animationState == AnimationState::Start || animationState == AnimationState::Stop) {
+            // we have to change opacity values for fade in/out of windows which are shown on front-desktop
+            if (prev_desktop == effects->currentDesktop() && w->x() < rect.x()) {
+                if (animationState == AnimationState::Start) {
+                    opacity = timeLine.value() * cubeOpacity;
+                } else if (animationState == AnimationState::Stop) {
+                    opacity = cubeOpacity * (1.0 - timeLine.value());
+                }
+            }
+            if (next_desktop == effects->currentDesktop() && w->x() + w->width() > rect.x() + rect.width()) {
+                if (animationState == AnimationState::Start) {
+                    opacity = timeLine.value() * cubeOpacity;
+                } else if (animationState == AnimationState::Stop) {
+                    opacity = cubeOpacity * (1.0 - timeLine.value());
+                }
+            }
+        }
+        // HACK set opacity to 0.99 in case of fully opaque to ensure that windows are painted in correct sequence
+        // bug #173214
+        if (opacity > 0.99f)
+            opacity = 0.99f;
+        if (opacityDesktopOnly && !w->isDesktop())
+            opacity = 0.99f;
+        data.multiplyOpacity(opacity);
+
+        if (w->isOnDesktop(painting_desktop) && w->x() < rect.x()) {
+            WindowQuadList new_quads;
+            Q_FOREACH (const WindowQuad & quad, data.quads) {
+                if (quad.right() > -w->x()) {
+                    new_quads.append(quad);
+                }
+            }
+            data.quads = new_quads;
+        }
+        if (w->isOnDesktop(painting_desktop) && w->x() + w->width() > rect.x() + rect.width()) {
+            WindowQuadList new_quads;
+            Q_FOREACH (const WindowQuad & quad, data.quads) {
+                if (quad.right() <= rect.width() - w->x()) {
+                    new_quads.append(quad);
+                }
+            }
+            data.quads = new_quads;
+        }
+        if (w->y() < rect.y()) {
+            WindowQuadList new_quads;
+            Q_FOREACH (const WindowQuad & quad, data.quads) {
+                if (quad.bottom() > -w->y()) {
+                    new_quads.append(quad);
+                }
+            }
+            data.quads = new_quads;
+        }
+        if (w->y() + w->height() > rect.y() + rect.height()) {
+            WindowQuadList new_quads;
+            Q_FOREACH (const WindowQuad & quad, data.quads) {
+                if (quad.bottom() <= rect.height() - w->y()) {
+                    new_quads.append(quad);
+                }
+            }
+            data.quads = new_quads;
+        }
+        GLShader *currentShader = nullptr;
+        if (mode == Cylinder) {
+            shaderManager->pushShader(cylinderShader);
+            cylinderShader->setUniform("xCoord", (float)w->x());
+            cylinderShader->setUniform("cubeAngle", (effects->numberOfDesktops() - 2) / (float)effects->numberOfDesktops() * 90.0f);
+            float factor = 0.0f;
+            if (animationState == AnimationState::Start) {
+                factor = 1.0f - timeLine.value();
+            } else if (animationState == AnimationState::Stop) {
+                factor = timeLine.value();
+            }
+            cylinderShader->setUniform("timeLine", factor);
+            currentShader = cylinderShader;
+        }
+        if (mode == Sphere) {
+            shaderManager->pushShader(sphereShader);
+            sphereShader->setUniform("u_offset", QVector2D(w->x(), w->y()));
+            sphereShader->setUniform("cubeAngle", (effects->numberOfDesktops() - 2) / (float)effects->numberOfDesktops() * 90.0f);
+            float factor = 0.0f;
+            if (animationState == AnimationState::Start) {
+                factor = 1.0f - timeLine.value();
+            } else if (animationState == AnimationState::Stop) {
+                factor = timeLine.value();
+            }
+            sphereShader->setUniform("timeLine", factor);
+            currentShader = sphereShader;
+        }
+        if (currentShader) {
+            data.shader = currentShader;
+        }
+        data.setProjectionMatrix(data.screenProjectionMatrix());
+        if (reflectionPainting) {
+            data.setModelViewMatrix(m_reflectionMatrix * m_rotationMatrix * m_currentFaceMatrix);
+        } else {
+            data.setModelViewMatrix(m_rotationMatrix * m_currentFaceMatrix);
+        }
+    }
+    effects->paintWindow(w, mask, region, data);
+    if (activated && cube_painting) {
+        if (mode == Cylinder || mode == Sphere) {
+            shaderManager->popShader();
+        }
+        if (w->isDesktop() && effects->numScreens() > 1 && paintCaps) {
+            QRect rect = effects->clientArea(FullArea, activeScreen, painting_desktop);
+            QRegion paint = QRegion(rect);
+            for (int i = 0; i < effects->numScreens(); i++) {
+                if (i == w->screen())
+                    continue;
+                paint = paint.subtracted(QRegion(effects->clientArea(ScreenArea, i, painting_desktop)));
+            }
+            paint = paint.subtracted(QRegion(w->frameGeometry()));
+            // in case of free area in multiscreen setup fill it with cap color
+            if (!paint.isEmpty()) {
+                glEnable(GL_BLEND);
+                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+                QVector<float> verts;
+                float quadSize = 0.0f;
+                int leftDesktop = frontDesktop - 1;
+                int rightDesktop = frontDesktop + 1;
+                if (leftDesktop == 0)
+                    leftDesktop = effects->numberOfDesktops();
+                if (rightDesktop > effects->numberOfDesktops())
+                    rightDesktop = 1;
+                if (painting_desktop == frontDesktop)
+                    quadSize = 100.0f;
+                else if (painting_desktop == leftDesktop || painting_desktop == rightDesktop)
+                    quadSize = 150.0f;
+                else
+                    quadSize = 250.0f;
+                for (const QRect &paintRect : paint) {
+                    for (int i = 0; i <= (paintRect.height() / quadSize); i++) {
+                        for (int j = 0; j <= (paintRect.width() / quadSize); j++) {
+                            verts << qMin(paintRect.x() + (j + 1)*quadSize, (float)paintRect.x() + paintRect.width()) << paintRect.y() + i*quadSize;
+                            verts << paintRect.x() + j*quadSize << paintRect.y() + i*quadSize;
+                            verts << paintRect.x() + j*quadSize << qMin(paintRect.y() + (i + 1)*quadSize, (float)paintRect.y() + paintRect.height());
+                            verts << paintRect.x() + j*quadSize << qMin(paintRect.y() + (i + 1)*quadSize, (float)paintRect.y() + paintRect.height());
+                            verts << qMin(paintRect.x() + (j + 1)*quadSize, (float)paintRect.x() + paintRect.width()) << qMin(paintRect.y() + (i + 1)*quadSize, (float)paintRect.y() + paintRect.height());
+                            verts << qMin(paintRect.x() + (j + 1)*quadSize, (float)paintRect.x() + paintRect.width()) << paintRect.y() + i*quadSize;
+                        }
+                    }
+                }
+                bool capShader = false;
+                if (effects->compositingType() == OpenGLCompositing && m_capShader && m_capShader->isValid()) {
+                    capShader = true;
+                    ShaderManager::instance()->pushShader(m_capShader);
+                    m_capShader->setUniform("u_mirror", 0);
+                    m_capShader->setUniform("u_untextured", 1);
+                    QMatrix4x4 mvp = data.screenProjectionMatrix();
+                    if (reflectionPainting) {
+                        mvp = mvp * m_reflectionMatrix * m_rotationMatrix * m_currentFaceMatrix;
+                    } else {
+                        mvp = mvp * m_rotationMatrix * m_currentFaceMatrix;
+                    }
+                    m_capShader->setUniform(GLShader::ModelViewProjectionMatrix, mvp);
+                }
+                GLVertexBuffer *vbo = GLVertexBuffer::streamingBuffer();
+                vbo->reset();
+                QColor color = capColor;
+                capColor.setAlphaF(cubeOpacity);
+                vbo->setColor(color);
+                vbo->setData(verts.size() / 2, 2, verts.constData(), nullptr);
+                if (!capShader || mode == Cube) {
+                    // TODO: use sphere and cylinder shaders
+                    vbo->render(GL_TRIANGLES);
+                }
+                if (capShader) {
+                    ShaderManager::instance()->popShader();
+                }
+                glDisable(GL_BLEND);
+            }
+        }
+    }
+}
+
+bool CubeEffect::borderActivated(ElectricBorder border)
+{
+    if (!borderActivate.contains(border) &&
+            !borderActivateCylinder.contains(border) &&
+            !borderActivateSphere.contains(border))
+        return false;
+    if (effects->activeFullScreenEffect() && effects->activeFullScreenEffect() != this)
+        return false;
+    if (borderActivate.contains(border)) {
+        if (!activated || (activated && mode == Cube))
+            toggleCube();
+        else
+            return false;
+    }
+    if (borderActivateCylinder.contains(border)) {
+        if (!activated || (activated && mode == Cylinder))
+            toggleCylinder();
+        else
+            return false;
+    }
+    if (borderActivateSphere.contains(border)) {
+        if (!activated || (activated && mode == Sphere))
+            toggleSphere();
+        else
+            return false;
+    }
+    return true;
+}
+
+void CubeEffect::toggleCube()
+{
+    qCDebug(KWINEFFECTS) << "toggle cube";
+    toggle(Cube);
+}
+
+void CubeEffect::toggleCylinder()
+{
+    qCDebug(KWINEFFECTS) << "toggle cylinder";
+    if (!useShaders)
+        useShaders = loadShader();
+    if (useShaders)
+        toggle(Cylinder);
+}
+
+void CubeEffect::toggleSphere()
+{
+    qCDebug(KWINEFFECTS) << "toggle sphere";
+    if (!useShaders)
+        useShaders = loadShader();
+    if (useShaders)
+        toggle(Sphere);
+}
+
+void CubeEffect::toggle(CubeMode newMode)
+{
+    if ((effects->activeFullScreenEffect() && effects->activeFullScreenEffect() != this) ||
+            effects->numberOfDesktops() < 2)
+        return;
+    if (!activated) {
+        mode = newMode;
+        setActive(true);
+    } else {
+        setActive(false);
+    }
+}
+
+void CubeEffect::grabbedKeyboardEvent(QKeyEvent* e)
+{
+    // If either stop is running or is scheduled - ignore all events
+    if ((!animations.isEmpty() && animations.last() == AnimationState::Stop) || animationState == AnimationState::Stop) {
+        return;
+    }
+    // taken from desktopgrid.cpp
+    if (e->type() == QEvent::KeyPress) {
+        // check for global shortcuts
+        // HACK: keyboard grab disables the global shortcuts so we have to check for global shortcut (bug 156155)
+        if (mode == Cube && cubeShortcut.contains(e->key() + e->modifiers())) {
+            toggleCube();
+            return;
+        }
+        if (mode == Cylinder && cylinderShortcut.contains(e->key() + e->modifiers())) {
+            toggleCylinder();
+            return;
+        }
+        if (mode == Sphere && sphereShortcut.contains(e->key() + e->modifiers())) {
+            toggleSphere();
+            return;
+        }
+
+        int desktop = -1;
+        // switch by F<number> or just <number>
+        if (e->key() >= Qt::Key_F1 && e->key() <= Qt::Key_F35)
+            desktop = e->key() - Qt::Key_F1 + 1;
+        else if (e->key() >= Qt::Key_0 && e->key() <= Qt::Key_9)
+            desktop = e->key() == Qt::Key_0 ? 10 : e->key() - Qt::Key_0;
+        if (desktop != -1) {
+            if (desktop <= effects->numberOfDesktops()) {
+                // we have to rotate to chosen desktop
+                // and end effect when rotation finished
+                rotateToDesktop(desktop);
+                setActive(false);
+            }
+            return;
+        }
+
+        int key = e->key();
+        if (invertKeys) {
+            if (key == Qt::Key_Left)
+                key = Qt::Key_Right;
+            else if (key == Qt::Key_Right)
+                key = Qt::Key_Left;
+            else if (key == Qt::Key_Up)
+                key = Qt::Key_Down;
+            else if (key == Qt::Key_Down)
+                key = Qt::Key_Up;
+        }
+
+        switch(key) {
+        // wrap only on autorepeat
+        case Qt::Key_Left:
+            qCDebug(KWINEFFECTS) << "left";
+            if (animations.count() < effects->numberOfDesktops())
+                animations.enqueue(AnimationState::Left);
+            break;
+        case Qt::Key_Right:
+            qCDebug(KWINEFFECTS) << "right";
+            if (animations.count() < effects->numberOfDesktops())
+                animations.enqueue(AnimationState::Right);
+            break;
+        case Qt::Key_Up:
+            qCDebug(KWINEFFECTS) << "up";
+            verticalAnimations.enqueue(VerticalAnimationState::Upwards);
+            break;
+        case Qt::Key_Down:
+            qCDebug(KWINEFFECTS) << "down";
+            verticalAnimations.enqueue(VerticalAnimationState::Downwards);
+        break;
+        case Qt::Key_Escape:
+            rotateToDesktop(effects->currentDesktop());
+            setActive(false);
+            return;
+        case Qt::Key_Enter:
+        case Qt::Key_Return:
+        case Qt::Key_Space:
+            setActive(false);
+            return;
+        case Qt::Key_Plus:
+        case Qt::Key_Equal:
+            zoom -= 10.0;
+            zoom = qMax(-zPosition, zoom);
+            rotateCube();
+            break;
+        case Qt::Key_Minus:
+            zoom += 10.0f;
+            rotateCube();
+            break;
+        default:
+            break;
+        }
+    }
+    effects->addRepaintFull();
+}
+
+void CubeEffect::rotateToDesktop(int desktop)
+{
+    // all scheduled animations will be removed as a speed up
+    animations.clear();
+    verticalAnimations.clear();
+    // we want only startAnimation to finish gracefully
+    // all the others can be interrupted
+    if (animationState != AnimationState::Start) {
+        animationState = AnimationState::None;
+    }
+    verticalAnimationState = VerticalAnimationState::None;
+    // find the fastest rotation path from frontDesktop to desktop
+    int rightRotations = frontDesktop - desktop;
+    if (rightRotations < 0) {
+        rightRotations += effects->numberOfDesktops();
+    }
+    int leftRotations = desktop - frontDesktop;
+    if (leftRotations < 0) {
+        leftRotations += effects->numberOfDesktops();
+    }
+    if (leftRotations <= rightRotations) {
+        for (int i = 0; i < leftRotations; i++) {
+            animations.enqueue(AnimationState::Left);
+        }
+    } else {
+        for (int i = 0; i < rightRotations; i++) {
+            animations.enqueue(AnimationState::Right);
+        }
+    }
+    // we want the face of desktop to appear, it might need also vertical animation
+    if (verticalCurrentAngle > 0.0f) {
+        verticalAnimations.enqueue(VerticalAnimationState::Downwards);
+    }
+    if (verticalCurrentAngle < 0.0f) {
+        verticalAnimations.enqueue(VerticalAnimationState::Upwards);
+    }
+    /* Start immediately, so there is no pause:
+     * during that pause, actual frontDesktop might change
+     * if user moves his mouse fast, leading to incorrect desktop */
+    if (animationState == AnimationState::None && !animations.empty()) {
+        startAnimation(animations.dequeue());
+    }
+    if (verticalAnimationState == VerticalAnimationState::None && !verticalAnimations.empty()) {
+        startVerticalAnimation(verticalAnimations.dequeue());
+    }
+}
+
+void CubeEffect::setActive(bool active)
+{
+    Q_FOREACH (CubeInsideEffect * inside, m_cubeInsideEffects) {
+        inside->setActive(true);
+    }
+    if (active) {
+        QString capPath = CubeConfig::capPath();
+        if (texturedCaps && !capTexture && !capPath.isEmpty()) {
+            QFutureWatcher<QImage> *watcher = new QFutureWatcher<QImage>(this);
+            connect(watcher, &QFutureWatcher<QImage>::finished, this, &CubeEffect::slotCubeCapLoaded);
+            watcher->setFuture(QtConcurrent::run(this, &CubeEffect::loadCubeCap, capPath));
+        }
+        QString wallpaperPath = CubeConfig::wallpaper().toLocalFile();
+        if (!wallpaper && !wallpaperPath.isEmpty()) {
+            QFutureWatcher<QImage> *watcher = new QFutureWatcher<QImage>(this);
+            connect(watcher, &QFutureWatcher<QImage>::finished, this, &CubeEffect::slotWallPaperLoaded);
+            watcher->setFuture(QtConcurrent::run(this, &CubeEffect::loadWallPaper, wallpaperPath));
+        }
+        activated = true;
+        activeScreen = effects->activeScreen();
+        keyboard_grab = effects->grabKeyboard(this);
+        effects->startMouseInterception(this, Qt::OpenHandCursor);
+        frontDesktop = effects->currentDesktop();
+        zoom = 0.0;
+        zOrderingFactor = zPosition / (effects->stackingOrder().count() - 1);
+        animations.enqueue(AnimationState::Start);
+        animationState = AnimationState::None;
+        verticalAnimationState = VerticalAnimationState::None;
+        effects->setActiveFullScreenEffect(this);
+        qCDebug(KWINEFFECTS) << "Cube is activated";
+        currentAngle = 0.0;
+        verticalCurrentAngle = 0.0;
+        if (reflection) {
+            QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+            float temporaryCoeff = float(rect.width()) / tan(M_PI / float(effects->numberOfDesktops()));
+            mAddedHeightCoeff1 = sqrt(float(rect.height()) * float(rect.height()) + temporaryCoeff * temporaryCoeff);
+            mAddedHeightCoeff2 = sqrt(float(rect.height()) * float(rect.height()) + float(rect.width()) * float(rect.width()) + temporaryCoeff * temporaryCoeff);
+        }
+        m_rotationMatrix.setToIdentity();
+    } else {
+        animations.enqueue(AnimationState::Stop);
+    }
+    effects->addRepaintFull();
+}
+
+void CubeEffect::windowInputMouseEvent(QEvent* e)
+{
+    if (!activated)
+        return;
+    if (tabBoxMode)
+        return;
+    if ((!animations.isEmpty() && animations.last() == AnimationState::Stop) || animationState == AnimationState::Stop)
+        return;
+
+    QMouseEvent *mouse = dynamic_cast< QMouseEvent* >(e);
+    if (!mouse)
+        return;
+
+    static QPoint oldpos;
+    static QElapsedTimer dblClckTime;
+    static int dblClckCounter(0);
+    if (mouse->type() == QEvent::MouseMove && mouse->buttons().testFlag(Qt::LeftButton)) {
+        const QPoint pos = mouse->pos();
+        QRect rect = effects->clientArea(FullArea, activeScreen, effects->currentDesktop());
+        bool repaint = false;
+        // vertical movement only if there is not a rotation
+        if (verticalAnimationState == VerticalAnimationState::None) {
+            // display height corresponds to 180*
+            int deltaY = pos.y() - oldpos.y();
+            float deltaVerticalDegrees = (float)deltaY / rect.height() * 180.0f;
+            if (invertMouse)
+                verticalCurrentAngle += deltaVerticalDegrees;
+            else
+                verticalCurrentAngle -= deltaVerticalDegrees;
+            // don't get too excited
+            verticalCurrentAngle = qBound(-90.0f, verticalCurrentAngle, 90.0f);
+
+            if (deltaVerticalDegrees != 0.0)
+                repaint = true;
+        }
+        // horizontal movement only if there is not a rotation
+        if (animationState == AnimationState::None) {
+            // display width corresponds to sum of angles of the polyhedron
+            int deltaX = oldpos.x() - pos.x();
+            float deltaDegrees = (float)deltaX / rect.width() * 360.0f;
+            if (deltaX == 0) {
+                if (pos.x() == 0)
+                    deltaDegrees = 5.0f;
+                if (pos.x() == rect.width() - 1)
+                    deltaDegrees = -5.0f;
+            }
+            if (invertMouse)
+                currentAngle += deltaDegrees;
+            else
+                currentAngle -= deltaDegrees;
+            if (deltaDegrees != 0.0)
+                repaint = true;
+        }
+        if (repaint) {
+            rotateCube();
+            effects->addRepaintFull();
+        }
+        oldpos = pos;
+    }
+
+    else if (mouse->type() == QEvent::MouseButtonPress && mouse->button() == Qt::LeftButton) {
+        oldpos = mouse->pos();
+        if (dblClckTime.elapsed() > QApplication::doubleClickInterval())
+            dblClckCounter = 0;
+        if (!dblClckCounter)
+            dblClckTime.start();
+    }
+
+    else if (mouse->type() == QEvent::MouseButtonRelease) {
+        effects->defineCursor(Qt::OpenHandCursor);
+        if (mouse->button() == Qt::LeftButton && ++dblClckCounter == 2) {
+            dblClckCounter = 0;
+            if (dblClckTime.elapsed() < QApplication::doubleClickInterval()) {
+                setActive(false);
+                return;
+            }
+        }
+        else if (mouse->button() == Qt::XButton1) {
+            if (animations.count() < effects->numberOfDesktops()) {
+                if (invertMouse)
+                    animations.enqueue(AnimationState::Right);
+                else
+                    animations.enqueue(AnimationState::Left);
+            }
+            effects->addRepaintFull();
+        } else if (mouse->button() == Qt::XButton2) {
+            if (animations.count() < effects->numberOfDesktops()) {
+                if (invertMouse)
+                    animations.enqueue(AnimationState::Left);
+                else
+                    animations.enqueue(AnimationState::Right);
+            }
+            effects->addRepaintFull();
+        } else if (mouse->button() == Qt::RightButton || (mouse->button() == Qt::LeftButton && closeOnMouseRelease)) {
+            setActive(false);
+        }
+    }
+}
+
+void CubeEffect::slotTabBoxAdded(int mode)
+{
+    if (activated)
+        return;
+    if (effects->activeFullScreenEffect() && effects->activeFullScreenEffect() != this)
+        return;
+    if (useForTabBox && mode == TabBoxDesktopListMode) {
+        effects->refTabBox();
+        tabBoxMode = true;
+        setActive(true);
+        rotateToDesktop(effects->currentTabBoxDesktop());
+    }
+}
+
+void CubeEffect::slotTabBoxUpdated()
+{
+    if (activated) {
+        rotateToDesktop(effects->currentTabBoxDesktop());
+        effects->addRepaintFull();
+    }
+}
+
+void CubeEffect::slotTabBoxClosed()
+{
+    if (activated) {
+        effects->unrefTabBox();
+        tabBoxMode = false;
+        setActive(false);
+    }
+}
+
+void CubeEffect::globalShortcutChanged(QAction *action, const QKeySequence &seq)
+{
+    if (action->objectName() == QStringLiteral("Cube")) {
+        cubeShortcut.clear();
+        cubeShortcut.append(seq);
+    } else if (action->objectName() == QStringLiteral("Cylinder")) {
+        cylinderShortcut.clear();
+        cylinderShortcut.append(seq);
+    } else if (action->objectName() == QStringLiteral("Sphere")) {
+        sphereShortcut.clear();
+        sphereShortcut.append(seq);
+    }
+}
+
+void* CubeEffect::proxy()
+{
+    return &m_proxy;
+}
+
+void CubeEffect::registerCubeInsideEffect(CubeInsideEffect* effect)
+{
+    m_cubeInsideEffects.append(effect);
+}
+
+void CubeEffect::unregisterCubeInsideEffect(CubeInsideEffect* effect)
+{
+    m_cubeInsideEffects.removeAll(effect);
+}
+
+bool CubeEffect::isActive() const
+{
+    return activated && !effects->isScreenLocked();
+}
+
+} // namespace
diff --git a/src/effects/cube/cube.h b/src/effects/cube/cube.h
new file mode 100644
index 000000000..5388bc3d3
--- /dev/null
+++ b/src/effects/cube/cube.h
@@ -0,0 +1,253 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_CUBE_H
+#define KWIN_CUBE_H
+
+#include <kwineffects.h>
+#include <kwinglutils.h>
+#include <QObject>
+#include <QQueue>
+#include <QMatrix4x4>
+#include <QFont>
+#include "cube_inside.h"
+#include "cube_proxy.h"
+
+namespace KWin
+{
+
+class CubeEffect
+    : public Effect
+{
+    Q_OBJECT
+    Q_PROPERTY(qreal cubeOpacity READ configuredCubeOpacity)
+    Q_PROPERTY(bool opacityDesktopOnly READ isOpacityDesktopOnly)
+    Q_PROPERTY(bool displayDesktopName READ isDisplayDesktopName)
+    Q_PROPERTY(bool reflection READ isReflection)
+    Q_PROPERTY(int rotationDuration READ configuredRotationDuration)
+    Q_PROPERTY(QColor backgroundColor READ configuredBackgroundColor)
+    Q_PROPERTY(QColor capColor READ configuredCapColor)
+    Q_PROPERTY(bool paintCaps READ isPaintCaps)
+    Q_PROPERTY(bool closeOnMouseRelease READ isCloseOnMouseRelease)
+    Q_PROPERTY(qreal zPosition READ configuredZPosition)
+    Q_PROPERTY(bool useForTabBox READ isUseForTabBox)
+    Q_PROPERTY(bool invertKeys READ isInvertKeys)
+    Q_PROPERTY(bool invertMouse READ isInvertMouse)
+    Q_PROPERTY(qreal capDeformationFactor READ configuredCapDeformationFactor)
+    Q_PROPERTY(bool useZOrdering READ isUseZOrdering)
+    Q_PROPERTY(bool texturedCaps READ isTexturedCaps)
+    // TODO: electric borders: not a registered type
+public:
+    CubeEffect();
+    ~CubeEffect() override;
+    void reconfigure(ReconfigureFlags) override;
+    void prePaintScreen(ScreenPrePaintData& data, std::chrono::milliseconds presentTime) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
+    void postPaintScreen() override;
+    void prePaintWindow(EffectWindow* w, WindowPrePaintData& data, std::chrono::milliseconds presentTime) override;
+    void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
+    bool borderActivated(ElectricBorder border) override;
+    void grabbedKeyboardEvent(QKeyEvent* e) override;
+    void windowInputMouseEvent(QEvent* e) override;
+    bool isActive() const override;
+
+    int requestedEffectChainPosition() const override {
+        return 50;
+    }
+
+    // proxy functions
+    void* proxy() override;
+    void registerCubeInsideEffect(CubeInsideEffect* effect);
+    void unregisterCubeInsideEffect(CubeInsideEffect* effect);
+
+    static bool supported();
+
+    // for properties
+    qreal configuredCubeOpacity() const {
+        return cubeOpacity;
+    }
+    bool isOpacityDesktopOnly() const {
+        return opacityDesktopOnly;
+    }
+    bool isDisplayDesktopName() const {
+        return displayDesktopName;
+    }
+    bool isReflection() const {
+        return reflection;
+    }
+    int configuredRotationDuration() const {
+        return rotationDuration.count();
+    }
+    QColor configuredBackgroundColor() const {
+        return backgroundColor;
+    }
+    QColor configuredCapColor() const {
+        return capColor;
+    }
+    bool isPaintCaps() const {
+        return paintCaps;
+    }
+    bool isCloseOnMouseRelease() const {
+        return closeOnMouseRelease;
+    }
+    qreal configuredZPosition() const {
+        return zPosition;
+    }
+    bool isUseForTabBox() const {
+        return useForTabBox;
+    }
+    bool isInvertKeys() const {
+        return invertKeys;
+    }
+    bool isInvertMouse() const {
+        return invertMouse;
+    }
+    qreal configuredCapDeformationFactor() const {
+        return capDeformationFactor;
+    }
+    bool isUseZOrdering() const {
+        return useZOrdering;
+    }
+    bool isTexturedCaps() const {
+        return texturedCaps;
+    }
+private Q_SLOTS:
+    void toggleCube();
+    void toggleCylinder();
+    void toggleSphere();
+    // slots for global shortcut changed
+    // needed to toggle the effect
+    void globalShortcutChanged(QAction *action, const QKeySequence &seq);
+    void slotTabBoxAdded(int mode);
+    void slotTabBoxUpdated();
+    void slotTabBoxClosed();
+    void slotCubeCapLoaded();
+    void slotWallPaperLoaded();
+private:
+    enum class AnimationState {
+        None,
+        Start,
+        Stop,
+        Left,
+        Right
+    };
+    enum class VerticalAnimationState {
+        None,
+        Upwards,
+        Downwards
+    };
+    enum CubeMode {
+        Cube,
+        Cylinder,
+        Sphere
+    };
+    void toggle(CubeMode newMode = Cube);
+    void paintCube(int mask, QRegion region, ScreenPaintData& data);
+    void paintCap(bool frontFirst, float zOffset, const QMatrix4x4 &projection);
+    void paintCubeCap();
+    void paintCylinderCap();
+    void paintSphereCap();
+    bool loadShader();
+    void rotateCube();
+    void rotateToDesktop(int desktop);
+    void setActive(bool active);
+    QImage loadCubeCap(const QString &capPath);
+    QImage loadWallPaper(const QString &file);
+    void startAnimation(AnimationState state);
+    void startVerticalAnimation(VerticalAnimationState state);
+
+    bool activated;
+    bool cube_painting;
+    bool keyboard_grab;
+    bool schedule_close;
+    QList<ElectricBorder> borderActivate;
+    QList<ElectricBorder> borderActivateCylinder;
+    QList<ElectricBorder> borderActivateSphere;
+    int painting_desktop;
+    int frontDesktop;
+    float cubeOpacity;
+    bool opacityDesktopOnly;
+    bool displayDesktopName;
+    EffectFrame* desktopNameFrame;
+    QFont desktopNameFont;
+    bool reflection;
+    bool rotating;
+    bool verticalRotating;
+    bool desktopChangedWhileRotating;
+    bool paintCaps;
+    QColor backgroundColor;
+    QColor capColor;
+    GLTexture* wallpaper;
+    bool texturedCaps;
+    GLTexture* capTexture;
+    //  animations
+    // Horizontal/start/stop
+    float startAngle;
+    float currentAngle;
+    int startFrontDesktop;
+    AnimationState animationState;
+    TimeLine timeLine;
+    QQueue<AnimationState> animations;
+    // vertical
+    float verticalStartAngle;
+    float verticalCurrentAngle;
+    VerticalAnimationState verticalAnimationState;
+    TimeLine verticalTimeLine;
+    QQueue<VerticalAnimationState> verticalAnimations;
+    std::chrono::milliseconds lastPresentTime;
+
+    bool reflectionPainting;
+    std::chrono::milliseconds rotationDuration;
+    int activeScreen;
+    bool bottomCap;
+    bool closeOnMouseRelease;
+    float zoom;
+    float zPosition;
+    bool useForTabBox;
+    bool invertKeys;
+    bool invertMouse;
+    bool tabBoxMode;
+    bool shortcutsRegistered;
+    CubeMode mode;
+    bool useShaders;
+    GLShader* cylinderShader;
+    GLShader* sphereShader;
+    GLShader* m_reflectionShader;
+    GLShader* m_capShader;
+    float capDeformationFactor;
+    bool useZOrdering;
+    float zOrderingFactor;
+    bool useList;
+    // needed for reflection
+    float mAddedHeightCoeff1;
+    float mAddedHeightCoeff2;
+
+    QMatrix4x4 m_rotationMatrix;
+    QMatrix4x4 m_reflectionMatrix;
+    QMatrix4x4 m_textureMirrorMatrix;
+    QMatrix4x4 m_currentFaceMatrix;
+    GLVertexBuffer *m_cubeCapBuffer;
+
+    // Shortcuts - needed to toggle the effect
+    QList<QKeySequence> cubeShortcut;
+    QList<QKeySequence> cylinderShortcut;
+    QList<QKeySequence> sphereShortcut;
+
+    // proxy
+    CubeEffectProxy m_proxy;
+    QList< CubeInsideEffect* > m_cubeInsideEffects;
+
+    QAction *m_cubeAction;
+    QAction *m_cylinderAction;
+    QAction *m_sphereAction;
+};
+
+} // namespace
+
+#endif
diff --git a/src/effects/cube/cube.kcfg b/src/effects/cube/cube.kcfg
new file mode 100644
index 000000000..ee9c5ec05
--- /dev/null
+++ b/src/effects/cube/cube.kcfg
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<kcfg xmlns="http://www.kde.org/standards/kcfg/1.0"
+      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+      xsi:schemaLocation="http://www.kde.org/standards/kcfg/1.0
+                          http://www.kde.org/standards/kcfg/1.0/kcfg.xsd" >
+    <kcfgfile arg="true"/>
+    <group name="Effect-Cube">
+        <entry name="BorderActivate" type="IntList" />
+        <entry name="BorderActivateCylinder" type="IntList" />
+        <entry name="BorderActivateSphere" type="IntList" />
+        <entry name="TouchBorderActivate" type="IntList" />
+        <entry name="TouchBorderActivateCylinder" type="IntList" />
+        <entry name="TouchBorderActivateSphere" type="IntList" />
+        <entry name="RotationDuration" type="Int">
+            <default>0</default>
+        </entry>
+        <entry name="Opacity" type="Int">
+            <default>80</default>
+        </entry>
+        <entry name="OpacityDesktopOnly" type="Bool">
+            <default>false</default>
+        </entry>
+        <entry name="DisplayDesktopName" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="Reflection" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="BackgroundColor" type="Color">
+            <default code="true">QColor(Qt::black)</default>
+        </entry>
+        <entry name="CapColor" type="Color">
+            <default code="true">QColor(KColorScheme(QPalette::Active, KColorScheme::Window).background().color())</default>
+        </entry>
+        <entry name="CapPath" type="String">
+            <default code="true">QStandardPaths::locate(QStandardPaths::AppDataLocation, QStringLiteral(&quot;cubecap.png&quot;))</default>
+        </entry>
+        <entry name="TexturedCaps" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="Caps" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="CloseOnMouseRelease" type="Bool">
+            <default>false</default>
+        </entry>
+        <entry name="TabBox" type="Bool">
+            <default>false</default>
+        </entry>
+        <entry name="ZPosition" type="Int">
+            <default>100</default>
+        </entry>
+        <entry name="Wallpaper" type="Url"/>
+        <entry name="CapDeformation" type="Int">
+            <default>0</default>
+        </entry>
+        <entry name="InvertKeys" type="Bool">
+            <default>false</default>
+        </entry>
+        <entry name="InvertMouse" type="Bool">
+            <default>false</default>
+        </entry>
+        <entry name="ZOrdering" type="Bool">
+            <default>false</default>
+        </entry>
+    </group>
+</kcfg>
diff --git a/src/effects/cube/cube_config.cpp b/src/effects/cube/cube_config.cpp
new file mode 100644
index 000000000..62ad11b7b
--- /dev/null
+++ b/src/effects/cube/cube_config.cpp
@@ -0,0 +1,110 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#include "cube_config.h"
+// KConfigSkeleton
+#include "cubeconfig.h"
+#include <config-kwin.h>
+#include <kwineffects_interface.h>
+
+#include <QAction>
+
+#include <kconfiggroup.h>
+#include <kcolorscheme.h>
+#include <KActionCollection>
+#include <KAboutData>
+#include <KGlobalAccel>
+#include <KLocalizedString>
+#include <KPluginFactory>
+
+#include <QVBoxLayout>
+#include <QColor>
+
+K_PLUGIN_FACTORY_WITH_JSON(CubeEffectConfigFactory,
+                           "cube_config.json",
+                           registerPlugin<KWin::CubeEffectConfig>();)
+
+namespace KWin
+{
+
+CubeEffectConfigForm::CubeEffectConfigForm(QWidget* parent) : QWidget(parent)
+{
+    setupUi(this);
+}
+
+CubeEffectConfig::CubeEffectConfig(QWidget* parent, const QVariantList& args) :
+    KCModule(parent, args)
+{
+    m_ui = new CubeEffectConfigForm(this);
+
+    QVBoxLayout* layout = new QVBoxLayout(this);
+
+    layout->addWidget(m_ui);
+
+    m_ui->tabWidget->setTabText(0, i18nc("@title:tab Basic Settings", "Basic"));
+    m_ui->tabWidget->setTabText(1, i18nc("@title:tab Advanced Settings", "Advanced"));
+
+    // Shortcut config. The shortcut belongs to the component "kwin"!
+    m_actionCollection = new KActionCollection(this, QStringLiteral("kwin"));
+    m_actionCollection->setComponentDisplayName(i18n("KWin"));
+
+    m_actionCollection->setConfigGroup(QStringLiteral("Cube"));
+    m_actionCollection->setConfigGlobal(true);
+
+    QAction* cubeAction = m_actionCollection->addAction(QStringLiteral("Cube"));
+    cubeAction->setText(i18n("Desktop Cube"));
+    cubeAction->setProperty("isConfigurationAction", true);
+    KGlobalAccel::self()->setDefaultShortcut(cubeAction, QList<QKeySequence>() << Qt::CTRL + Qt::Key_F11);
+    KGlobalAccel::self()->setShortcut(cubeAction, QList<QKeySequence>() << Qt::CTRL + Qt::Key_F11);
+    QAction* cylinderAction = m_actionCollection->addAction(QStringLiteral("Cylinder"));
+    cylinderAction->setText(i18n("Desktop Cylinder"));
+    cylinderAction->setProperty("isConfigurationAction", true);
+    KGlobalAccel::self()->setShortcut(cylinderAction, QList<QKeySequence>());
+    QAction* sphereAction = m_actionCollection->addAction(QStringLiteral("Sphere"));
+    sphereAction->setText(i18n("Desktop Sphere"));
+    sphereAction->setProperty("isConfigurationAction", true);
+    KGlobalAccel::self()->setShortcut(sphereAction, QList<QKeySequence>());
+
+    m_ui->editor->addCollection(m_actionCollection);
+
+    capsSelectionChanged();
+    connect(m_ui->kcfg_Caps, &QCheckBox::stateChanged, this, &CubeEffectConfig::capsSelectionChanged);
+    m_ui->kcfg_Wallpaper->setFilter(QStringLiteral("*.png *.jpeg *.jpg "));
+    CubeConfig::instance(KWIN_CONFIG);
+    addConfig(CubeConfig::self(), m_ui);
+    load();
+}
+
+void CubeEffectConfig::save()
+{
+    KCModule::save();
+    m_ui->editor->save();
+    OrgKdeKwinEffectsInterface interface(QStringLiteral("org.kde.KWin"),
+                                         QStringLiteral("/Effects"),
+                                         QDBusConnection::sessionBus());
+    interface.reconfigureEffect(QStringLiteral("cube"));
+}
+
+void CubeEffectConfig::capsSelectionChanged()
+{
+    if (m_ui->kcfg_Caps->checkState() == Qt::Checked) {
+        // activate cap color
+        m_ui->kcfg_CapColor->setEnabled(true);
+        m_ui->capColorLabel->setEnabled(true);
+        m_ui->kcfg_TexturedCaps->setEnabled(true);
+    } else {
+        // deactivate cap color
+        m_ui->kcfg_CapColor->setEnabled(false);
+        m_ui->capColorLabel->setEnabled(false);
+        m_ui->kcfg_TexturedCaps->setEnabled(false);
+    }
+}
+
+} // namespace
+
+#include "cube_config.moc"
diff --git a/src/effects/cube/cube_config.desktop b/src/effects/cube/cube_config.desktop
new file mode 100644
index 000000000..09e6d5453
--- /dev/null
+++ b/src/effects/cube/cube_config.desktop
@@ -0,0 +1,83 @@
+[Desktop Entry]
+Type=Service
+X-KDE-ServiceTypes=KCModule
+
+X-KDE-Library=kwin_cube_config
+X-KDE-ParentComponents=cube
+
+Name=Desktop Cube
+Name[ar]=سطح مكتب مكعّب
+Name[az]=İş Masası kubu
+Name[be@latin]=Rabočy kub
+Name[bg]=Кубичен работен плот
+Name[bn]=ডেস্কটপ কিউব
+Name[bs]=Kocka površi
+Name[ca]=Cub de l'escriptori
+Name[ca@valencia]=Cub d'escriptori
+Name[cs]=Plochy na kostce
+Name[csb]=Szescan pùltu
+Name[da]=Skrivebordsterning
+Name[de]=Arbeitsflächen-Würfel
+Name[el]=Κύβος επιφάνειας εργασίας
+Name[en_GB]=Desktop Cube
+Name[eo]=Labortabla Kubo
+Name[es]=Cubo de escritorio
+Name[et]=Töölauakuubik
+Name[eu]=Mahaigain kuboa
+Name[fi]=Työpöytäkuutio
+Name[fr]=Bureau en cube
+Name[fy]=Buroblêdkubus
+Name[ga]=Ciúb Deisce
+Name[gl]=Cubo do escritorio
+Name[gu]=ડેસ્કટોપ ટ્યુબ
+Name[he]=שולחן עבודה בקובייה
+Name[hi]=डेस्कटॉप घन
+Name[hne]=डेस्कटाप घन
+Name[hr]=Radna površina na kocki
+Name[hsb]=Kóstka
+Name[hu]=Asztalkocka
+Name[ia]=Cubo de scriptorio
+Name[id]=Kubus Desktop
+Name[is]=Skjáborðskubbur
+Name[it]=Cubo dei desktop
+Name[ja]=デスクトップキューブ
+Name[kk]=Үстел текшесі
+Name[km]=គូប​ផ្ទៃតុ​
+Name[kn]=ಗಣಕತೆರೆ ಘನಾಕೃತಿ
+Name[ko]=데스크톱 큐브
+Name[ku]=Sermaseya Mîkap
+Name[lt]=Darbalaukio kubas
+Name[lv]=Darbvirsmas kubs
+Name[mai]=डेस्कटाप घन
+Name[mk]=Работна коцка
+Name[ml]=പണിയിടം ക്യൂബ്
+Name[mr]=डेस्कटॉप क्यूब
+Name[nb]=Skrivebordsterning
+Name[nds]=Wörpel-Schriefdisch
+Name[nl]=Bureaubladkubus
+Name[nn]=Skrivebordskube
+Name[pa]=ਡੈਸਕਟਾਪ ਘਣ
+Name[pl]=Sześcian pulpitu
+Name[pt]=Cubo de Ecrãs
+Name[pt_BR]=Cubo de áreas de trabalho
+Name[ro]=Cub de birou
+Name[ru]=Куб рабочих столов
+Name[si]=වැඩතල ඝනකය
+Name[sk]=Plochy na kocke
+Name[sl]=Kocka z namizji
+Name[sr]=Коцка површи
+Name[sr@ijekavian]=Коцка површи
+Name[sr@ijekavianlatin]=Kocka površi
+Name[sr@latin]=Kocka površi
+Name[sv]=Skrivbordskub
+Name[ta]=பணிமேசை க்யூப்
+Name[te]=‍డెస్‍క్ టాప్ క్యూబ్
+Name[th]=พื้นที่ทำงานทรงลูกบาศก์
+Name[tr]=Masaüstü Küpü
+Name[ug]=ئۈستەلئۈستى كۈپى
+Name[uk]=Куб стільниць
+Name[vi]=Khối vuông màn hình
+Name[wa]=Cube di scribannes
+Name[x-test]=xxDesktop Cubexx
+Name[zh_CN]=3D 虚拟桌面切换
+Name[zh_TW]=桌面立方體
diff --git a/src/effects/cube/cube_config.h b/src/effects/cube/cube_config.h
new file mode 100644
index 000000000..5bc13f69a
--- /dev/null
+++ b/src/effects/cube/cube_config.h
@@ -0,0 +1,46 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_CUBE_CONFIG_H
+#define KWIN_CUBE_CONFIG_H
+
+#include <kcmodule.h>
+
+#include "ui_cube_config.h"
+
+
+namespace KWin
+{
+
+class CubeEffectConfigForm : public QWidget, public Ui::CubeEffectConfigForm
+{
+    Q_OBJECT
+public:
+    explicit CubeEffectConfigForm(QWidget* parent);
+};
+
+class CubeEffectConfig : public KCModule
+{
+    Q_OBJECT
+public:
+    explicit CubeEffectConfig(QWidget* parent = nullptr, const QVariantList& args = QVariantList());
+
+public Q_SLOTS:
+    void save() override;
+
+private Q_SLOTS:
+    void capsSelectionChanged();
+private:
+    CubeEffectConfigForm* m_ui;
+    KActionCollection* m_actionCollection;
+};
+
+} // namespace
+
+#endif
diff --git a/src/effects/cube/cube_config.ui b/src/effects/cube/cube_config.ui
new file mode 100644
index 000000000..ec79f1c59
--- /dev/null
+++ b/src/effects/cube/cube_config.ui
@@ -0,0 +1,569 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>KWin::CubeEffectConfigForm</class>
+ <widget class="QWidget" name="KWin::CubeEffectConfigForm">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>747</width>
+    <height>566</height>
+   </rect>
+  </property>
+  <layout class="QVBoxLayout">
+   <item>
+    <widget class="QTabWidget" name="tabWidget">
+     <property name="currentIndex">
+      <number>0</number>
+     </property>
+     <widget class="QWidget" name="tab">
+      <attribute name="title">
+       <string>Tab 1</string>
+      </attribute>
+      <layout class="QGridLayout" name="gridLayout_5">
+       <item row="1" column="1">
+        <widget class="QGroupBox" name="groupBox_5">
+         <property name="title">
+          <string>Background</string>
+         </property>
+         <layout class="QGridLayout" name="gridLayout">
+          <item row="0" column="0">
+           <widget class="QLabel" name="label_6">
+            <property name="text">
+             <string>Background color:</string>
+            </property>
+            <property name="alignment">
+             <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+            </property>
+            <property name="buddy">
+             <cstring>kcfg_BackgroundColor</cstring>
+            </property>
+           </widget>
+          </item>
+          <item row="0" column="1">
+           <widget class="KColorButton" name="kcfg_BackgroundColor">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+              <horstretch>0</horstretch>
+              <verstretch>0</verstretch>
+             </sizepolicy>
+            </property>
+           </widget>
+          </item>
+          <item row="1" column="0">
+           <widget class="QLabel" name="label_3">
+            <property name="text">
+             <string>Wallpaper:</string>
+            </property>
+            <property name="alignment">
+             <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+            </property>
+            <property name="buddy">
+             <cstring>kcfg_Wallpaper</cstring>
+            </property>
+           </widget>
+          </item>
+          <item row="1" column="1">
+           <widget class="KUrlRequester" name="kcfg_Wallpaper">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Expanding" vsizetype="Preferred">
+              <horstretch>0</horstretch>
+              <verstretch>0</verstretch>
+             </sizepolicy>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item row="3" column="0" colspan="2">
+        <widget class="QGroupBox" name="groupBox_8">
+         <property name="title">
+          <string>Activation</string>
+         </property>
+         <layout class="QGridLayout" name="gridLayout_3">
+          <item row="0" column="0" colspan="2">
+           <widget class="KShortcutsEditor" name="editor" native="true">
+            <property name="minimumSize">
+             <size>
+              <width>0</width>
+              <height>200</height>
+             </size>
+            </property>
+            <property name="actionTypes">
+              <enum>KShortcutsEditor::GlobalAction</enum>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item row="0" column="0" rowspan="2">
+        <widget class="QGroupBox" name="groupBox_7">
+         <property name="title">
+          <string>Appearance</string>
+         </property>
+         <layout class="QGridLayout" name="gridLayout_2">
+          <item row="0" column="0" colspan="2">
+           <widget class="QCheckBox" name="kcfg_DisplayDesktopName">
+            <property name="text">
+             <string>Display desktop name</string>
+            </property>
+           </widget>
+          </item>
+          <item row="1" column="0" colspan="2">
+           <widget class="QCheckBox" name="kcfg_Reflection">
+            <property name="text">
+             <string>Reflection</string>
+            </property>
+           </widget>
+          </item>
+          <item row="3" column="0">
+           <widget class="QLabel" name="label">
+            <property name="text">
+             <string>Rotation duration:</string>
+            </property>
+            <property name="alignment">
+             <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+            </property>
+            <property name="buddy">
+             <cstring>kcfg_RotationDuration</cstring>
+            </property>
+           </widget>
+          </item>
+          <item row="3" column="1">
+           <widget class="QSpinBox" name="kcfg_RotationDuration">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+              <horstretch>0</horstretch>
+              <verstretch>0</verstretch>
+             </sizepolicy>
+            </property>
+            <property name="minimumSize">
+             <size>
+              <width>100</width>
+              <height>0</height>
+             </size>
+            </property>
+            <property name="specialValueText">
+             <string comment="Duration of rotation">Default</string>
+            </property>
+            <property name="maximum">
+             <number>5000</number>
+            </property>
+            <property name="singleStep">
+             <number>10</number>
+            </property>
+           </widget>
+          </item>
+          <item row="4" column="0" colspan="2">
+           <spacer name="verticalSpacer_2">
+            <property name="orientation">
+             <enum>Qt::Vertical</enum>
+            </property>
+            <property name="sizeHint" stdset="0">
+             <size>
+              <width>20</width>
+              <height>0</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+          <item row="2" column="0" colspan="2">
+           <widget class="QCheckBox" name="kcfg_ZOrdering">
+            <property name="text">
+             <string>Windows hover above cube</string>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item row="0" column="1">
+        <widget class="QGroupBox" name="groupBox_4">
+         <property name="title">
+          <string>Opacity</string>
+         </property>
+         <layout class="QGridLayout" name="gridLayout_6">
+          <item row="1" column="0" colspan="2">
+           <widget class="QSlider" name="kcfg_Opacity">
+            <property name="minimumSize">
+             <size>
+              <width>200</width>
+              <height>0</height>
+             </size>
+            </property>
+            <property name="maximum">
+             <number>100</number>
+            </property>
+            <property name="singleStep">
+             <number>1</number>
+            </property>
+            <property name="value">
+             <number>100</number>
+            </property>
+            <property name="orientation">
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="tickPosition">
+             <enum>QSlider::TicksBelow</enum>
+            </property>
+            <property name="tickInterval">
+             <number>10</number>
+            </property>
+           </widget>
+          </item>
+          <item row="1" column="2">
+           <widget class="QSpinBox" name="kcfg_OpacitySpin">
+            <property name="minimumSize">
+             <size>
+              <width>75</width>
+              <height>0</height>
+             </size>
+            </property>
+            <property name="suffix">
+             <string> %</string>
+            </property>
+            <property name="maximum">
+             <number>100</number>
+            </property>
+            <property name="value">
+             <number>100</number>
+            </property>
+           </widget>
+          </item>
+          <item row="2" column="0">
+           <widget class="QLabel" name="label_4">
+            <property name="text">
+             <string>Transparent</string>
+            </property>
+           </widget>
+          </item>
+          <item row="2" column="1">
+           <widget class="QLabel" name="label_5">
+            <property name="text">
+             <string>Opaque</string>
+            </property>
+            <property name="alignment">
+             <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+            </property>
+           </widget>
+          </item>
+          <item row="3" column="0" colspan="3">
+           <widget class="QCheckBox" name="kcfg_OpacityDesktopOnly">
+            <property name="text">
+             <string>Do not change opacity of windows</string>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item row="4" column="0" colspan="2">
+        <spacer name="verticalSpacer_3">
+         <property name="orientation">
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>20</width>
+           <height>40</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+      </layout>
+     </widget>
+     <widget class="QWidget" name="tab_2">
+      <attribute name="title">
+       <string>Tab 2</string>
+      </attribute>
+      <layout class="QGridLayout" name="gridLayout_7">
+       <item row="0" column="0" rowspan="2">
+        <widget class="QGroupBox" name="groupBox_3">
+         <property name="title">
+          <string>Caps</string>
+         </property>
+         <layout class="QGridLayout" name="gridLayout_4">
+          <item row="0" column="0" colspan="2">
+           <widget class="QCheckBox" name="kcfg_Caps">
+            <property name="text">
+             <string>Show caps</string>
+            </property>
+           </widget>
+          </item>
+          <item row="1" column="0">
+           <widget class="QLabel" name="capColorLabel">
+            <property name="text">
+             <string>Cap color:</string>
+            </property>
+            <property name="alignment">
+             <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+            </property>
+            <property name="buddy">
+             <cstring>kcfg_CapColor</cstring>
+            </property>
+           </widget>
+          </item>
+          <item row="1" column="1">
+           <widget class="KColorButton" name="kcfg_CapColor">
+            <property name="sizePolicy">
+             <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+              <horstretch>0</horstretch>
+              <verstretch>0</verstretch>
+             </sizepolicy>
+            </property>
+           </widget>
+          </item>
+          <item row="2" column="0" colspan="2">
+           <widget class="QCheckBox" name="kcfg_TexturedCaps">
+            <property name="text">
+             <string>Display image on caps</string>
+            </property>
+           </widget>
+          </item>
+          <item row="3" column="0">
+           <spacer name="verticalSpacer_4">
+            <property name="orientation">
+             <enum>Qt::Vertical</enum>
+            </property>
+            <property name="sizeHint" stdset="0">
+             <size>
+              <width>20</width>
+              <height>40</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item row="2" column="0" colspan="2">
+        <widget class="QGroupBox" name="groupBox_2">
+         <property name="title">
+          <string>Zoom</string>
+         </property>
+         <layout class="QGridLayout" name="gridLayout_8">
+          <item row="1" column="0">
+           <widget class="QLabel" name="label_8">
+            <property name="text">
+             <string>Near</string>
+            </property>
+           </widget>
+          </item>
+          <item row="1" column="1">
+           <widget class="QLabel" name="label_9">
+            <property name="text">
+             <string>Far</string>
+            </property>
+            <property name="alignment">
+             <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+            </property>
+           </widget>
+          </item>
+          <item row="0" column="0" colspan="2">
+           <widget class="QSlider" name="kcfg_ZPosition">
+            <property name="toolTip">
+             <string>Define how far away the object should appear</string>
+            </property>
+            <property name="maximum">
+             <number>3000</number>
+            </property>
+            <property name="singleStep">
+             <number>10</number>
+            </property>
+            <property name="pageStep">
+             <number>100</number>
+            </property>
+            <property name="orientation">
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="tickPosition">
+             <enum>QSlider::TicksBelow</enum>
+            </property>
+            <property name="tickInterval">
+             <number>100</number>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item row="4" column="0" colspan="2">
+        <spacer name="verticalSpacer">
+         <property name="orientation">
+          <enum>Qt::Vertical</enum>
+         </property>
+         <property name="sizeHint" stdset="0">
+          <size>
+           <width>20</width>
+           <height>0</height>
+          </size>
+         </property>
+        </spacer>
+       </item>
+       <item row="0" column="1" rowspan="2">
+        <widget class="QGroupBox" name="groupBox_9">
+         <property name="title">
+          <string>Additional Options</string>
+         </property>
+         <layout class="QVBoxLayout" name="verticalLayout">
+          <item>
+           <widget class="QCheckBox" name="kcfg_CloseOnMouseRelease">
+            <property name="toolTip">
+             <string>If enabled the effect will be deactivated after rotating the cube with the mouse,
+otherwise it will remain active</string>
+            </property>
+            <property name="text">
+             <string>Close after mouse dragging</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="kcfg_TabBox">
+            <property name="text">
+             <string>Use this effect for walking through the desktops</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="kcfg_InvertKeys">
+            <property name="text">
+             <string>Invert cursor keys</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <widget class="QCheckBox" name="kcfg_InvertMouse">
+            <property name="text">
+             <string>Invert mouse</string>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </widget>
+       </item>
+       <item row="3" column="0" colspan="2">
+        <widget class="QGroupBox" name="capDeformationGroupBox">
+         <property name="title">
+          <string>Sphere Cap Deformation</string>
+         </property>
+         <layout class="QGridLayout" name="gridLayout_9">
+          <item row="0" column="0" colspan="2">
+           <widget class="QSlider" name="kcfg_CapDeformation">
+            <property name="maximum">
+             <number>100</number>
+            </property>
+            <property name="orientation">
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="tickPosition">
+             <enum>QSlider::TicksBelow</enum>
+            </property>
+            <property name="tickInterval">
+             <number>25</number>
+            </property>
+           </widget>
+          </item>
+          <item row="1" column="0">
+           <widget class="QLabel" name="capDeformationSphereLabel">
+            <property name="text">
+             <string>Sphere</string>
+            </property>
+           </widget>
+          </item>
+          <item row="1" column="1">
+           <widget class="QLabel" name="capDeformationPlaneLabel">
+            <property name="text">
+             <string>Plane</string>
+            </property>
+            <property name="alignment">
+             <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </widget>
+       </item>
+      </layout>
+     </widget>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <customwidgets>
+  <customwidget>
+   <class>KColorButton</class>
+   <extends>QPushButton</extends>
+   <header>kcolorbutton.h</header>
+  </customwidget>
+  <customwidget>
+   <class>KUrlRequester</class>
+   <extends>QFrame</extends>
+   <header>kurlrequester.h</header>
+   <container>1</container>
+  </customwidget>
+  <customwidget>
+   <class>KShortcutsEditor</class>
+   <extends>QWidget</extends>
+   <header location="global">KShortcutsEditor</header>
+   <container>1</container>
+  </customwidget>
+ </customwidgets>
+ <tabstops>
+  <tabstop>tabWidget</tabstop>
+  <tabstop>kcfg_DisplayDesktopName</tabstop>
+  <tabstop>kcfg_Reflection</tabstop>
+  <tabstop>kcfg_ZOrdering</tabstop>
+  <tabstop>kcfg_RotationDuration</tabstop>
+  <tabstop>kcfg_Opacity</tabstop>
+  <tabstop>kcfg_OpacitySpin</tabstop>
+  <tabstop>kcfg_OpacityDesktopOnly</tabstop>
+  <tabstop>kcfg_BackgroundColor</tabstop>
+  <tabstop>kcfg_Wallpaper</tabstop>
+  <tabstop>kcfg_Caps</tabstop>
+  <tabstop>kcfg_CapColor</tabstop>
+  <tabstop>kcfg_TexturedCaps</tabstop>
+  <tabstop>kcfg_CloseOnMouseRelease</tabstop>
+  <tabstop>kcfg_TabBox</tabstop>
+  <tabstop>kcfg_InvertKeys</tabstop>
+  <tabstop>kcfg_InvertMouse</tabstop>
+  <tabstop>kcfg_ZPosition</tabstop>
+  <tabstop>kcfg_CapDeformation</tabstop>
+ </tabstops>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>kcfg_OpacitySpin</sender>
+   <signal>valueChanged(int)</signal>
+   <receiver>kcfg_Opacity</receiver>
+   <slot>setValue(int)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>727</x>
+     <y>85</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>611</x>
+     <y>88</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>kcfg_Opacity</sender>
+   <signal>valueChanged(int)</signal>
+   <receiver>kcfg_OpacitySpin</receiver>
+   <slot>setValue(int)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>611</x>
+     <y>88</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>727</x>
+     <y>85</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
diff --git a/src/effects/cube/cube_inside.h b/src/effects/cube/cube_inside.h
new file mode 100644
index 000000000..fe96ab718
--- /dev/null
+++ b/src/effects/cube/cube_inside.h
@@ -0,0 +1,29 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_CUBE_INSIDE_H
+#define KWIN_CUBE_INSIDE_H
+#include <kwineffects.h>
+
+namespace KWin
+{
+
+class CubeInsideEffect : public Effect
+{
+public:
+    CubeInsideEffect() {}
+    ~CubeInsideEffect() override {}
+
+    virtual void paint() = 0;
+    virtual void setActive(bool active) = 0;
+};
+
+} // namespace
+
+#endif // KWIN_CUBE_INSIDE_H
diff --git a/src/effects/cube/cube_proxy.cpp b/src/effects/cube/cube_proxy.cpp
new file mode 100644
index 000000000..d9221b312
--- /dev/null
+++ b/src/effects/cube/cube_proxy.cpp
@@ -0,0 +1,36 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "cube_proxy.h"
+#include "cube.h"
+#include "cube_inside.h"
+
+namespace KWin
+{
+
+CubeEffectProxy::CubeEffectProxy(CubeEffect* effect)
+    : m_effect(effect)
+{
+}
+
+CubeEffectProxy::~CubeEffectProxy()
+{
+}
+
+void CubeEffectProxy::registerCubeInsideEffect(CubeInsideEffect* effect)
+{
+    m_effect->registerCubeInsideEffect(effect);
+}
+
+void CubeEffectProxy::unregisterCubeInsideEffect(CubeInsideEffect* effect)
+{
+    m_effect->unregisterCubeInsideEffect(effect);
+}
+
+} // namespace
diff --git a/src/effects/cube/cube_proxy.h b/src/effects/cube/cube_proxy.h
new file mode 100644
index 000000000..808470150
--- /dev/null
+++ b/src/effects/cube/cube_proxy.h
@@ -0,0 +1,34 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_CUBE_PROXY_H
+#define KWIN_CUBE_PROXY_H
+
+namespace KWin
+{
+
+class CubeEffect;
+class CubeInsideEffect;
+
+class CubeEffectProxy
+{
+public:
+    explicit CubeEffectProxy(CubeEffect* effect);
+    ~CubeEffectProxy();
+
+    void registerCubeInsideEffect(CubeInsideEffect* effect);
+    void unregisterCubeInsideEffect(CubeInsideEffect* effect);
+
+private:
+    CubeEffect* m_effect;
+};
+
+} // namespace
+
+#endif // KWIN_CUBE_PROXY_H
diff --git a/src/effects/cube/cubeconfig.kcfgc b/src/effects/cube/cubeconfig.kcfgc
new file mode 100644
index 000000000..4ee0f8030
--- /dev/null
+++ b/src/effects/cube/cubeconfig.kcfgc
@@ -0,0 +1,6 @@
+File=cube.kcfg
+ClassName=CubeConfig
+NameSpace=KWin
+Singleton=true
+Mutators=true
+IncludeFiles=kcolorscheme.h
diff --git a/src/effects/cube/data/1.10/cube-cap.glsl b/src/effects/cube/data/1.10/cube-cap.glsl
new file mode 100644
index 000000000..818905460
--- /dev/null
+++ b/src/effects/cube/data/1.10/cube-cap.glsl
@@ -0,0 +1,29 @@
+uniform sampler2D sampler;
+uniform vec4 geometryColor;
+uniform float u_opacity;
+uniform int u_mirror;
+uniform int u_untextured;
+
+varying vec2 texcoord0;
+
+vec2 mirrorTex(vec2 coords) {
+    vec2 mirrored = coords;
+    if (u_mirror != 0) {
+        mirrored.t = mirrored.t * (-1.0) + 1.0;
+    }
+    return mirrored;
+}
+
+void main() {
+    vec4 color = geometryColor;
+    vec2 texCoord = mirrorTex(texcoord0);
+    vec4 tex = texture2D(sampler, texCoord);
+    if (texCoord.s < 0.0 || texCoord.s > 1.0 ||
+            texCoord.t < 0.0 || texCoord.t > 1.0 || u_untextured != 0) {
+        tex = geometryColor;
+    }
+    color.rgb = tex.rgb*tex.a + color.rgb*(1.0-tex.a);
+    color.a = u_opacity;
+
+    gl_FragColor = color;
+}
diff --git a/src/effects/cube/data/1.10/cube-reflection.glsl b/src/effects/cube/data/1.10/cube-reflection.glsl
new file mode 100644
index 000000000..d9335a2ce
--- /dev/null
+++ b/src/effects/cube/data/1.10/cube-reflection.glsl
@@ -0,0 +1,8 @@
+uniform float u_alpha;
+
+varying vec2 texcoord0;
+
+void main()
+{
+    gl_FragColor = vec4(0.0, 0.0, 0.0, u_alpha*texcoord0.s);
+}
diff --git a/src/effects/cube/data/1.10/cylinder.vert b/src/effects/cube/data/1.10/cylinder.vert
new file mode 100644
index 000000000..eeb250da8
--- /dev/null
+++ b/src/effects/cube/data/1.10/cylinder.vert
@@ -0,0 +1,35 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008, 2011 Martin Gräßlin <kde@martin-graesslin.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+uniform mat4 modelViewProjectionMatrix;
+uniform float width;
+uniform float cubeAngle;
+uniform float xCoord;
+uniform float timeLine;
+
+attribute vec4 position;
+attribute vec4 texcoord;
+
+varying vec2 texcoord0;
+
+void main()
+{
+    texcoord0 = texcoord.st;
+    vec4 transformedVertex = vec4(position.x - ( width - xCoord ), position.yzw);
+    float radian = radians(cubeAngle);
+    float radius = (width)*tan(radian);
+    float azimuthAngle = radians(transformedVertex.x/(width)*(90.0 - cubeAngle));
+
+    transformedVertex.x = width - xCoord + radius * sin( azimuthAngle );
+    transformedVertex.z = position.z + radius * cos( azimuthAngle ) - radius;
+
+    vec3 diff = (position.xyz - transformedVertex.xyz)*timeLine;
+    transformedVertex.xyz += diff;
+
+    gl_Position = modelViewProjectionMatrix*transformedVertex;
+}
diff --git a/src/effects/cube/data/1.10/sphere.vert b/src/effects/cube/data/1.10/sphere.vert
new file mode 100644
index 000000000..844044423
--- /dev/null
+++ b/src/effects/cube/data/1.10/sphere.vert
@@ -0,0 +1,41 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008, 2011 Martin Gräßlin <kde@martin-graesslin.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+uniform mat4 modelViewProjectionMatrix;
+uniform float width;
+uniform float height;
+uniform float cubeAngle;
+uniform vec2 u_offset;
+uniform float timeLine;
+
+attribute vec4 position;
+attribute vec4 texcoord;
+
+varying vec2 texcoord0;
+
+void main()
+{
+    texcoord0 = texcoord.st;
+    vec4 transformedVertex = position;
+    transformedVertex.x = transformedVertex.x - width;
+    transformedVertex.y = transformedVertex.y - height;
+    transformedVertex.xy = transformedVertex.xy + u_offset;
+    float radian = radians(cubeAngle);
+    float radius = (width)/cos(radian);
+    float zenithAngle = acos(transformedVertex.y/radius);
+    float azimuthAngle = asin(transformedVertex.x/radius);
+    transformedVertex.z = radius * sin( zenithAngle ) * cos( azimuthAngle ) - radius*cos( radians( 90.0 - cubeAngle ) );
+    transformedVertex.x = radius * sin( zenithAngle ) * sin( azimuthAngle );
+
+    transformedVertex.xy += vec2( width - u_offset.x, height - u_offset.y );
+
+    vec3 diff = (position.xyz - transformedVertex.xyz)*timeLine;
+    transformedVertex.xyz += diff;
+
+    gl_Position = modelViewProjectionMatrix*transformedVertex;
+}
diff --git a/src/effects/cube/data/1.40/cube-cap.glsl b/src/effects/cube/data/1.40/cube-cap.glsl
new file mode 100644
index 000000000..20a830626
--- /dev/null
+++ b/src/effects/cube/data/1.40/cube-cap.glsl
@@ -0,0 +1,32 @@
+#version 140
+uniform sampler2D sampler;
+uniform vec4 geometryColor;
+uniform float u_opacity;
+uniform int u_mirror;
+uniform int u_untextured;
+
+in vec2 texcoord0;
+
+out vec4 fragColor;
+
+vec2 mirrorTex(vec2 coords) {
+    vec2 mirrored = coords;
+    if (u_mirror != 0) {
+        mirrored.t = mirrored.t * (-1.0) + 1.0;
+    }
+    return mirrored;
+}
+
+void main() {
+    vec4 color = geometryColor;
+    vec2 texCoord = mirrorTex(texcoord0);
+    vec4 tex = texture(sampler, texCoord);
+    if (texCoord.s < 0.0 || texCoord.s > 1.0 ||
+            texCoord.t < 0.0 || texCoord.t > 1.0 || u_untextured != 0) {
+        tex = geometryColor;
+    }
+    color.rgb = tex.rgb*tex.a + color.rgb*(1.0-tex.a);
+    color.a = u_opacity;
+
+    fragColor = color;
+}
diff --git a/src/effects/cube/data/1.40/cube-reflection.glsl b/src/effects/cube/data/1.40/cube-reflection.glsl
new file mode 100644
index 000000000..b70e98d92
--- /dev/null
+++ b/src/effects/cube/data/1.40/cube-reflection.glsl
@@ -0,0 +1,11 @@
+#version 140
+uniform float u_alpha;
+
+in vec2 texcoord0;
+
+out vec4 fragColor;
+
+void main()
+{
+    fragColor = vec4(0.0, 0.0, 0.0, u_alpha*texcoord0.s);
+}
diff --git a/src/effects/cube/data/1.40/cylinder.vert b/src/effects/cube/data/1.40/cylinder.vert
new file mode 100644
index 000000000..d30472ffb
--- /dev/null
+++ b/src/effects/cube/data/1.40/cylinder.vert
@@ -0,0 +1,36 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008, 2011 Martin Gräßlin <kde@martin-graesslin.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#version 140
+uniform mat4 modelViewProjectionMatrix;
+uniform float width;
+uniform float cubeAngle;
+uniform float xCoord;
+uniform float timeLine;
+
+in vec4 position;
+in vec4 texcoord;
+
+out vec2 texcoord0;
+
+void main()
+{
+    texcoord0 = texcoord.st;
+    vec4 transformedVertex = vec4(position.x - ( width - xCoord ), position.yzw);
+    float radian = radians(cubeAngle);
+    float radius = (width)*tan(radian);
+    float azimuthAngle = radians(transformedVertex.x/(width)*(90.0 - cubeAngle));
+
+    transformedVertex.x = width - xCoord + radius * sin( azimuthAngle );
+    transformedVertex.z = position.z + radius * cos( azimuthAngle ) - radius;
+
+    vec3 diff = (position.xyz - transformedVertex.xyz)*timeLine;
+    transformedVertex.xyz += diff;
+
+    gl_Position = modelViewProjectionMatrix*transformedVertex;
+}
diff --git a/src/effects/cube/data/1.40/sphere.vert b/src/effects/cube/data/1.40/sphere.vert
new file mode 100644
index 000000000..82648a2cd
--- /dev/null
+++ b/src/effects/cube/data/1.40/sphere.vert
@@ -0,0 +1,42 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008, 2011 Martin Gräßlin <kde@martin-graesslin.com>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#version 140
+uniform mat4 modelViewProjectionMatrix;
+uniform float width;
+uniform float height;
+uniform float cubeAngle;
+uniform vec2 u_offset;
+uniform float timeLine;
+
+in vec4 position;
+in vec4 texcoord;
+
+out vec2 texcoord0;
+
+void main()
+{
+    texcoord0 = texcoord.st;
+    vec4 transformedVertex = position;
+    transformedVertex.x = transformedVertex.x - width;
+    transformedVertex.y = transformedVertex.y - height;
+    transformedVertex.xy = transformedVertex.xy + u_offset;
+    float radian = radians(cubeAngle);
+    float radius = (width)/cos(radian);
+    float zenithAngle = acos(transformedVertex.y/radius);
+    float azimuthAngle = asin(transformedVertex.x/radius);
+    transformedVertex.z = radius * sin( zenithAngle ) * cos( azimuthAngle ) - radius*cos( radians( 90.0 - cubeAngle ) );
+    transformedVertex.x = radius * sin( zenithAngle ) * sin( azimuthAngle );
+
+    transformedVertex.xy += vec2( width - u_offset.x, height - u_offset.y );
+
+    vec3 diff = (position.xyz - transformedVertex.xyz)*timeLine;
+    transformedVertex.xyz += diff;
+
+    gl_Position = modelViewProjectionMatrix*transformedVertex;
+}
diff --git a/src/effects/cube/data/cubecap.png b/src/effects/cube/data/cubecap.png
new file mode 100644
index 000000000..229fa04f2
Binary files /dev/null and b/src/effects/cube/data/cubecap.png differ
diff --git a/src/effects/cubeslide/CMakeLists.txt b/src/effects/cubeslide/CMakeLists.txt
new file mode 100644
index 000000000..7275b8c66
--- /dev/null
+++ b/src/effects/cubeslide/CMakeLists.txt
@@ -0,0 +1,24 @@
+#######################################
+# Config
+
+set(kwin_cubeslide_config_SRCS cubeslide_config.cpp)
+ki18n_wrap_ui(kwin_cubeslide_config_SRCS cubeslide_config.ui)
+kconfig_add_kcfg_files(kwin_cubeslide_config_SRCS cubeslideconfig.kcfgc)
+
+add_library(kwin_cubeslide_config MODULE ${kwin_cubeslide_config_SRCS})
+
+target_link_libraries(kwin_cubeslide_config
+    KF5::ConfigWidgets
+    KF5::I18n
+    kwineffects
+    KWinEffectsInterface
+)
+
+kcoreaddons_desktop_to_json(kwin_cubeslide_config cubeslide_config.desktop SERVICE_TYPES kcmodule.desktop)
+
+install(
+    TARGETS
+        kwin_cubeslide_config
+    DESTINATION
+        ${KDE_INSTALL_PLUGINDIR}/kwin/effects/configs
+)
diff --git a/src/effects/cubeslide/cubeslide.cpp b/src/effects/cubeslide/cubeslide.cpp
new file mode 100644
index 000000000..cbea00454
--- /dev/null
+++ b/src/effects/cubeslide/cubeslide.cpp
@@ -0,0 +1,669 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#include "cubeslide.h"
+// KConfigSkeleton
+#include "cubeslideconfig.h"
+
+#include <kwinconfig.h>
+
+#include <QVector3D>
+
+#include <cmath>
+
+namespace KWin
+{
+
+CubeSlideEffect::CubeSlideEffect()
+    : stickyPainting(false)
+    , lastPresentTime(std::chrono::milliseconds::zero())
+    , windowMoving(false)
+    , desktopChangedWhileMoving(false)
+    , progressRestriction(0.0f)
+{
+    initConfig<CubeSlideConfig>();
+    connect(effects, &EffectsHandler::windowAdded,
+            this, &CubeSlideEffect::slotWindowAdded);
+    connect(effects, &EffectsHandler::windowDeleted,
+            this, &CubeSlideEffect::slotWindowDeleted);
+    connect(effects, QOverload<int,int,EffectWindow *>::of(&EffectsHandler::desktopChanged),
+            this, &CubeSlideEffect::slotDesktopChanged);
+    connect(effects, &EffectsHandler::windowStepUserMovedResized,
+            this, &CubeSlideEffect::slotWindowStepUserMovedResized);
+    connect(effects, &EffectsHandler::windowFinishUserMovedResized,
+            this, &CubeSlideEffect::slotWindowFinishUserMovedResized);
+    connect(effects, &EffectsHandler::numberDesktopsChanged,
+            this, &CubeSlideEffect::slotNumberDesktopsChanged);
+    reconfigure(ReconfigureAll);
+}
+
+CubeSlideEffect::~CubeSlideEffect()
+{
+}
+
+bool CubeSlideEffect::supported()
+{
+    return effects->isOpenGLCompositing() && effects->animationsSupported();
+}
+
+void CubeSlideEffect::reconfigure(ReconfigureFlags)
+{
+    CubeSlideConfig::self()->read();
+    // TODO: rename rotationDuration to duration
+    rotationDuration = animationTime(CubeSlideConfig::rotationDuration() != 0 ? CubeSlideConfig::rotationDuration() : 500);
+    timeLine.setEasingCurve(QEasingCurve::InOutSine);
+    timeLine.setDuration(rotationDuration);
+    dontSlidePanels = CubeSlideConfig::dontSlidePanels();
+    dontSlideStickyWindows = CubeSlideConfig::dontSlideStickyWindows();
+    usePagerLayout = CubeSlideConfig::usePagerLayout();
+    useWindowMoving = CubeSlideConfig::useWindowMoving();
+}
+
+void CubeSlideEffect::prePaintScreen(ScreenPrePaintData& data, std::chrono::milliseconds presentTime)
+{
+    std::chrono::milliseconds delta = std::chrono::milliseconds::zero();
+    if (lastPresentTime.count()) {
+        delta = presentTime - lastPresentTime;
+    }
+    lastPresentTime = presentTime;
+
+    if (isActive()) {
+        data.mask |= PAINT_SCREEN_TRANSFORMED | PAINT_SCREEN_WITH_TRANSFORMED_WINDOWS | PAINT_SCREEN_BACKGROUND_FIRST;
+        timeLine.setCurrentTime(timeLine.currentTime() + delta.count());
+        if (windowMoving && timeLine.currentTime() > progressRestriction * (qreal)timeLine.duration())
+            timeLine.setCurrentTime(progressRestriction * (qreal)timeLine.duration());
+    }
+    effects->prePaintScreen(data, presentTime);
+}
+
+void CubeSlideEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
+{
+    if (isActive()) {
+        glEnable(GL_CULL_FACE);
+        glCullFace(GL_FRONT);
+        paintSlideCube(mask, region, data);
+        glCullFace(GL_BACK);
+        paintSlideCube(mask, region, data);
+        glDisable(GL_CULL_FACE);
+        // Paint an extra screen with 'sticky' windows.
+        if (!staticWindows.isEmpty()) {
+            stickyPainting = true;
+            effects->paintScreen(mask, region, data);
+            stickyPainting = false;
+        }
+    } else
+        effects->paintScreen(mask, region, data);
+}
+
+void CubeSlideEffect::paintSlideCube(int mask, QRegion region, ScreenPaintData& data)
+{
+    // slide cube only paints to desktops at a time
+    // first the horizontal rotations followed by vertical rotations
+    QRect rect = effects->clientArea(FullArea, effects->activeScreen(), effects->currentDesktop());
+    float point = rect.width() / 2 * tan(45.0f * M_PI / 180.0f);
+    cube_painting = true;
+    painting_desktop = front_desktop;
+
+    ScreenPaintData firstFaceData = data;
+    ScreenPaintData secondFaceData = data;
+    RotationDirection direction = slideRotations.head();
+    int secondDesktop;
+    switch(direction) {
+    case Left:
+        firstFaceData.setRotationAxis(Qt::YAxis);
+        secondFaceData.setRotationAxis(Qt::YAxis);
+        if (usePagerLayout)
+            secondDesktop = effects->desktopToLeft(front_desktop, true);
+        else {
+            secondDesktop = front_desktop - 1;
+            if (secondDesktop == 0)
+                secondDesktop = effects->numberOfDesktops();
+        }
+        firstFaceData.setRotationAngle(90.0f * timeLine.currentValue());
+        secondFaceData.setRotationAngle(-90.0f * (1.0f - timeLine.currentValue()));
+        break;
+    case Right:
+        firstFaceData.setRotationAxis(Qt::YAxis);
+        secondFaceData.setRotationAxis(Qt::YAxis);
+        if (usePagerLayout)
+            secondDesktop = effects->desktopToRight(front_desktop, true);
+        else {
+            secondDesktop = front_desktop + 1;
+            if (secondDesktop > effects->numberOfDesktops())
+                secondDesktop = 1;
+        }
+        firstFaceData.setRotationAngle(-90.0f * timeLine.currentValue());
+        secondFaceData.setRotationAngle(90.0f * (1.0f - timeLine.currentValue()));
+        break;
+    case Upwards:
+        firstFaceData.setRotationAxis(Qt::XAxis);
+        secondFaceData.setRotationAxis(Qt::XAxis);
+        secondDesktop = effects->desktopAbove(front_desktop, true);
+        firstFaceData.setRotationAngle(-90.0f * timeLine.currentValue());
+        secondFaceData.setRotationAngle(90.0f * (1.0f - timeLine.currentValue()));
+        point = rect.height() / 2 * tan(45.0f * M_PI / 180.0f);
+        break;
+    case Downwards:
+        firstFaceData.setRotationAxis(Qt::XAxis);
+        secondFaceData.setRotationAxis(Qt::XAxis);
+        secondDesktop = effects->desktopBelow(front_desktop, true);
+        firstFaceData.setRotationAngle(90.0f * timeLine.currentValue());
+        secondFaceData.setRotationAngle(-90.0f * (1.0f - timeLine.currentValue()));
+        point = rect.height() / 2 * tan(45.0f * M_PI / 180.0f);
+        break;
+    default:
+        // totally impossible
+        return;
+    }
+    // front desktop
+    firstFaceData.setRotationOrigin(QVector3D(rect.width() / 2, rect.height() / 2, -point));
+    other_desktop = secondDesktop;
+    firstDesktop = true;
+    effects->paintScreen(mask, region, firstFaceData);
+    // second desktop
+    other_desktop = painting_desktop;
+    painting_desktop = secondDesktop;
+    firstDesktop = false;
+    secondFaceData.setRotationOrigin(QVector3D(rect.width() / 2, rect.height() / 2, -point));
+    effects->paintScreen(mask, region, secondFaceData);
+    cube_painting = false;
+    painting_desktop = effects->currentDesktop();
+}
+
+void CubeSlideEffect::prePaintWindow(EffectWindow* w,  WindowPrePaintData& data, std::chrono::milliseconds presentTime)
+{
+    if (stickyPainting) {
+        if (staticWindows.contains(w)) {
+            w->enablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+        } else {
+            w->disablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+        }
+    } else if (isActive() && cube_painting) {
+        if (staticWindows.contains(w)) {
+            w->disablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+            effects->prePaintWindow(w, data, presentTime);
+            return;
+        }
+        QRect rect = effects->clientArea(FullArea, effects->activeScreen(), painting_desktop);
+        if (w->isOnDesktop(painting_desktop)) {
+            if (w->x() < rect.x()) {
+                data.quads = data.quads.splitAtX(-w->x());
+            }
+            if (w->x() + w->width() > rect.x() + rect.width()) {
+                data.quads = data.quads.splitAtX(rect.width() - w->x());
+            }
+            if (w->y() < rect.y()) {
+                data.quads = data.quads.splitAtY(-w->y());
+            }
+            if (w->y() + w->height() > rect.y() + rect.height()) {
+                data.quads = data.quads.splitAtY(rect.height() - w->y());
+            }
+            w->enablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+        } else if (w->isOnDesktop(other_desktop)) {
+            RotationDirection direction = slideRotations.head();
+            bool enable = false;
+            if (w->x() < rect.x() &&
+                    (direction == Left || direction == Right)) {
+                data.quads = data.quads.splitAtX(-w->x());
+                enable = true;
+            }
+            if (w->x() + w->width() > rect.x() + rect.width() &&
+                    (direction == Left || direction == Right)) {
+                data.quads = data.quads.splitAtX(rect.width() - w->x());
+                enable = true;
+            }
+            if (w->y() < rect.y() &&
+                    (direction == Upwards || direction == Downwards)) {
+                data.quads = data.quads.splitAtY(-w->y());
+                enable = true;
+            }
+            if (w->y() + w->height() > rect.y() + rect.height() &&
+                    (direction == Upwards || direction == Downwards)) {
+                data.quads = data.quads.splitAtY(rect.height() - w->y());
+                enable = true;
+            }
+            if (enable) {
+                data.setTransformed();
+                data.setTranslucent();
+                w->enablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+            } else
+                w->disablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+        } else
+            w->disablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+    }
+    effects->prePaintWindow(w, data, presentTime);
+}
+
+void CubeSlideEffect::paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data)
+{
+    if (isActive() && cube_painting && !staticWindows.contains(w)) {
+        // filter out quads overlapping the edges
+        QRect rect = effects->clientArea(FullArea, effects->activeScreen(), painting_desktop);
+        if (w->isOnDesktop(painting_desktop)) {
+            if (w->x() < rect.x()) {
+                WindowQuadList new_quads;
+                Q_FOREACH (const WindowQuad & quad, data.quads) {
+                    if (quad.right() > -w->x()) {
+                        new_quads.append(quad);
+                    }
+                }
+                data.quads = new_quads;
+            }
+            if (w->x() + w->width() > rect.x() + rect.width()) {
+                WindowQuadList new_quads;
+                Q_FOREACH (const WindowQuad & quad, data.quads) {
+                    if (quad.right() <= rect.width() - w->x()) {
+                        new_quads.append(quad);
+                    }
+                }
+                data.quads = new_quads;
+            }
+            if (w->y() < rect.y()) {
+                WindowQuadList new_quads;
+                Q_FOREACH (const WindowQuad & quad, data.quads) {
+                    if (quad.bottom() > -w->y()) {
+                        new_quads.append(quad);
+                    }
+                }
+                data.quads = new_quads;
+            }
+            if (w->y() + w->height() > rect.y() + rect.height()) {
+                WindowQuadList new_quads;
+                Q_FOREACH (const WindowQuad & quad, data.quads) {
+                    if (quad.bottom() <= rect.height() - w->y()) {
+                        new_quads.append(quad);
+                    }
+                }
+                data.quads = new_quads;
+            }
+        }
+        // paint windows overlapping edges from other desktop
+        if (w->isOnDesktop(other_desktop) && (mask & PAINT_WINDOW_TRANSFORMED)) {
+            RotationDirection direction = slideRotations.head();
+            if (w->x() < rect.x() &&
+                    (direction == Left || direction == Right)) {
+                WindowQuadList new_quads;
+                data.setXTranslation(rect.width());
+                Q_FOREACH (const WindowQuad & quad, data.quads) {
+                    if (quad.right() <= -w->x()) {
+                        new_quads.append(quad);
+                    }
+                }
+                data.quads = new_quads;
+            }
+            if (w->x() + w->width() > rect.x() + rect.width() &&
+                    (direction == Left || direction == Right)) {
+                WindowQuadList new_quads;
+                data.setXTranslation(-rect.width());
+                Q_FOREACH (const WindowQuad & quad, data.quads) {
+                    if (quad.right() > rect.width() - w->x()) {
+                        new_quads.append(quad);
+                    }
+                }
+                data.quads = new_quads;
+            }
+            if (w->y() < rect.y() &&
+                    (direction == Upwards || direction == Downwards)) {
+                WindowQuadList new_quads;
+                data.setYTranslation(rect.height());
+                Q_FOREACH (const WindowQuad & quad, data.quads) {
+                    if (quad.bottom() <= -w->y()) {
+                        new_quads.append(quad);
+                    }
+                }
+                data.quads = new_quads;
+            }
+            if (w->y() + w->height() > rect.y() + rect.height() &&
+                    (direction == Upwards || direction == Downwards)) {
+                WindowQuadList new_quads;
+                data.setYTranslation(-rect.height());
+                Q_FOREACH (const WindowQuad & quad, data.quads) {
+                    if (quad.bottom() > rect.height() - w->y()) {
+                        new_quads.append(quad);
+                    }
+                }
+                data.quads = new_quads;
+            }
+            if (firstDesktop)
+                data.multiplyOpacity(timeLine.currentValue());
+            else
+                data.multiplyOpacity((1.0 - timeLine.currentValue()));
+        }
+    }
+    effects->paintWindow(w, mask, region, data);
+}
+
+void CubeSlideEffect::postPaintScreen()
+{
+    effects->postPaintScreen();
+    if (isActive()) {
+        if (timeLine.currentValue() == 1.0) {
+            RotationDirection direction = slideRotations.dequeue();
+            switch(direction) {
+            case Left:
+                if (usePagerLayout)
+                    front_desktop = effects->desktopToLeft(front_desktop, true);
+                else {
+                    front_desktop--;
+                    if (front_desktop == 0)
+                        front_desktop = effects->numberOfDesktops();
+                }
+                break;
+            case Right:
+                if (usePagerLayout)
+                    front_desktop = effects->desktopToRight(front_desktop, true);
+                else {
+                    front_desktop++;
+                    if (front_desktop > effects->numberOfDesktops())
+                        front_desktop = 1;
+                }
+                break;
+            case Upwards:
+                front_desktop = effects->desktopAbove(front_desktop, true);
+                break;
+            case Downwards:
+                front_desktop = effects->desktopBelow(front_desktop, true);
+                break;
+            }
+            timeLine.setCurrentTime(0);
+            if (slideRotations.count() == 1)
+                timeLine.setEasingCurve(QEasingCurve::OutSine);
+            else
+                timeLine.setEasingCurve(QEasingCurve::Linear);
+            if (slideRotations.empty()) {
+                for (EffectWindow* w : qAsConst(staticWindows)) {
+                    w->setData(WindowForceBlurRole, QVariant());
+                    w->setData(WindowForceBackgroundContrastRole, QVariant());
+                }
+                staticWindows.clear();
+                lastPresentTime = std::chrono::milliseconds::zero();
+                effects->setActiveFullScreenEffect(nullptr);
+            }
+        }
+        effects->addRepaintFull();
+    }
+}
+
+void CubeSlideEffect::slotDesktopChanged(int old, int current, EffectWindow* w)
+{
+    Q_UNUSED(w)
+    if (effects->activeFullScreenEffect() && effects->activeFullScreenEffect() != this)
+        return;
+    if (old > effects->numberOfDesktops()) {
+        // number of desktops has been reduced -> no animation
+        return;
+    }
+    if (windowMoving) {
+        desktopChangedWhileMoving = true;
+        progressRestriction = 1.0 - progressRestriction;
+        effects->addRepaintFull();
+        return;
+    }
+    bool activate = true;
+    if (!slideRotations.empty()) {
+        // last slide still in progress
+        activate = false;
+        RotationDirection direction = slideRotations.dequeue();
+        slideRotations.clear();
+        slideRotations.enqueue(direction);
+        switch(direction) {
+        case Left:
+            if (usePagerLayout)
+                old = effects->desktopToLeft(front_desktop, true);
+            else {
+                old = front_desktop - 1;
+                if (old == 0)
+                    old = effects->numberOfDesktops();
+            }
+            break;
+        case Right:
+            if (usePagerLayout)
+                old = effects->desktopToRight(front_desktop, true);
+            else {
+                old = front_desktop + 1;
+                if (old > effects->numberOfDesktops())
+                    old = 1;
+            }
+            break;
+        case Upwards:
+            old = effects->desktopAbove(front_desktop, true);
+            break;
+        case Downwards:
+            old = effects->desktopBelow(front_desktop, true);
+            break;
+        }
+    }
+    if (usePagerLayout) {
+        // calculate distance in respect to pager
+        QPoint diff = effects->desktopGridCoords(effects->currentDesktop()) - effects->desktopGridCoords(old);
+        if (qAbs(diff.x()) > effects->desktopGridWidth() / 2) {
+            int sign = -1 * (diff.x() / qAbs(diff.x()));
+            diff.setX(sign *(effects->desktopGridWidth() - qAbs(diff.x())));
+        }
+        if (diff.x() > 0) {
+            for (int i = 0; i < diff.x(); i++) {
+                slideRotations.enqueue(Right);
+            }
+        } else if (diff.x() < 0) {
+            diff.setX(-diff.x());
+            for (int i = 0; i < diff.x(); i++) {
+                slideRotations.enqueue(Left);
+            }
+        }
+        if (qAbs(diff.y()) > effects->desktopGridHeight() / 2) {
+            int sign = -1 * (diff.y() / qAbs(diff.y()));
+            diff.setY(sign *(effects->desktopGridHeight() - qAbs(diff.y())));
+        }
+        if (diff.y() > 0) {
+            for (int i = 0; i < diff.y(); i++) {
+                slideRotations.enqueue(Downwards);
+            }
+        }
+        if (diff.y() < 0) {
+            diff.setY(-diff.y());
+            for (int i = 0; i < diff.y(); i++) {
+                slideRotations.enqueue(Upwards);
+            }
+        }
+    } else {
+        // ignore pager layout
+        int left = old - current;
+        if (left < 0)
+            left = effects->numberOfDesktops() + left;
+        int right = current - old;
+        if (right < 0)
+            right = effects->numberOfDesktops() + right;
+        if (left < right) {
+            for (int i = 0; i < left; i++) {
+                slideRotations.enqueue(Left);
+            }
+        } else {
+            for (int i = 0; i < right; i++) {
+                slideRotations.enqueue(Right);
+            }
+        }
+    }
+    timeLine.setDuration((float)rotationDuration / (float)slideRotations.count());
+    if (activate) {
+        startAnimation();
+        front_desktop = old;
+        effects->addRepaintFull();
+    }
+}
+
+void CubeSlideEffect::startAnimation() {
+    const EffectWindowList windows = effects->stackingOrder();
+    for (EffectWindow* w : windows) {
+        if (!shouldAnimate(w)) {
+            w->setData(WindowForceBlurRole, QVariant(true));
+            w->setData(WindowForceBackgroundContrastRole, QVariant(true));
+            staticWindows.insert(w);
+        }
+    }
+    if (slideRotations.count() == 1) {
+        timeLine.setEasingCurve(QEasingCurve::InOutSine);
+    } else {
+        timeLine.setEasingCurve(QEasingCurve::InSine);
+    }
+    effects->setActiveFullScreenEffect(this);
+    timeLine.setCurrentTime(0);
+}
+
+void CubeSlideEffect::slotWindowAdded(EffectWindow* w) {
+    if (!isActive()) {
+        return;
+    }
+    if (!shouldAnimate(w)) {
+        staticWindows.insert(w);
+        w->setData(WindowForceBlurRole, QVariant(true));
+        w->setData(WindowForceBackgroundContrastRole, QVariant(true));
+    }
+}
+
+void CubeSlideEffect::slotWindowDeleted(EffectWindow* w) {
+    staticWindows.remove(w);
+}
+
+bool CubeSlideEffect::shouldAnimate(const EffectWindow* w) const
+{
+    if (w->isDock()) {
+        return !dontSlidePanels;
+    }
+    if (w->isOnAllDesktops()) {
+        if (w->isDesktop()) {
+            return true;
+        }
+        if (w->isSpecialWindow()) {
+            return false;
+        }
+        return !dontSlideStickyWindows;
+    }
+    return true;
+}
+
+void CubeSlideEffect::slotWindowStepUserMovedResized(EffectWindow* w)
+{
+    if (!useWindowMoving)
+        return;
+    if (!effects->kwinOption(SwitchDesktopOnScreenEdgeMovingWindows).toBool())
+        return;
+    if (w->isUserResize())
+        return;
+    const QSize screenSize = effects->virtualScreenSize();
+    const QPoint cursor = effects->cursorPos();
+    const int horizontal = screenSize.width() * 0.1;
+    const int vertical = screenSize.height() * 0.1;
+    const QRect leftRect(0, screenSize.height() * 0.1, horizontal, screenSize.height() * 0.8);
+    const QRect rightRect(screenSize.width() - horizontal, screenSize.height() * 0.1, horizontal, screenSize.height() * 0.8);
+    const QRect topRect(horizontal, 0, screenSize.width() * 0.8, vertical);
+    const QRect bottomRect(horizontal, screenSize.height() - vertical, screenSize.width() - horizontal * 2, vertical);
+    if (leftRect.contains(cursor)) {
+        if (effects->desktopToLeft(effects->currentDesktop()) != effects->currentDesktop())
+            windowMovingChanged(0.3 *(float)(horizontal - cursor.x()) / (float)horizontal, Left);
+    } else if (rightRect.contains(cursor)) {
+        if (effects->desktopToRight(effects->currentDesktop()) != effects->currentDesktop())
+            windowMovingChanged(0.3 *(float)(cursor.x() - screenSize.width() + horizontal) / (float)horizontal, Right);
+    } else if (topRect.contains(cursor)) {
+        if (effects->desktopAbove(effects->currentDesktop()) != effects->currentDesktop())
+            windowMovingChanged(0.3 *(float)(vertical - cursor.y()) / (float)vertical, Upwards);
+    } else if (bottomRect.contains(cursor)) {
+        if (effects->desktopBelow(effects->currentDesktop()) != effects->currentDesktop())
+            windowMovingChanged(0.3 *(float)(cursor.y() - screenSize.height() + vertical) / (float)vertical, Downwards);
+    } else {
+        // not in one of the areas
+        windowMoving = false;
+        desktopChangedWhileMoving = false;
+        timeLine.setCurrentTime(0);
+        lastPresentTime = std::chrono::milliseconds::zero();
+        if (!slideRotations.isEmpty())
+            slideRotations.clear();
+        effects->setActiveFullScreenEffect(nullptr);
+        effects->addRepaintFull();
+    }
+}
+
+void CubeSlideEffect::slotWindowFinishUserMovedResized(EffectWindow* w)
+{
+    if (!useWindowMoving)
+        return;
+    if (!effects->kwinOption(SwitchDesktopOnScreenEdgeMovingWindows).toBool())
+        return;
+    if (w->isUserResize())
+        return;
+    if (!desktopChangedWhileMoving) {
+        if (slideRotations.isEmpty())
+            return;
+        const RotationDirection direction = slideRotations.dequeue();
+        switch(direction) {
+        case Left:
+            slideRotations.enqueue(Right);
+            break;
+        case Right:
+            slideRotations.enqueue(Left);
+            break;
+        case Upwards:
+            slideRotations.enqueue(Downwards);
+            break;
+        case Downwards:
+            slideRotations.enqueue(Upwards);
+            break;
+        default:
+            break; // impossible
+        }
+        timeLine.setCurrentTime(timeLine.duration() - timeLine.currentTime());
+    }
+    desktopChangedWhileMoving = false;
+    windowMoving = false;
+    effects->addRepaintFull();
+}
+
+void CubeSlideEffect::windowMovingChanged(float progress, RotationDirection direction)
+{
+    if (desktopChangedWhileMoving)
+        progressRestriction = 1.0 - progress;
+    else
+        progressRestriction = progress;
+    front_desktop = effects->currentDesktop();
+    if (slideRotations.isEmpty()) {
+        slideRotations.enqueue(direction);
+        windowMoving = true;
+        startAnimation();
+    }
+    effects->addRepaintFull();
+}
+
+bool CubeSlideEffect::isActive() const
+{
+    return !slideRotations.isEmpty();
+}
+
+void CubeSlideEffect::slotNumberDesktopsChanged()
+{
+    // This effect animates only aftermaths of desktop switching. There is no any
+    // way to reference removed desktops for animation purposes. So our the best
+    // shot is just to do nothing. It doesn't look nice and we probaby have to
+    // find more proper way to handle this case.
+
+    if (!isActive()) {
+        return;
+    }
+
+    for (EffectWindow *w : qAsConst(staticWindows)) {
+        w->setData(WindowForceBlurRole, QVariant());
+        w->setData(WindowForceBackgroundContrastRole, QVariant());
+    }
+
+    slideRotations.clear();
+    staticWindows.clear();
+    lastPresentTime = std::chrono::milliseconds::zero();
+
+    effects->setActiveFullScreenEffect(nullptr);
+}
+
+} // namespace
diff --git a/src/effects/cubeslide/cubeslide.h b/src/effects/cubeslide/cubeslide.h
new file mode 100644
index 000000000..e4f38ca75
--- /dev/null
+++ b/src/effects/cubeslide/cubeslide.h
@@ -0,0 +1,106 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_CUBESLIDE_H
+#define KWIN_CUBESLIDE_H
+
+#include <kwineffects.h>
+#include <kwinglutils.h>
+#include <QQueue>
+#include <QSet>
+#include <QTimeLine>
+
+namespace KWin
+{
+class CubeSlideEffect
+    : public Effect
+{
+    Q_OBJECT
+    Q_PROPERTY(int rotationDuration READ configuredRotationDuration)
+    Q_PROPERTY(bool dontSlidePanels READ isDontSlidePanels)
+    Q_PROPERTY(bool dontSlideStickyWindows READ isDontSlideStickyWindows)
+    Q_PROPERTY(bool usePagerLayout READ isUsePagerLayout)
+    Q_PROPERTY(bool useWindowMoving READ isUseWindowMoving)
+public:
+    CubeSlideEffect();
+    ~CubeSlideEffect() override;
+    void reconfigure(ReconfigureFlags) override;
+    void prePaintScreen(ScreenPrePaintData& data, std::chrono::milliseconds presentTime) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
+    void postPaintScreen() override;
+    void prePaintWindow(EffectWindow* w, WindowPrePaintData& data, std::chrono::milliseconds presentTime) override;
+    void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
+    bool isActive() const override;
+
+    int requestedEffectChainPosition() const override {
+        return 50;
+    }
+
+    static bool supported();
+
+    // for properties
+    int configuredRotationDuration() const {
+        return rotationDuration;
+    }
+    bool isDontSlidePanels() const {
+        return dontSlidePanels;
+    }
+    bool isDontSlideStickyWindows() const {
+        return dontSlideStickyWindows;
+    }
+    bool isUsePagerLayout() const {
+        return usePagerLayout;
+    }
+    bool isUseWindowMoving() const {
+        return useWindowMoving;
+    }
+private Q_SLOTS:
+    void slotWindowAdded(EffectWindow* w);
+    void slotWindowDeleted(EffectWindow* w);
+
+    void slotDesktopChanged(int old, int current, EffectWindow* w);
+    void slotWindowStepUserMovedResized(KWin::EffectWindow *w);
+    void slotWindowFinishUserMovedResized(KWin::EffectWindow *w);
+    void slotNumberDesktopsChanged();
+
+private:
+    enum RotationDirection {
+        Left,
+        Right,
+        Upwards,
+        Downwards
+    };
+    void paintSlideCube(int mask, QRegion region, ScreenPaintData& data);
+    void windowMovingChanged(float progress, RotationDirection direction);
+
+    bool shouldAnimate(const EffectWindow* w) const;
+    void startAnimation();
+
+    bool cube_painting;
+    int front_desktop;
+    int painting_desktop;
+    int other_desktop;
+    bool firstDesktop;
+    bool stickyPainting;
+    QSet<EffectWindow*> staticWindows;
+    QTimeLine timeLine;
+    std::chrono::milliseconds lastPresentTime;
+    QQueue<RotationDirection> slideRotations;
+    bool dontSlidePanels;
+    bool dontSlideStickyWindows;
+    bool usePagerLayout;
+    int rotationDuration;
+    bool useWindowMoving;
+    bool windowMoving;
+    bool desktopChangedWhileMoving;
+    double progressRestriction;
+};
+}
+
+#endif
diff --git a/src/effects/cubeslide/cubeslide.kcfg b/src/effects/cubeslide/cubeslide.kcfg
new file mode 100644
index 000000000..0bf2bd227
--- /dev/null
+++ b/src/effects/cubeslide/cubeslide.kcfg
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<kcfg xmlns="http://www.kde.org/standards/kcfg/1.0"
+      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+      xsi:schemaLocation="http://www.kde.org/standards/kcfg/1.0
+                          http://www.kde.org/standards/kcfg/1.0/kcfg.xsd" >
+    <kcfgfile arg="true"/>
+    <group name="Effect-CubeSlide">
+        <entry name="RotationDuration" type="Int">
+            <default>0</default>
+        </entry>
+        <entry name="DontSlidePanels" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="DontSlideStickyWindows" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="UsePagerLayout" type="Bool">
+            <default>true</default>
+        </entry>
+        <entry name="UseWindowMoving" type="Bool">
+            <default>false</default>
+        </entry>
+    </group>
+</kcfg>
diff --git a/src/effects/cubeslide/cubeslide_config.cpp b/src/effects/cubeslide/cubeslide_config.cpp
new file mode 100644
index 000000000..24a40e21a
--- /dev/null
+++ b/src/effects/cubeslide/cubeslide_config.cpp
@@ -0,0 +1,58 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#include "cubeslide_config.h"
+// KConfigSkeleton
+#include "cubeslideconfig.h"
+#include <config-kwin.h>
+#include <kwineffects_interface.h>
+
+#include <kconfiggroup.h>
+#include <KAboutData>
+#include <KPluginFactory>
+#include <QVBoxLayout>
+
+K_PLUGIN_FACTORY_WITH_JSON(CubeSlideEffectConfigFactory,
+                           "cubeslide_config.json",
+                           registerPlugin<KWin::CubeSlideEffectConfig>();)
+
+namespace KWin
+{
+
+CubeSlideEffectConfigForm::CubeSlideEffectConfigForm(QWidget* parent) : QWidget(parent)
+{
+    setupUi(this);
+}
+
+CubeSlideEffectConfig::CubeSlideEffectConfig(QWidget* parent, const QVariantList& args) :
+    KCModule(parent, args)
+{
+    m_ui = new CubeSlideEffectConfigForm(this);
+
+    QVBoxLayout* layout = new QVBoxLayout(this);
+
+    layout->addWidget(m_ui);
+
+    CubeSlideConfig::instance(KWIN_CONFIG);
+    addConfig(CubeSlideConfig::self(), m_ui);
+
+    load();
+}
+
+void CubeSlideEffectConfig::save()
+{
+    KCModule::save();
+    OrgKdeKwinEffectsInterface interface(QStringLiteral("org.kde.KWin"),
+                                         QStringLiteral("/Effects"),
+                                         QDBusConnection::sessionBus());
+    interface.reconfigureEffect(QStringLiteral("cubeslide"));
+}
+
+} // namespace
+
+#include "cubeslide_config.moc"
diff --git a/src/effects/cubeslide/cubeslide_config.desktop b/src/effects/cubeslide/cubeslide_config.desktop
new file mode 100644
index 000000000..473807b22
--- /dev/null
+++ b/src/effects/cubeslide/cubeslide_config.desktop
@@ -0,0 +1,74 @@
+[Desktop Entry]
+Type=Service
+X-KDE-ServiceTypes=KCModule
+
+X-KDE-Library=kwin_cubeslide_config
+X-KDE-ParentComponents=cubeslide
+
+Name=Desktop Cube Animation
+Name[az]=Animasiyalı İş Masası kubu
+Name[bg]=Кубична анимация върху работен плот
+Name[bs]=Animacija kocke površi
+Name[ca]=Animació de cub per a l'escriptori
+Name[ca@valencia]=Animació de cub d'escriptori
+Name[cs]=Animace kostky plochy
+Name[csb]=Animacëjô Szescanu pùltu
+Name[da]=Animeret skrivebordsterning
+Name[de]=Animation Arbeitsflächen-Würfel
+Name[el]=Εφέ κύβου επιφάνειας εργασίας
+Name[en_GB]=Desktop Cube Animation
+Name[eo]=Movbildo de Labortabla kubo
+Name[es]=Animación del cubo de escritorio
+Name[et]=Töölauakuubiku animeerimine
+Name[eu]=Mahaigain kuboaren animazioa
+Name[fi]=Työpöytäkuutioanimaatio
+Name[fr]=Animation du bureau en cube
+Name[fy]=Buroblêd kubus animaasje
+Name[ga]=Beochan an Chiúib Deisce
+Name[gl]=Animación do cubo do escritorio
+Name[gu]=ડેસ્ટોપ ક્યુબ એનિમેશન
+Name[he]=הנפשת שולחן עבודה בקובייה
+Name[hi]=डेस्कटॉप घन एनिमेशन
+Name[hr]=Animacija kocke s radnom površinom
+Name[hu]=Asztalváltó kocka
+Name[ia]=Animation de cubo de scriptorio
+Name[id]=Animasi Kubus Desktop
+Name[is]=Hreyfingar á skjáborðskubbi
+Name[it]=Animazione del cubo dei desktop
+Name[ja]=デスクトップキューブのアニメーション
+Name[kk]=Үстел текшесін анимациялау
+Name[km]=ការ​ធ្វើ​ឲ្យ​គូប​ផ្ទៃតុ​មាន​ចលនា​
+Name[kn]=ಗಣಕತೆರೆ ಘನಾಕೃತಿಯ ಸಜೀವನ(ಎನಿಮೇಶನ್)
+Name[ko]=데스크톱 큐브 애니메이션
+Name[lt]=Darbalaukio kubo animacija
+Name[lv]=Darbvirsmas kuba animācija
+Name[mk]=Анимација „Работна коцка“
+Name[ml]=പണിയിടം ക്യൂബ് നീക്കം
+Name[mr]=डेस्कटॉप क्यूब ऍनीमेशन
+Name[nb]=Animert skrivebordsterning
+Name[nds]=Animeert Wörpel-Schriefdisch
+Name[nl]=Animatie met bureaubladkubus
+Name[nn]=Kubeskifte av skrivebord
+Name[pa]=ਡੈਸਕਟਾਪ ਘਣ ਐਨੀਮੇਸ਼ਨ
+Name[pl]=Animacja sześcianu pulpitów
+Name[pt]=Animação do Cubo de Ecrãs
+Name[pt_BR]=Animação do cubo de áreas de trabalho
+Name[ro]=Animație Cub de birou
+Name[ru]=Анимация куба рабочих столов
+Name[si]=වැඩතල ඝනක සජීවීකරණය
+Name[sk]=Animácia plochy na kocke
+Name[sl]=Animacija kocka z namizji
+Name[sr]=Анимација коцке површи
+Name[sr@ijekavian]=Анимација коцке површи
+Name[sr@ijekavianlatin]=Animacija kocke površi
+Name[sr@latin]=Animacija kocke površi
+Name[sv]=Animering med skrivbordskub
+Name[th]=พื้นที่ทำงานทรงลูกบาศก์แบบเคลื่อนไหว
+Name[tr]=Masaüstü Küp Animasyonu
+Name[ug]=ئۈستەلئۈستى كۇب جانلاندۇرۇمى
+Name[uk]=Анімація куба стільниць
+Name[vi]=Hiệu ứng khối vuông màn hình
+Name[wa]=Animåcion cube do scribannes
+Name[x-test]=xxDesktop Cube Animationxx
+Name[zh_CN]=3D 切换
+Name[zh_TW]=桌面立方體動畫
diff --git a/src/effects/cubeslide/cubeslide_config.h b/src/effects/cubeslide/cubeslide_config.h
new file mode 100644
index 000000000..8a49c6eee
--- /dev/null
+++ b/src/effects/cubeslide/cubeslide_config.h
@@ -0,0 +1,43 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_CUBESLIDE_CONFIG_H
+#define KWIN_CUBESLIDE_CONFIG_H
+
+#include <kcmodule.h>
+
+#include "ui_cubeslide_config.h"
+
+
+namespace KWin
+{
+
+class CubeSlideEffectConfigForm : public QWidget, public Ui::CubeSlideEffectConfigForm
+{
+    Q_OBJECT
+public:
+    explicit CubeSlideEffectConfigForm(QWidget* parent);
+};
+
+class CubeSlideEffectConfig : public KCModule
+{
+    Q_OBJECT
+public:
+    explicit CubeSlideEffectConfig(QWidget* parent = nullptr, const QVariantList& args = QVariantList());
+
+public Q_SLOTS:
+    void save() override;
+
+private:
+    CubeSlideEffectConfigForm* m_ui;
+};
+
+} // namespace
+
+#endif
diff --git a/src/effects/cubeslide/cubeslide_config.ui b/src/effects/cubeslide/cubeslide_config.ui
new file mode 100644
index 000000000..44acfe9ad
--- /dev/null
+++ b/src/effects/cubeslide/cubeslide_config.ui
@@ -0,0 +1,105 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>KWin::CubeSlideEffectConfigForm</class>
+ <widget class="QWidget" name="KWin::CubeSlideEffectConfigForm">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>431</width>
+    <height>161</height>
+   </rect>
+  </property>
+  <layout class="QGridLayout" name="gridLayout">
+   <item row="2" column="0" colspan="2">
+    <widget class="QCheckBox" name="kcfg_DontSlideStickyWindows">
+     <property name="text">
+      <string>Do not animate windows on all desktops</string>
+     </property>
+    </widget>
+   </item>
+   <item row="5" column="0">
+    <spacer name="verticalSpacer">
+     <property name="orientation">
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeHint" stdset="0">
+      <size>
+       <width>20</width>
+       <height>40</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+   <item row="0" column="1">
+    <widget class="QSpinBox" name="kcfg_RotationDuration">
+     <property name="sizePolicy">
+      <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+       <horstretch>0</horstretch>
+       <verstretch>0</verstretch>
+      </sizepolicy>
+     </property>
+     <property name="minimumSize">
+      <size>
+       <width>100</width>
+       <height>0</height>
+      </size>
+     </property>
+     <property name="specialValueText">
+      <string comment="Duration of rotation">Default</string>
+     </property>
+     <property name="suffix">
+      <string> msec</string>
+     </property>
+     <property name="maximum">
+      <number>5000</number>
+     </property>
+     <property name="singleStep">
+      <number>10</number>
+     </property>
+    </widget>
+   </item>
+   <item row="1" column="0" colspan="2">
+    <widget class="QCheckBox" name="kcfg_DontSlidePanels">
+     <property name="text">
+      <string>Do not animate panels</string>
+     </property>
+    </widget>
+   </item>
+   <item row="0" column="0">
+    <widget class="QLabel" name="label">
+     <property name="text">
+      <string>Rotation duration:</string>
+     </property>
+     <property name="alignment">
+      <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+     </property>
+     <property name="buddy">
+      <cstring>kcfg_RotationDuration</cstring>
+     </property>
+    </widget>
+   </item>
+   <item row="3" column="0" colspan="2">
+    <widget class="QCheckBox" name="kcfg_UsePagerLayout">
+     <property name="text">
+      <string>Use pager layout for animation</string>
+     </property>
+    </widget>
+   </item>
+   <item row="4" column="0" colspan="2">
+    <widget class="QCheckBox" name="kcfg_UseWindowMoving">
+     <property name="text">
+      <string>Start animation when moving windows towards screen edges</string>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>kcfg_RotationDuration</tabstop>
+  <tabstop>kcfg_DontSlidePanels</tabstop>
+  <tabstop>kcfg_DontSlideStickyWindows</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/src/effects/cubeslide/cubeslideconfig.kcfgc b/src/effects/cubeslide/cubeslideconfig.kcfgc
new file mode 100644
index 000000000..6059a7e3e
--- /dev/null
+++ b/src/effects/cubeslide/cubeslideconfig.kcfgc
@@ -0,0 +1,5 @@
+File=cubeslide.kcfg
+ClassName=CubeSlideConfig
+NameSpace=KWin
+Singleton=true
+Mutators=true
diff --git a/src/effects/effect_builtins.cpp b/src/effects/effect_builtins.cpp
index fb5679935..66cf57d10 100644
--- a/src/effects/effect_builtins.cpp
+++ b/src/effects/effect_builtins.cpp
@@ -35,6 +35,10 @@
 #include "windowgeometry/windowgeometry.h"
 #include "zoom/zoom.h"
 // OpenGL-specific effects for desktop
+#include "coverswitch/coverswitch.h"
+#include "cube/cube.h"
+#include "cubeslide/cubeslide.h"
+#include "flipswitch/flipswitch.h"
 #include "glide/glide.h"
 #include "invert/invert.h"
 #include "lookingglass/lookingglass.h"
@@ -133,6 +137,54 @@ EFFECT_FALLBACK
 #endif
 EFFECT_FALLBACK
         QString()
+    }, {
+        QStringLiteral("coverswitch"),
+        i18ndc("kwin_effects", "Name of a KWin Effect", "Cover Switch"),
+        i18ndc("kwin_effects", "Comment describing the KWin Effect", "Display a Cover Flow effect for the alt+tab window switcher"),
+        QStringLiteral("Window Management"),
+        QString(),
+        QUrl(QStringLiteral("https://files.kde.org/plasma/kwin/effect-videos/cover_switch.mp4")),
+        false,
+        true,
+#ifdef EFFECT_BUILTINS
+        &createHelper<CoverSwitchEffect>,
+        &CoverSwitchEffect::supported,
+        nullptr,
+#endif
+EFFECT_FALLBACK
+        QStringLiteral("kwin_coverswitch_config")
+    }, {
+        QStringLiteral("cube"),
+        i18ndc("kwin_effects", "Name of a KWin Effect", "Desktop Cube"),
+        i18ndc("kwin_effects", "Comment describing the KWin Effect", "Display each virtual desktop on a side of a cube"),
+        QStringLiteral("Window Management"),
+        QString(),
+        QUrl(QStringLiteral("https://files.kde.org/plasma/kwin/effect-videos/desktop_cube.ogv")),
+        false,
+        false,
+#ifdef EFFECT_BUILTINS
+        &createHelper<CubeEffect>,
+        &CubeEffect::supported,
+        nullptr,
+#endif
+EFFECT_FALLBACK
+        QStringLiteral("kwin_cube_config")
+    }, {
+        QStringLiteral("cubeslide"),
+        i18ndc("kwin_effects", "Name of a KWin Effect", "Desktop Cube Animation"),
+        i18ndc("kwin_effects", "Comment describing the KWin Effect", "Animate desktop switching with a cube"),
+        QStringLiteral("Virtual Desktop Switching Animation"),
+        QStringLiteral("desktop-animations"),
+        QUrl(QStringLiteral("https://files.kde.org/plasma/kwin/effect-videos/desktop_cube_animation.ogv")),
+        false,
+        false,
+#ifdef EFFECT_BUILTINS
+        &createHelper<CubeSlideEffect>,
+        &CubeSlideEffect::supported,
+        nullptr,
+#endif
+EFFECT_FALLBACK
+        QStringLiteral("kwin_cubeslide_config")
     }, {
         QStringLiteral("desktopgrid"),
         i18ndc("kwin_effects", "Name of a KWin Effect", "Desktop Grid"),
@@ -181,6 +233,22 @@ EFFECT_FALLBACK
 #endif
 EFFECT_FALLBACK
         QString()
+    }, {
+        QStringLiteral("flipswitch"),
+        i18ndc("kwin_effects", "Name of a KWin Effect", "Flip Switch"),
+        i18ndc("kwin_effects", "Comment describing the KWin Effect", "Flip through windows that are in a stack for the alt+tab window switcher"),
+        QStringLiteral("Window Management"),
+        QString(),
+        QUrl(QStringLiteral("https://files.kde.org/plasma/kwin/effect-videos/flip_switch.mp4")),
+        false,
+        false,
+#ifdef EFFECT_BUILTINS
+        &createHelper<FlipSwitchEffect>,
+        &FlipSwitchEffect::supported,
+        nullptr,
+#endif
+EFFECT_FALLBACK
+        QStringLiteral("kwin_flipswitch_config")
     }, {
         QStringLiteral("glide"),
         i18ndc("kwin_effects", "Name of a KWin Effect", "Glide"),
diff --git a/src/effects/effect_builtins.h b/src/effects/effect_builtins.h
index d86a0e365..1e9f786be 100644
--- a/src/effects/effect_builtins.h
+++ b/src/effects/effect_builtins.h
@@ -26,9 +26,13 @@ enum class BuiltInEffect
     Blur,
     ColorPicker,
     Contrast,
+    CoverSwitch,
+    Cube,
+    CubeSlide,
     DesktopGrid,
     DimInactive,
     FallApart,
+    FlipSwitch,
     Glide,
     HighlightWindow,
     Invert,
diff --git a/src/effects/flipswitch/CMakeLists.txt b/src/effects/flipswitch/CMakeLists.txt
new file mode 100644
index 000000000..852e5dc92
--- /dev/null
+++ b/src/effects/flipswitch/CMakeLists.txt
@@ -0,0 +1,24 @@
+#######################################
+# Config
+set(kwin_flipswitch_config_SRCS flipswitch_config.cpp)
+ki18n_wrap_ui(kwin_flipswitch_config_SRCS flipswitch_config.ui)
+kconfig_add_kcfg_files(kwin_flipswitch_config_SRCS flipswitchconfig.kcfgc)
+
+add_library(kwin_flipswitch_config MODULE ${kwin_flipswitch_config_SRCS})
+
+target_link_libraries(kwin_flipswitch_config
+    KF5::ConfigWidgets
+    KF5::GlobalAccel
+    KF5::I18n
+    KF5::XmlGui
+    KWinEffectsInterface
+)
+
+kcoreaddons_desktop_to_json(kwin_flipswitch_config flipswitch_config.desktop SERVICE_TYPES kcmodule.desktop)
+
+install(
+    TARGETS
+        kwin_flipswitch_config
+    DESTINATION
+        ${KDE_INSTALL_PLUGINDIR}/kwin/effects/configs
+)
diff --git a/src/effects/flipswitch/flipswitch.cpp b/src/effects/flipswitch/flipswitch.cpp
new file mode 100644
index 000000000..f7300d11a
--- /dev/null
+++ b/src/effects/flipswitch/flipswitch.cpp
@@ -0,0 +1,987 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008, 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#include "flipswitch.h"
+// KConfigSkeleton
+#include "flipswitchconfig.h"
+
+#include <QAction>
+#include <kwinconfig.h>
+#include <QKeyEvent>
+
+#include <KGlobalAccel>
+#include <KLocalizedString>
+
+#include <kwinglutils.h>
+
+#include <cmath>
+
+namespace KWin
+{
+
+FlipSwitchEffect::FlipSwitchEffect()
+    : m_selectedWindow(nullptr)
+    , m_currentAnimationEasingCurve(QEasingCurve::InOutSine)
+    , m_lastPresentTime(std::chrono::milliseconds::zero())
+    , m_active(false)
+    , m_start(false)
+    , m_stop(false)
+    , m_animation(false)
+    , m_hasKeyboardGrab(false)
+    , m_captionFrame(nullptr)
+{
+    initConfig<FlipSwitchConfig>();
+    reconfigure(ReconfigureAll);
+
+    // Caption frame
+    m_captionFont.setBold(true);
+    m_captionFont.setPointSize(m_captionFont.pointSize() * 2);
+
+    QAction* flipSwitchCurrentAction = new QAction(this);
+    flipSwitchCurrentAction->setObjectName(QStringLiteral("FlipSwitchCurrent"));
+    flipSwitchCurrentAction->setText(i18n("Toggle Flip Switch (Current desktop)"));
+    KGlobalAccel::self()->setShortcut(flipSwitchCurrentAction, QList<QKeySequence>());
+    m_shortcutCurrent = KGlobalAccel::self()->shortcut(flipSwitchCurrentAction);
+    effects->registerGlobalShortcut(QKeySequence(), flipSwitchCurrentAction);
+    connect(flipSwitchCurrentAction, &QAction::triggered, this, &FlipSwitchEffect::toggleActiveCurrent);
+    QAction* flipSwitchAllAction = new QAction(this);
+    flipSwitchAllAction->setObjectName(QStringLiteral("FlipSwitchAll"));
+    flipSwitchAllAction->setText(i18n("Toggle Flip Switch (All desktops)"));
+    KGlobalAccel::self()->setShortcut(flipSwitchAllAction, QList<QKeySequence>());
+    effects->registerGlobalShortcut(QKeySequence(), flipSwitchAllAction);
+    m_shortcutAll = KGlobalAccel::self()->shortcut(flipSwitchAllAction);
+    connect(flipSwitchAllAction, &QAction::triggered, this, &FlipSwitchEffect::toggleActiveAllDesktops);
+    connect(KGlobalAccel::self(), &KGlobalAccel::globalShortcutChanged, this, &FlipSwitchEffect::globalShortcutChanged);
+    connect(effects, &EffectsHandler::windowAdded, this, &FlipSwitchEffect::slotWindowAdded);
+    connect(effects, &EffectsHandler::windowClosed, this, &FlipSwitchEffect::slotWindowClosed);
+    connect(effects, &EffectsHandler::tabBoxAdded, this, &FlipSwitchEffect::slotTabBoxAdded);
+    connect(effects, &EffectsHandler::tabBoxClosed, this, &FlipSwitchEffect::slotTabBoxClosed);
+    connect(effects, &EffectsHandler::tabBoxUpdated, this, &FlipSwitchEffect::slotTabBoxUpdated);
+    connect(effects, &EffectsHandler::tabBoxKeyEvent, this, &FlipSwitchEffect::slotTabBoxKeyEvent);
+    connect(effects, &EffectsHandler::screenAboutToLock, this, [this]() {
+        setActive(false, AllDesktopsMode);
+        setActive(false, CurrentDesktopMode);
+    });
+}
+
+FlipSwitchEffect::~FlipSwitchEffect()
+{
+    delete m_captionFrame;
+}
+
+bool FlipSwitchEffect::supported()
+{
+    return effects->isOpenGLCompositing() && effects->animationsSupported();
+}
+
+void FlipSwitchEffect::reconfigure(ReconfigureFlags)
+{
+    FlipSwitchConfig::self()->read();
+    m_tabbox = FlipSwitchConfig::tabBox();
+    m_tabboxAlternative = FlipSwitchConfig::tabBoxAlternative();
+    const int duration = animationTime<FlipSwitchConfig>(200);
+    m_timeLine.setDuration(duration);
+    m_startStopTimeLine.setDuration(duration);
+
+    m_angle = FlipSwitchConfig::angle();
+    m_xPosition = FlipSwitchConfig::xPosition() / 100.0f;
+    m_yPosition = FlipSwitchConfig::yPosition() / 100.0f;
+    m_windowTitle = FlipSwitchConfig::windowTitle();
+}
+
+void FlipSwitchEffect::prePaintScreen(ScreenPrePaintData& data, std::chrono::milliseconds presentTime)
+{
+    int time = 0;
+    if (m_animation || m_start || m_stop) {
+        if (m_lastPresentTime.count()) {
+            time = (presentTime - m_lastPresentTime).count();
+        }
+        m_lastPresentTime = presentTime;
+    }
+
+    data.mask |= PAINT_SCREEN_WITH_TRANSFORMED_WINDOWS;
+    if (m_start)
+        m_startStopTimeLine.setCurrentTime(m_startStopTimeLine.currentTime() + time);
+    if (m_stop && m_scheduledDirections.isEmpty())
+        m_startStopTimeLine.setCurrentTime(m_startStopTimeLine.currentTime() - time);
+    if (m_animation)
+        m_timeLine.setCurrentTime(m_timeLine.currentTime() + time);
+
+    effects->prePaintScreen(data, presentTime);
+}
+
+void FlipSwitchEffect::paintScreen(int mask, const QRegion &region, ScreenPaintData& data)
+{
+    effects->paintScreen(mask, region, data);
+    if (m_active) {
+        EffectWindowList tempList;
+        if (m_mode == TabboxMode)
+            tempList = effects->currentTabBoxWindowList();
+        else {
+            // we have to setup the list
+            // using stacking order directly is not possible
+            // as not each window in stacking order is shown
+            // TODO: store list instead of calculating in each frame?
+            Q_FOREACH (EffectWindow * w, effects->stackingOrder()) {
+                if (m_windows.contains(w))
+                    tempList.append(w);
+            }
+        }
+        m_flipOrderedWindows.clear();
+        int index = tempList.indexOf(m_selectedWindow);
+
+        int tabIndex = index;
+        if (m_mode == TabboxMode) {
+            Q_FOREACH (SwitchingDirection direction, m_scheduledDirections) { // krazy:exclude=foreach
+                if (direction == DirectionBackward)
+                    index++;
+                else
+                    index--;
+                if (index < 0)
+                    index = tempList.count() + index;
+                if (index >= tempList.count())
+                    index = index % tempList.count();
+            }
+            tabIndex = index;
+            EffectWindow* w = nullptr;
+            if (!m_scheduledDirections.isEmpty() && m_scheduledDirections.head() == DirectionBackward) {
+                index--;
+                if (index < 0)
+                    index = tempList.count() + index;
+                w = tempList.at(index);
+            }
+            for (int i = index - 1; i >= 0; i--)
+                m_flipOrderedWindows.append(tempList.at(i));
+            for (int i = effects->currentTabBoxWindowList().count() - 1; i >= index; i--)
+                m_flipOrderedWindows.append(tempList.at(i));
+            if (w) {
+                m_flipOrderedWindows.removeAll(w);
+                m_flipOrderedWindows.append(w);
+            }
+        } else {
+            Q_FOREACH (SwitchingDirection direction, m_scheduledDirections) { // krazy:exclude=foreach
+                if (direction == DirectionForward)
+                    index++;
+                else
+                    index--;
+                if (index < 0)
+                    index = tempList.count() - 1;
+                if (index >= tempList.count())
+                    index = 0;
+            }
+            tabIndex = index;
+            EffectWindow* w = nullptr;
+            if (!m_scheduledDirections.isEmpty() && m_scheduledDirections.head() == DirectionBackward) {
+                index++;
+                if (index >= tempList.count())
+                    index = 0;
+            }
+            // sort from stacking order
+            for (int i = index + 1; i < tempList.count(); i++)
+                m_flipOrderedWindows.append(tempList.at(i));
+            for (int i = 0; i <= index; i++)
+                m_flipOrderedWindows.append(tempList.at(i));
+            if (w) {
+                m_flipOrderedWindows.removeAll(w);
+                m_flipOrderedWindows.append(w);
+            }
+        }
+
+
+        int winMask = PAINT_WINDOW_TRANSFORMED | PAINT_WINDOW_TRANSLUCENT;
+        // fade in/out one window at the end of the stack during animation
+        if (m_animation && !m_scheduledDirections.isEmpty()) {
+            EffectWindow* w = m_flipOrderedWindows.last();
+            if (ItemInfo *info = m_windows.value(w,0)) {
+                WindowPaintData data(w);
+                if (effects->numScreens() > 1) {
+                    data.setProjectionMatrix(m_projectionMatrix);
+                    data.setModelViewMatrix(m_modelviewMatrix);
+                }
+                data.setRotationAxis(Qt::YAxis);
+                data.setRotationAngle(m_angle * m_startStopTimeLine.currentValue());
+                data.setOpacity(info->opacity);
+                data.setBrightness(info->brightness);
+                data.setSaturation(info->saturation);
+                int distance = tempList.count() - 1;
+                float zDistance = 500.0f;
+                data.translate(- (w->x() - m_screenArea.x() + data.xTranslation()) * m_startStopTimeLine.currentValue());
+
+                data.translate(m_screenArea.width() * m_xPosition * m_startStopTimeLine.currentValue(),
+                               (m_screenArea.y() + m_screenArea.height() * m_yPosition - (w->y() + w->height() + data.yTranslation())) * m_startStopTimeLine.currentValue());
+                data.translate(- (m_screenArea.width() * 0.25f) * distance * m_startStopTimeLine.currentValue(),
+                               - (m_screenArea.height() * 0.10f) * distance * m_startStopTimeLine.currentValue(),
+                               - (zDistance * distance) * m_startStopTimeLine.currentValue());
+                if (m_scheduledDirections.head() == DirectionForward)
+                    data.multiplyOpacity(0.8 * m_timeLine.currentValue());
+                else
+                    data.multiplyOpacity(0.8 * (1.0 - m_timeLine.currentValue()));
+
+                if (effects->numScreens() > 1) {
+                    adjustWindowMultiScreen(w, data);
+                }
+                effects->drawWindow(w, winMask, infiniteRegion(), data);
+            }
+        }
+
+        Q_FOREACH (EffectWindow *w, m_flipOrderedWindows) {
+            ItemInfo *info = m_windows.value(w,0);
+            if (!info)
+                continue;
+            WindowPaintData data(w);
+            if (effects->numScreens() > 1) {
+                data.setProjectionMatrix(m_projectionMatrix);
+                data.setModelViewMatrix(m_modelviewMatrix);
+            }
+            data.setRotationAxis(Qt::YAxis);
+            data.setRotationAngle(m_angle * m_startStopTimeLine.currentValue());
+            data.setOpacity(info->opacity);
+            data.setBrightness(info->brightness);
+            data.setSaturation(info->saturation);
+            int windowIndex = tempList.indexOf(w);
+            int distance;
+            if (m_mode == TabboxMode) {
+                if (windowIndex < tabIndex)
+                    distance = tempList.count() - (tabIndex - windowIndex);
+                else if (windowIndex > tabIndex)
+                    distance = windowIndex - tabIndex;
+                else
+                    distance = 0;
+            } else {
+                distance = m_flipOrderedWindows.count() - m_flipOrderedWindows.indexOf(w) - 1;
+
+                if (!m_scheduledDirections.isEmpty() && m_scheduledDirections.head() == DirectionBackward) {
+                    distance--;
+                }
+            }
+            if (!m_scheduledDirections.isEmpty() && m_scheduledDirections.head() == DirectionBackward) {
+                if (w == m_flipOrderedWindows.last()) {
+                    distance = -1;
+                    data.multiplyOpacity(m_timeLine.currentValue());
+                }
+            }
+            float zDistance = 500.0f;
+            data.translate(- (w->x() - m_screenArea.x() + data.xTranslation()) * m_startStopTimeLine.currentValue());
+            data.translate(m_screenArea.width() * m_xPosition * m_startStopTimeLine.currentValue(),
+                           (m_screenArea.y() + m_screenArea.height() * m_yPosition - (w->y() + w->height() + data.yTranslation())) * m_startStopTimeLine.currentValue());
+
+            data.translate(-(m_screenArea.width() * 0.25f) * distance * m_startStopTimeLine.currentValue(),
+                           -(m_screenArea.height() * 0.10f) * distance * m_startStopTimeLine.currentValue(),
+                           -(zDistance * distance) * m_startStopTimeLine.currentValue());
+            if (m_animation && !m_scheduledDirections.isEmpty()) {
+                if (m_scheduledDirections.head() == DirectionForward) {
+                    data.translate((m_screenArea.width() * 0.25f) * m_timeLine.currentValue(),
+                                   (m_screenArea.height() * 0.10f) * m_timeLine.currentValue(),
+                                   zDistance * m_timeLine.currentValue());
+                    if (distance == 0)
+                        data.multiplyOpacity((1.0 - m_timeLine.currentValue()));
+                } else {
+                    data.translate(- (m_screenArea.width() * 0.25f) * m_timeLine.currentValue(),
+                                   - (m_screenArea.height() * 0.10f) * m_timeLine.currentValue(),
+                                   - zDistance * m_timeLine.currentValue());
+                }
+            }
+            data.multiplyOpacity((0.8 + 0.2 * (1.0 - m_startStopTimeLine.currentValue())));
+            if (effects->numScreens() > 1) {
+                adjustWindowMultiScreen(w, data);
+            }
+
+            effects->drawWindow(w, winMask, infiniteRegion(), data);
+        }
+
+        if (m_windowTitle) {
+            // Render the caption frame
+            if (m_animation) {
+                m_captionFrame->setCrossFadeProgress(m_timeLine.currentValue());
+            }
+            m_captionFrame->render(region, m_startStopTimeLine.currentValue());
+        }
+    }
+}
+
+void FlipSwitchEffect::postPaintScreen()
+{
+    if (m_active) {
+        if (m_start && m_startStopTimeLine.currentValue() == 1.0f) {
+            m_start = false;
+            if (!m_scheduledDirections.isEmpty()) {
+                m_animation = true;
+                m_timeLine.setCurrentTime(0);
+                if (m_scheduledDirections.count() == 1) {
+                    m_currentAnimationEasingCurve = QEasingCurve::OutSine;
+                    m_timeLine.setEasingCurve(m_currentAnimationEasingCurve);
+                } else {
+                    m_currentAnimationEasingCurve = QEasingCurve::Linear;
+                    m_timeLine.setEasingCurve(m_currentAnimationEasingCurve);
+                }
+            }
+            effects->addRepaintFull();
+        }
+        if (m_stop && m_startStopTimeLine.currentValue() == 0.0f) {
+            m_stop = false;
+            m_active = false;
+            m_captionFrame->free();
+            effects->setActiveFullScreenEffect(nullptr);
+            effects->addRepaintFull();
+            qDeleteAll(m_windows);
+            m_windows.clear();
+        }
+        if (m_animation && m_timeLine.currentValue() == 1.0f) {
+            m_timeLine.setCurrentTime(0);
+            m_scheduledDirections.dequeue();
+            if (m_scheduledDirections.isEmpty()) {
+                m_animation = false;
+                effects->addRepaintFull();
+            } else {
+                if (m_scheduledDirections.count() == 1) {
+                    if (m_stop)
+                        m_currentAnimationEasingCurve = QEasingCurve::Linear;
+                    else
+                        m_currentAnimationEasingCurve = QEasingCurve::OutSine;
+                } else {
+                    m_currentAnimationEasingCurve = QEasingCurve::Linear;
+                }
+                m_timeLine.setEasingCurve(m_currentAnimationEasingCurve);
+            }
+        }
+        if (m_start || m_stop || m_animation)
+            effects->addRepaintFull();
+        else
+            m_lastPresentTime = std::chrono::milliseconds::zero();
+    }
+    effects->postPaintScreen();
+}
+
+void FlipSwitchEffect::prePaintWindow(EffectWindow* w, WindowPrePaintData& data, std::chrono::milliseconds presentTime)
+{
+    if (m_active) {
+        if (m_windows.contains(w)) {
+            data.setTransformed();
+            data.setTranslucent();
+            if (!w->isOnCurrentDesktop())
+                w->enablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+            if (w->isMinimized())
+                w->enablePainting(EffectWindow::PAINT_DISABLED_BY_MINIMIZE);
+        } else {
+            if ((m_start || m_stop) && !w->isDesktop() && w->isOnCurrentDesktop())
+                data.setTranslucent();
+            else if (!w->isDesktop())
+                w->disablePainting(EffectWindow::PAINT_DISABLED_BY_DESKTOP);
+        }
+    }
+    effects->prePaintWindow(w, data, presentTime);
+}
+
+void FlipSwitchEffect::paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data)
+{
+    if (m_active) {
+        ItemInfo *info = m_windows.value(w,0);
+        if (info) {
+            info->opacity = data.opacity();
+            info->brightness = data.brightness();
+            info->saturation = data.saturation();
+        }
+
+        // fade out all windows not in window list except the desktops
+        const bool isFader = (m_start || m_stop) && !info && !w->isDesktop();
+        if (isFader)
+            data.multiplyOpacity((1.0 - m_startStopTimeLine.currentValue()));
+
+        // if not a fader or the desktop, skip painting here to prevent flicker
+        if (!(isFader || w->isDesktop()))
+            return;
+    }
+    effects->paintWindow(w, mask, region, data);
+}
+
+//*************************************************************
+// Tabbox handling
+//*************************************************************
+void FlipSwitchEffect::slotTabBoxAdded(int mode)
+{
+    if (effects->activeFullScreenEffect() && effects->activeFullScreenEffect() != this)
+        return;
+    // only for windows mode
+    effects->setShowingDesktop(false);
+    if (((mode == TabBoxWindowsMode && m_tabbox) ||
+            (mode == TabBoxWindowsAlternativeMode && m_tabboxAlternative) ||
+            (mode == TabBoxCurrentAppWindowsMode && m_tabbox) ||
+            (mode == TabBoxCurrentAppWindowsAlternativeMode && m_tabboxAlternative))
+            && (!m_active || (m_active && m_stop))
+            && !effects->currentTabBoxWindowList().isEmpty()) {
+        setActive(true, TabboxMode);
+        if (m_active)
+            effects->refTabBox();
+    }
+}
+
+void FlipSwitchEffect::slotTabBoxClosed()
+{
+    if (m_active) {
+        setActive(false, TabboxMode);
+        effects->unrefTabBox();
+    }
+}
+
+void FlipSwitchEffect::slotTabBoxUpdated()
+{
+    if (m_active && !m_stop) {
+        if (!effects->currentTabBoxWindowList().isEmpty()) {
+            // determine the switch direction
+            if (m_selectedWindow != effects->currentTabBoxWindow()) {
+                if (m_selectedWindow != nullptr) {
+                    int old_index = effects->currentTabBoxWindowList().indexOf(m_selectedWindow);
+                    int new_index = effects->currentTabBoxWindowList().indexOf(effects->currentTabBoxWindow());
+                    SwitchingDirection new_direction;
+                    int distance = new_index - old_index;
+                    if (distance > 0)
+                        new_direction = DirectionForward;
+                    if (distance < 0)
+                        new_direction = DirectionBackward;
+                    if (effects->currentTabBoxWindowList().count() == 2) {
+                        new_direction = DirectionForward;
+                        distance = 1;
+                    }
+                    if (distance != 0) {
+                        distance = abs(distance);
+                        int tempDistance = effects->currentTabBoxWindowList().count() - distance;
+                        if (tempDistance < abs(distance)) {
+                            distance = tempDistance;
+                            if (new_direction == DirectionForward)
+                                new_direction = DirectionBackward;
+                            else
+                                new_direction = DirectionForward;
+                        }
+                        scheduleAnimation(new_direction, distance);
+                    }
+                }
+                m_selectedWindow = effects->currentTabBoxWindow();
+                updateCaption();
+            }
+        }
+        effects->addRepaintFull();
+    }
+}
+
+//*************************************************************
+// Window adding/removing handling
+//*************************************************************
+
+void FlipSwitchEffect::slotWindowAdded(EffectWindow* w)
+{
+    if (m_active && isSelectableWindow(w)) {
+        m_windows[ w ] = new ItemInfo;
+    }
+}
+
+void FlipSwitchEffect::slotWindowClosed(EffectWindow* w)
+{
+    if (m_selectedWindow == w)
+        m_selectedWindow = nullptr;
+    if (m_active) {
+        QHash< const EffectWindow*, ItemInfo* >::iterator it = m_windows.find(w);
+        if (it != m_windows.end()) {
+            delete *it;
+            m_windows.erase(it);
+        }
+    }
+}
+
+//*************************************************************
+// Activation
+//*************************************************************
+
+void FlipSwitchEffect::setActive(bool activate, FlipSwitchMode mode)
+{
+    if (activate) {
+        // effect already active, do some sanity checks
+        if (m_active) {
+            if (m_stop) {
+                if (mode != m_mode) {
+                    // only the same mode may reactivate the effect
+                    return;
+                }
+            } else {
+                // active, but not scheduled for closing -> abort
+                return;
+            }
+        }
+
+        m_mode = mode;
+        Q_FOREACH (EffectWindow * w, effects->stackingOrder()) {
+            if (isSelectableWindow(w) && !m_windows.contains(w))
+                m_windows[ w ] = new ItemInfo;
+        }
+        if (m_windows.isEmpty())
+            return;
+
+        effects->setActiveFullScreenEffect(this);
+        m_active = true;
+        m_start = true;
+        m_startStopTimeLine.setEasingCurve(QEasingCurve::InOutSine);
+        m_activeScreen = effects->activeScreen();
+        m_screenArea = effects->clientArea(ScreenArea, m_activeScreen, effects->currentDesktop());
+
+        if (effects->numScreens() > 1) {
+            // unfortunatelly we have to change the projection matrix in dual screen mode
+            // code is copied from Coverswitch
+            QRect fullRect = effects->clientArea(FullArea, m_activeScreen, effects->currentDesktop());
+            float fovy = 60.0f;
+            float aspect = 1.0f;
+            float zNear = 0.1f;
+            float zFar = 100.0f;
+
+            float ymax = zNear * std::tan(fovy * M_PI / 360.0f);
+            float ymin = -ymax;
+            float xmin =  ymin * aspect;
+            float xmax = ymax * aspect;
+
+            if (m_screenArea.width() != fullRect.width()) {
+                if (m_screenArea.x() == 0) {
+                    // horizontal layout: left screen
+                    xmin *= (float)m_screenArea.width() / (float)fullRect.width();
+                    xmax *= (fullRect.width() - 0.5f * m_screenArea.width()) / (0.5f * fullRect.width());
+                } else {
+                    // horizontal layout: right screen
+                    xmin *= (fullRect.width() - 0.5f * m_screenArea.width()) / (0.5f * fullRect.width());
+                    xmax *= (float)m_screenArea.width() / (float)fullRect.width();
+                }
+            }
+            if (m_screenArea.height() != fullRect.height()) {
+                if (m_screenArea.y() == 0) {
+                    // vertical layout: top screen
+                    ymin *= (fullRect.height() - 0.5f * m_screenArea.height()) / (0.5f * fullRect.height());
+                    ymax *= (float)m_screenArea.height() / (float)fullRect.height();
+                } else {
+                    // vertical layout: bottom screen
+                    ymin *= (float)m_screenArea.height() / (float)fullRect.height();
+                    ymax *= (fullRect.height() - 0.5f * m_screenArea.height()) / (0.5f * fullRect.height());
+                }
+            }
+
+            m_projectionMatrix = QMatrix4x4();
+            m_projectionMatrix.frustum(xmin, xmax, ymin, ymax, zNear, zFar);
+
+            const float scaleFactor = 1.1f / zNear;
+
+            // Create a second matrix that transforms screen coordinates
+            // to world coordinates.
+            QMatrix4x4 matrix;
+            matrix.translate(xmin * scaleFactor, ymax * scaleFactor, -1.1);
+            matrix.scale( (xmax - xmin) * scaleFactor / fullRect.width(),
+                        -(ymax - ymin) * scaleFactor / fullRect.height(),
+                        0.001);
+            // Combine the matrices
+            m_projectionMatrix *= matrix;
+
+            m_modelviewMatrix = QMatrix4x4();
+            m_modelviewMatrix.translate(m_screenArea.x(), m_screenArea.y(), 0.0);
+        }
+
+        if (m_stop) {
+            // effect is still closing from last usage
+            m_stop = false;
+        } else {
+            // things to do only when there is no closing animation
+            m_scheduledDirections.clear();
+        }
+
+        switch(m_mode) {
+        case TabboxMode:
+            m_selectedWindow = effects->currentTabBoxWindow();
+            effects->startMouseInterception(this, Qt::ArrowCursor);
+            break;
+        case CurrentDesktopMode:
+            m_selectedWindow = effects->activeWindow();
+            effects->startMouseInterception(this, Qt::BlankCursor);
+            m_hasKeyboardGrab = effects->grabKeyboard(this);
+            break;
+        case AllDesktopsMode:
+            m_selectedWindow = effects->activeWindow();
+            effects->startMouseInterception(this, Qt::BlankCursor);
+            m_hasKeyboardGrab = effects->grabKeyboard(this);
+            break;
+        }
+
+        // Setup caption frame geometry
+        QRect frameRect = QRect(m_screenArea.width() * 0.25f + m_screenArea.x(),
+                                m_screenArea.height() * 0.1f + m_screenArea.y() - QFontMetrics(m_captionFont).height(),
+                                m_screenArea.width() * 0.5f,
+                                QFontMetrics(m_captionFont).height());
+        if (!m_captionFrame) {
+            m_captionFrame = effects->effectFrame(EffectFrameStyled);
+            m_captionFrame->setFont(m_captionFont);
+            m_captionFrame->enableCrossFade(true);
+        }
+        m_captionFrame->setGeometry(frameRect);
+        m_captionFrame->setIconSize(QSize(frameRect.height(), frameRect.height()));
+        updateCaption();
+        effects->addRepaintFull();
+    } else {
+        // only deactivate if mode is current mode
+        if (mode != m_mode)
+            return;
+        if (m_start && m_scheduledDirections.isEmpty()) {
+            m_start = false;
+        }
+        m_stop = true;
+        if (m_animation) {
+            m_startStopTimeLine.setEasingCurve(QEasingCurve::OutSine);
+            if (m_scheduledDirections.count() == 1) {
+                if (m_currentAnimationEasingCurve == QEasingCurve::InOutSine)
+                    m_currentAnimationEasingCurve = QEasingCurve::InSine;
+                else if (m_currentAnimationEasingCurve == QEasingCurve::OutSine)
+                    m_currentAnimationEasingCurve = QEasingCurve::Linear;
+                m_timeLine.setEasingCurve(m_currentAnimationEasingCurve);
+            }
+        } else
+            m_startStopTimeLine.setEasingCurve(QEasingCurve::InOutSine);
+        effects->stopMouseInterception(this);
+        if (m_hasKeyboardGrab) {
+            effects->ungrabKeyboard();
+            m_hasKeyboardGrab = false;
+        }
+        effects->addRepaintFull();
+    }
+}
+
+void FlipSwitchEffect::toggleActiveAllDesktops()
+{
+    if (m_active) {
+        if (m_stop) {
+            // reactivate if stopping
+            setActive(true, AllDesktopsMode);
+        } else {
+            // deactivate if not stopping
+            setActive(false, AllDesktopsMode);
+        }
+    } else {
+        setActive(true, AllDesktopsMode);
+    }
+}
+
+void FlipSwitchEffect::toggleActiveCurrent()
+{
+    if (m_active) {
+        if (m_stop) {
+            // reactivate if stopping
+            setActive(true, CurrentDesktopMode);
+        } else {
+            // deactivate if not stopping
+            setActive(false, CurrentDesktopMode);
+        }
+    } else {
+        setActive(true, CurrentDesktopMode);
+    }
+}
+
+//*************************************************************
+// Helper function
+//*************************************************************
+
+bool FlipSwitchEffect::isSelectableWindow(EffectWindow* w) const
+{
+    // desktop windows might be included
+    if ((w->isSpecialWindow() && !w->isDesktop()) || w->isUtility())
+        return false;
+    if (w->isDesktop())
+        return (m_mode == TabboxMode && effects->currentTabBoxWindowList().contains(w));
+    if (w->isDeleted())
+        return false;
+    if (!w->acceptsFocus())
+        return false;
+    switch(m_mode) {
+    case TabboxMode:
+        return effects->currentTabBoxWindowList().contains(w);
+    case CurrentDesktopMode:
+        return w->isOnCurrentDesktop();
+    case AllDesktopsMode:
+        //nothing special
+        break;
+    }
+    return true;
+}
+
+void FlipSwitchEffect::scheduleAnimation(const SwitchingDirection& direction, int distance)
+{
+    if (m_start) {
+        // start is still active so change the shape to have a nice transition
+        m_startStopTimeLine.setEasingCurve(QEasingCurve::InSine);
+    }
+    if (!m_animation && !m_start) {
+        m_animation = true;
+        m_scheduledDirections.enqueue(direction);
+        distance--;
+        // reset shape just to make sure
+        m_currentAnimationEasingCurve = QEasingCurve::InOutSine;
+        m_timeLine.setEasingCurve(m_currentAnimationEasingCurve);
+    }
+    for (int i = 0; i < distance; i++) {
+        if (m_scheduledDirections.count() > 1 && m_scheduledDirections.last() != direction)
+            m_scheduledDirections.pop_back();
+        else
+            m_scheduledDirections.enqueue(direction);
+        if (m_scheduledDirections.count() == m_windows.count() + 1) {
+            SwitchingDirection temp = m_scheduledDirections.dequeue();
+            m_scheduledDirections.clear();
+            m_scheduledDirections.enqueue(temp);
+        }
+    }
+    if (m_scheduledDirections.count() > 1) {
+        QEasingCurve curve;
+        switch (m_currentAnimationEasingCurve.type()) {
+        case QEasingCurve::InOutSine:
+            curve = QEasingCurve::InSine;
+            break;
+        case QEasingCurve::OutSine:
+            curve = QEasingCurve::Linear;
+            break;
+        default:
+            curve = m_currentAnimationEasingCurve;
+        }
+        if (m_currentAnimationEasingCurve != curve) {
+            m_currentAnimationEasingCurve = curve;
+            m_timeLine.setEasingCurve(curve);
+        }
+    }
+}
+
+void FlipSwitchEffect::adjustWindowMultiScreen(const KWin::EffectWindow* w, WindowPaintData& data)
+{
+    if (effects->numScreens() <= 1)
+        return;
+    QRect clientRect = effects->clientArea(FullScreenArea, w->screen(), effects->currentDesktop());
+    QRect rect = effects->clientArea(ScreenArea, m_activeScreen, effects->currentDesktop());
+    QRect fullRect = effects->clientArea(FullArea, m_activeScreen, effects->currentDesktop());
+    if (w->screen() == m_activeScreen) {
+        if (clientRect.width() != fullRect.width() && clientRect.x() != fullRect.x()) {
+            data.translate(- clientRect.x());
+        }
+        if (clientRect.height() != fullRect.height() && clientRect.y() != fullRect.y()) {
+            data.translate(0.0, - clientRect.y());
+        }
+    } else {
+        if (clientRect.width() != fullRect.width() && clientRect.x() < rect.x()) {
+            data.translate(- (m_screenArea.x() - clientRect.x()));
+        }
+        if (clientRect.height() != fullRect.height() && clientRect.y() < m_screenArea.y()) {
+            data.translate(0.0, - (m_screenArea.y() - clientRect.y()));
+        }
+    }
+}
+
+void FlipSwitchEffect::selectNextOrPreviousWindow(bool forward)
+{
+    if (!m_active || !m_selectedWindow) {
+        return;
+    }
+    const int index = effects->currentTabBoxWindowList().indexOf(m_selectedWindow);
+    int newIndex = index;
+    if (forward) {
+        ++newIndex;
+    } else {
+        --newIndex;
+    }
+    if (newIndex == effects->currentTabBoxWindowList().size()) {
+        newIndex = 0;
+    } else if (newIndex < 0) {
+        newIndex = effects->currentTabBoxWindowList().size() -1;
+    }
+    if (index == newIndex) {
+        return;
+    }
+    effects->setTabBoxWindow(effects->currentTabBoxWindowList().at(newIndex));
+}
+
+
+//*************************************************************
+// Keyboard handling
+//*************************************************************
+void FlipSwitchEffect::globalShortcutChanged(QAction *action, const QKeySequence &shortcut)
+{
+    if (action->objectName() == QStringLiteral("FlipSwitchAll")) {
+        m_shortcutAll.clear();
+        m_shortcutAll.append(shortcut);
+    } else if (action->objectName() == QStringLiteral("FlipSwitchCurrent")) {
+        m_shortcutCurrent.clear();
+        m_shortcutCurrent.append(shortcut);
+    }
+}
+
+void FlipSwitchEffect::grabbedKeyboardEvent(QKeyEvent* e)
+{
+    if (e->type() == QEvent::KeyPress) {
+        // check for global shortcuts
+        // HACK: keyboard grab disables the global shortcuts so we have to check for global shortcut (bug 156155)
+        if (m_mode == CurrentDesktopMode && m_shortcutCurrent.contains(e->key() + e->modifiers())) {
+            toggleActiveCurrent();
+            return;
+        }
+        if (m_mode == AllDesktopsMode && m_shortcutAll.contains(e->key() + e->modifiers())) {
+            toggleActiveAllDesktops();
+            return;
+        }
+
+        switch(e->key()) {
+        case Qt::Key_Escape:
+            setActive(false, m_mode);
+            return;
+        case Qt::Key_Tab: {
+            // find next window
+            if (m_windows.isEmpty())
+                return; // sanity check
+            bool found = false;
+            for (int i = effects->stackingOrder().indexOf(m_selectedWindow) - 1; i >= 0; i--) {
+                if (isSelectableWindow(effects->stackingOrder().at(i))) {
+                    m_selectedWindow = effects->stackingOrder().at(i);
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                for (int i = effects->stackingOrder().count() - 1; i > effects->stackingOrder().indexOf(m_selectedWindow); i--) {
+                    if (isSelectableWindow(effects->stackingOrder().at(i))) {
+                        m_selectedWindow = effects->stackingOrder().at(i);
+                        found = true;
+                        break;
+                    }
+                }
+            }
+            if (found) {
+                updateCaption();
+                scheduleAnimation(DirectionForward);
+            }
+            break;
+        }
+        case Qt::Key_Backtab: {
+            // find previous window
+            if (m_windows.isEmpty())
+                return; // sanity check
+            bool found = false;
+            for (int i = effects->stackingOrder().indexOf(m_selectedWindow) + 1; i < effects->stackingOrder().count(); i++) {
+                if (isSelectableWindow(effects->stackingOrder().at(i))) {
+                    m_selectedWindow = effects->stackingOrder().at(i);
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                for (int i = 0; i < effects->stackingOrder().indexOf(m_selectedWindow); i++) {
+                    if (isSelectableWindow(effects->stackingOrder().at(i))) {
+                        m_selectedWindow = effects->stackingOrder().at(i);
+                        found = true;
+                        break;
+                    }
+                }
+            }
+            if (found) {
+                updateCaption();
+                scheduleAnimation(DirectionBackward);
+            }
+            break;
+        }
+        case Qt::Key_Return:
+        case Qt::Key_Enter:
+        case Qt::Key_Space:
+            if (m_selectedWindow)
+                effects->activateWindow(m_selectedWindow);
+            setActive(false, m_mode);
+            break;
+        default:
+            break;
+        }
+        effects->addRepaintFull();
+    }
+}
+
+void FlipSwitchEffect::slotTabBoxKeyEvent(QKeyEvent *event)
+{
+    if (event->type() == QEvent::KeyPress) {
+        switch (event->key()) {
+        case Qt::Key_Up:
+        case Qt::Key_Left:
+            selectPreviousWindow();
+            break;
+        case Qt::Key_Down:
+        case Qt::Key_Right:
+            selectNextWindow();
+            break;
+        default:
+            // nothing
+            break;
+        }
+    }
+}
+
+bool FlipSwitchEffect::isActive() const
+{
+    return m_active && !effects->isScreenLocked();
+}
+
+void FlipSwitchEffect::updateCaption()
+{
+    if (!m_selectedWindow) {
+        return;
+    }
+    if (m_selectedWindow->isDesktop()) {
+        m_captionFrame->setText(i18nc("Special entry in alt+tab list for minimizing all windows",
+                     "Show Desktop"));
+        static QPixmap pix = QIcon::fromTheme(QStringLiteral("user-desktop")).pixmap(m_captionFrame->iconSize());
+        m_captionFrame->setIcon(pix);
+    } else {
+        m_captionFrame->setText(m_selectedWindow->caption());
+        m_captionFrame->setIcon(m_selectedWindow->icon());
+    }
+}
+
+//*************************************************************
+// Mouse handling
+//*************************************************************
+
+void FlipSwitchEffect::windowInputMouseEvent(QEvent* e)
+{
+    if (e->type() != QEvent::MouseButtonPress)
+        return;
+    // we don't want click events during animations
+    if (m_animation)
+        return;
+    QMouseEvent* event = static_cast< QMouseEvent* >(e);
+
+    switch (event->button()) {
+    case Qt::XButton1: // wheel up
+        selectPreviousWindow();
+        break;
+    case Qt::XButton2: // wheel down
+        selectNextWindow();
+        break;
+    case Qt::LeftButton:
+    case Qt::RightButton:
+    case Qt::MiddleButton:
+    default:
+        // TODO: Change window on mouse button click
+        break;
+    }
+}
+
+//*************************************************************
+// Item Info
+//*************************************************************
+FlipSwitchEffect::ItemInfo::ItemInfo()
+    : deleted(false)
+    , opacity(0.0)
+    , brightness(0.0)
+    , saturation(0.0)
+{
+}
+
+FlipSwitchEffect::ItemInfo::~ItemInfo()
+{
+}
+
+} // namespace
+
diff --git a/src/effects/flipswitch/flipswitch.h b/src/effects/flipswitch/flipswitch.h
new file mode 100644
index 000000000..cef9fb166
--- /dev/null
+++ b/src/effects/flipswitch/flipswitch.h
@@ -0,0 +1,155 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008, 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_FLIPSWITCH_H
+#define KWIN_FLIPSWITCH_H
+
+#include <kwineffects.h>
+#include <QMatrix4x4>
+#include <QQueue>
+#include <QTimeLine>
+#include <QFont>
+
+namespace KWin
+{
+
+class FlipSwitchEffect
+    : public Effect
+{
+    Q_OBJECT
+    Q_PROPERTY(bool tabBox READ isTabBox)
+    Q_PROPERTY(bool tabBoxAlternative READ isTabBoxAlternative)
+    Q_PROPERTY(int duration READ duration)
+    Q_PROPERTY(int angle READ angle)
+    Q_PROPERTY(qreal xPosition READ xPosition)
+    Q_PROPERTY(qreal yPosition READ yPosition)
+    Q_PROPERTY(bool windowTitle READ isWindowTitle)
+public:
+    FlipSwitchEffect();
+    ~FlipSwitchEffect() override;
+
+    void reconfigure(ReconfigureFlags) override;
+    void prePaintScreen(ScreenPrePaintData& data, std::chrono::milliseconds presentTime) override;
+    void paintScreen(int mask, const QRegion &region, ScreenPaintData& data) override;
+    void postPaintScreen() override;
+    void prePaintWindow(EffectWindow *w, WindowPrePaintData &data, std::chrono::milliseconds presentTime) override;
+    void paintWindow(EffectWindow* w, int mask, QRegion region, WindowPaintData& data) override;
+    void grabbedKeyboardEvent(QKeyEvent* e) override;
+    void windowInputMouseEvent(QEvent* e) override;
+    bool isActive() const override;
+
+    int requestedEffectChainPosition() const override {
+        return 50;
+    }
+
+    static bool supported();
+
+    // for properties
+    bool isTabBox() const {
+        return m_tabbox;
+    }
+    bool isTabBoxAlternative() const {
+        return m_tabboxAlternative;
+    }
+    int duration() const {
+        return m_timeLine.duration();
+    }
+    int angle() const {
+        return m_angle;
+    }
+    qreal xPosition() const {
+        return m_xPosition;
+    }
+    qreal yPosition() const {
+        return m_yPosition;
+    }
+    bool isWindowTitle() const {
+        return m_windowTitle;
+    }
+private Q_SLOTS:
+    void toggleActiveCurrent();
+    void toggleActiveAllDesktops();
+    void globalShortcutChanged(QAction *action, const QKeySequence &shortcut);
+    void slotWindowAdded(KWin::EffectWindow* w);
+    void slotWindowClosed(KWin::EffectWindow *w);
+    void slotTabBoxAdded(int mode);
+    void slotTabBoxClosed();
+    void slotTabBoxUpdated();
+    void slotTabBoxKeyEvent(QKeyEvent* event);
+
+private:
+    class ItemInfo;
+    enum SwitchingDirection {
+        DirectionForward,
+        DirectionBackward
+    };
+    enum FlipSwitchMode {
+        TabboxMode,
+        CurrentDesktopMode,
+        AllDesktopsMode
+    };
+    void setActive(bool activate, FlipSwitchMode mode);
+    bool isSelectableWindow(EffectWindow *w) const;
+    void scheduleAnimation(const SwitchingDirection& direction, int distance = 1);
+    void adjustWindowMultiScreen(const EffectWindow *w, WindowPaintData& data);
+    void selectNextOrPreviousWindow(bool forward);
+    inline void selectNextWindow() { selectNextOrPreviousWindow(true); }
+    inline void selectPreviousWindow() { selectNextOrPreviousWindow(false); }
+    /**
+     * Updates the caption of the caption frame.
+     * Taking care of rewording the desktop client.
+     * As well sets the icon for the caption frame.
+     */
+    void updateCaption();
+    QQueue< SwitchingDirection> m_scheduledDirections;
+    EffectWindow* m_selectedWindow;
+    QTimeLine m_timeLine;
+    QTimeLine m_startStopTimeLine;
+    QEasingCurve m_currentAnimationEasingCurve;
+    std::chrono::milliseconds m_lastPresentTime;
+    QRect m_screenArea;
+    int m_activeScreen;
+    bool m_active;
+    bool m_start;
+    bool m_stop;
+    bool m_animation;
+    bool m_hasKeyboardGrab;
+    FlipSwitchMode m_mode;
+    EffectFrame* m_captionFrame;
+    QFont m_captionFont;
+    EffectWindowList m_flipOrderedWindows;
+    QHash< const EffectWindow*, ItemInfo* > m_windows;
+    QMatrix4x4 m_projectionMatrix;
+    QMatrix4x4 m_modelviewMatrix;
+    // options
+    bool m_tabbox;
+    bool m_tabboxAlternative;
+    float m_angle;
+    float m_xPosition;
+    float m_yPosition;
+    bool m_windowTitle;
+    // Shortcuts
+    QList<QKeySequence> m_shortcutCurrent;
+    QList<QKeySequence> m_shortcutAll;
+};
+
+class FlipSwitchEffect::ItemInfo
+{
+public:
+    ItemInfo();
+    ~ItemInfo();
+    bool deleted;
+    double opacity;
+    double brightness;
+    double saturation;
+};
+
+} // namespace
+
+#endif
diff --git a/src/effects/flipswitch/flipswitch.kcfg b/src/effects/flipswitch/flipswitch.kcfg
new file mode 100644
index 000000000..37c2e7599
--- /dev/null
+++ b/src/effects/flipswitch/flipswitch.kcfg
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<kcfg xmlns="http://www.kde.org/standards/kcfg/1.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://www.kde.org/standards/kcfg/1.0
+    http://www.kde.org/standards/kcfg/1.0/kcfg.xsd" >
+    <kcfgfile arg="true"/>
+    <group name="Effect-FlipSwitch">
+        <entry name="TabBox" type="Bool">
+            <default>false</default>
+        </entry>
+        <entry name="TabBoxAlternative" type="Bool">
+            <default>false</default>
+        </entry>
+        <entry name="Duration" type="Int">
+            <default>0</default>
+        </entry>
+        <entry name="Angle" type="Int">
+            <default>30</default>
+        </entry>
+        <entry name="XPosition" type="Int">
+            <default>33</default>
+        </entry>
+        <entry name="YPosition" type="Int">
+            <default>100</default>
+        </entry>
+        <entry name="WindowTitle" type="Bool">
+            <default>true</default>
+        </entry>
+    </group>
+</kcfg>
diff --git a/src/effects/flipswitch/flipswitch_config.cpp b/src/effects/flipswitch/flipswitch_config.cpp
new file mode 100644
index 000000000..22a010cdd
--- /dev/null
+++ b/src/effects/flipswitch/flipswitch_config.cpp
@@ -0,0 +1,86 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008, 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+#include "flipswitch_config.h"
+// KConfigSkeleton
+#include "flipswitchconfig.h"
+#include <config-kwin.h>
+#include <kwineffects_interface.h>
+
+#include <QAction>
+
+#include <kconfiggroup.h>
+#include <KActionCollection>
+#include <KAboutData>
+#include <KGlobalAccel>
+#include <KLocalizedString>
+#include <KPluginFactory>
+
+#include <QVBoxLayout>
+
+K_PLUGIN_FACTORY_WITH_JSON(FlipSwitchEffectConfigFactory,
+                           "flipswitch_config.json",
+                           registerPlugin<KWin::FlipSwitchEffectConfig>();)
+
+namespace KWin
+{
+
+FlipSwitchEffectConfigForm::FlipSwitchEffectConfigForm(QWidget* parent) : QWidget(parent)
+{
+    setupUi(this);
+}
+
+FlipSwitchEffectConfig::FlipSwitchEffectConfig(QWidget* parent, const QVariantList& args) :
+    KCModule(parent, args)
+{
+    m_ui = new FlipSwitchEffectConfigForm(this);
+
+    QVBoxLayout* layout = new QVBoxLayout(this);
+
+    layout->addWidget(m_ui);
+
+    // Shortcut config. The shortcut belongs to the component "kwin"!
+    m_actionCollection = new KActionCollection(this, QStringLiteral("kwin"));
+    QAction* a = m_actionCollection->addAction(QStringLiteral("FlipSwitchCurrent"));
+    a->setText(i18n("Toggle Flip Switch (Current desktop)"));
+    KGlobalAccel::self()->setShortcut(a, QList<QKeySequence>());
+    QAction* b = m_actionCollection->addAction(QStringLiteral("FlipSwitchAll"));
+    b->setText(i18n("Toggle Flip Switch (All desktops)"));
+    KGlobalAccel::self()->setShortcut(b, QList<QKeySequence>());
+
+    m_actionCollection->setComponentDisplayName(i18n("KWin"));
+    m_actionCollection->setConfigGroup(QStringLiteral("FlipSwitch"));
+    m_actionCollection->setConfigGlobal(true);
+
+    m_ui->shortcutEditor->addCollection(m_actionCollection);
+
+    FlipSwitchConfig::instance(KWIN_CONFIG);
+    addConfig(FlipSwitchConfig::self(), m_ui);
+
+    load();
+}
+
+FlipSwitchEffectConfig::~FlipSwitchEffectConfig()
+{
+}
+
+void FlipSwitchEffectConfig::save()
+{
+    KCModule::save();
+    m_ui->shortcutEditor->save();
+
+    OrgKdeKwinEffectsInterface interface(QStringLiteral("org.kde.KWin"),
+                                         QStringLiteral("/Effects"),
+                                         QDBusConnection::sessionBus());
+    interface.reconfigureEffect(QStringLiteral("flipswitch"));
+}
+
+
+} // namespace
+
+#include "flipswitch_config.moc"
diff --git a/src/effects/flipswitch/flipswitch_config.desktop b/src/effects/flipswitch/flipswitch_config.desktop
new file mode 100644
index 000000000..fcf3ef284
--- /dev/null
+++ b/src/effects/flipswitch/flipswitch_config.desktop
@@ -0,0 +1,77 @@
+[Desktop Entry]
+Type=Service
+X-KDE-ServiceTypes=KCModule
+
+X-KDE-Library=kwin_flipswitch_config
+X-KDE-ParentComponents=flipswitch
+
+Name=Flip Switch
+Name[af]=Wissel skakelaar
+Name[ar]=تبديل بالتقليب
+Name[az]=Səhifələmə
+Name[bs]=Preklopno prebacivanje
+Name[ca]=Canvi en roda
+Name[ca@valencia]=Canvi en roda
+Name[cs]=Kartotéka
+Name[da]=Vippeskifter
+Name[de]=3D-Fensterstapel
+Name[el]=Εναλλαγή στοίβας
+Name[en_GB]=Flip Switch
+Name[eo]=Turna ŝanĝilo
+Name[es]=Selección de ventana en modo cascada
+Name[et]=Aknalehitseja
+Name[eu]=Biratze aldaketa
+Name[fi]=Kääntövaihtaja
+Name[fr]=Empilement en perspective
+Name[fy]=Flip wiksel
+Name[ga]=Flip Switch
+Name[gl]=Cambio en fila
+Name[gu]=ફ્લિપ સ્વિચ
+Name[he]=מחליף ערמה
+Name[hi]=स्विच बदलें
+Name[hne]=फ्लिप स्विच
+Name[hr]=Naslagani prozori – promjena
+Name[hu]=Billenős váltódoboz
+Name[ia]=Commutator de  colpetto (Flip)
+Name[id]=Beralih Jungkir
+Name[is]=Flettirofi
+Name[it]=Scambiafinestre a pila
+Name[ja]=フリップスイッチ
+Name[kk]=Ақтарып ауыстырғыш
+Name[km]=ប្ដូរ​ការ​ត្រឡប់​
+Name[kn]=ಬದಲಾವಣೆ ಗುಂಡಿ (ಫ್ಲಿಪ್ ಸ್ವಿಚ್)
+Name[ko]=플립 전환기
+Name[lt]=Kartotekos pavidalo langų perjungiklis
+Name[lv]=Flip pārslēdzējs
+Name[mai]=स्विच पलटू
+Name[ml]=ഫ്ലിപ് സ്വിച്ച്
+Name[mr]=पलटी करून बदल
+Name[nb]=Bla-bytter
+Name[nds]=Dreihwesseln
+Name[nl]=Flip Switch
+Name[nn]=Stabelvekslar
+Name[pa]=ਫਲਿੱਪ ਸਵਿੱਚ
+Name[pl]=Przełączanie przebierane
+Name[pt]=Mudança em Pilha
+Name[pt_BR]=Mudança em pilha
+Name[ro]=Schimbare cu întoarcere
+Name[ru]=Перелистывание
+Name[si]=උඩට ගැනීම් මාරුව
+Name[sk]=Prepínať v kartotéke
+Name[sl]=Preklapljanje - sklad
+Name[sr]=Преклопно пребацивање
+Name[sr@ijekavian]=Преклопно пребацивање
+Name[sr@ijekavianlatin]=Preklopno prebacivanje
+Name[sr@latin]=Preklopno prebacivanje
+Name[sv]=Blädderbyte
+Name[ta]=Flip Switch
+Name[te]=ఫ్లిప్ స్విచ్
+Name[th]=สลับหน้าต่างพลิกซ้อนเป็นชั้น
+Name[tr]=Dönen Seçici
+Name[ug]=ئايلاندۇرۇپ ئالماشتۇر
+Name[uk]=Тасування карток
+Name[vi]=Chuyển đổi lật
+Name[wa]=Discandjeu d' finiesses
+Name[x-test]=xxFlip Switchxx
+Name[zh_CN]=3D 窗口切换
+Name[zh_TW]=翻轉切換
diff --git a/src/effects/flipswitch/flipswitch_config.h b/src/effects/flipswitch/flipswitch_config.h
new file mode 100644
index 000000000..a81675bb3
--- /dev/null
+++ b/src/effects/flipswitch/flipswitch_config.h
@@ -0,0 +1,46 @@
+/*
+    KWin - the KDE window manager
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2008, 2009 Martin Gräßlin <mgraesslin@kde.org>
+
+    SPDX-License-Identifier: GPL-2.0-or-later
+*/
+
+#ifndef KWIN_FLIPSWITCH_CONFIG_H
+#define KWIN_FLIPSWITCH_CONFIG_H
+
+#include <kcmodule.h>
+
+#include "ui_flipswitch_config.h"
+
+class KActionCollection;
+
+namespace KWin
+{
+
+class FlipSwitchEffectConfigForm : public QWidget, public Ui::FlipSwitchEffectConfigForm
+{
+    Q_OBJECT
+public:
+    explicit FlipSwitchEffectConfigForm(QWidget* parent);
+};
+
+class FlipSwitchEffectConfig : public KCModule
+{
+    Q_OBJECT
+public:
+    explicit FlipSwitchEffectConfig(QWidget* parent = nullptr, const QVariantList& args = QVariantList());
+    ~FlipSwitchEffectConfig() override;
+
+public Q_SLOTS:
+    void save() override;
+
+private:
+    FlipSwitchEffectConfigForm* m_ui;
+    KActionCollection* m_actionCollection;
+};
+
+} // namespace
+
+#endif
diff --git a/src/effects/flipswitch/flipswitch_config.ui b/src/effects/flipswitch/flipswitch_config.ui
new file mode 100644
index 000000000..02a925f6b
--- /dev/null
+++ b/src/effects/flipswitch/flipswitch_config.ui
@@ -0,0 +1,238 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>KWin::FlipSwitchEffectConfigForm</class>
+ <widget class="QWidget" name="KWin::FlipSwitchEffectConfigForm">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>400</width>
+    <height>316</height>
+   </rect>
+  </property>
+  <layout class="QVBoxLayout">
+   <item>
+    <widget class="QGroupBox" name="groupBox">
+     <property name="title">
+      <string>Appearance</string>
+     </property>
+     <layout class="QFormLayout" name="formLayout">
+      <item row="0" column="0">
+       <widget class="QLabel" name="label_3">
+        <property name="text">
+         <string>Flip animation duration:</string>
+        </property>
+        <property name="alignment">
+         <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+        </property>
+        <property name="buddy">
+         <cstring>kcfg_Duration</cstring>
+        </property>
+       </widget>
+      </item>
+      <item row="0" column="1">
+       <widget class="QSpinBox" name="kcfg_Duration">
+        <property name="sizePolicy">
+         <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+          <horstretch>0</horstretch>
+          <verstretch>0</verstretch>
+         </sizepolicy>
+        </property>
+        <property name="specialValueText">
+         <string comment="Duration of flip animation">Default</string>
+        </property>
+        <property name="maximum">
+         <number>5000</number>
+        </property>
+        <property name="singleStep">
+         <number>10</number>
+        </property>
+       </widget>
+      </item>
+      <item row="1" column="0">
+       <widget class="QLabel" name="label">
+        <property name="text">
+         <string>Angle:</string>
+        </property>
+        <property name="buddy">
+         <cstring>kcfg_Angle</cstring>
+        </property>
+       </widget>
+      </item>
+      <item row="1" column="1">
+       <widget class="QSpinBox" name="kcfg_Angle">
+        <property name="sizePolicy">
+         <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
+          <horstretch>0</horstretch>
+          <verstretch>0</verstretch>
+         </sizepolicy>
+        </property>
+        <property name="suffix">
+         <string> °</string>
+        </property>
+        <property name="maximum">
+         <number>360</number>
+        </property>
+       </widget>
+      </item>
+      <item row="3" column="0">
+       <widget class="QLabel" name="label_2">
+        <property name="text">
+         <string>Horizontal position of front:</string>
+        </property>
+        <property name="buddy">
+         <cstring>kcfg_XPosition</cstring>
+        </property>
+       </widget>
+      </item>
+      <item row="3" column="1">
+       <layout class="QVBoxLayout" name="verticalLayout_2">
+        <item>
+         <widget class="QSlider" name="kcfg_XPosition">
+          <property name="maximum">
+           <number>100</number>
+          </property>
+          <property name="orientation">
+           <enum>Qt::Horizontal</enum>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <layout class="QHBoxLayout" name="horizontalLayout">
+          <item>
+           <widget class="QLabel" name="label_4">
+            <property name="text">
+             <string>Left</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <spacer name="horizontalSpacer">
+            <property name="orientation">
+             <enum>Qt::Horizontal</enum>
+            </property>
+            <property name="sizeHint" stdset="0">
+             <size>
+              <width>40</width>
+              <height>20</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+          <item>
+           <widget class="QLabel" name="label_5">
+            <property name="text">
+             <string>Right</string>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </item>
+       </layout>
+      </item>
+      <item row="7" column="0">
+       <widget class="QLabel" name="label_6">
+        <property name="text">
+         <string>Vertical position of front:</string>
+        </property>
+        <property name="buddy">
+         <cstring>kcfg_YPosition</cstring>
+        </property>
+       </widget>
+      </item>
+      <item row="7" column="1">
+       <layout class="QHBoxLayout" name="horizontalLayout_2">
+        <item>
+         <widget class="QSlider" name="kcfg_YPosition">
+          <property name="maximum">
+           <number>100</number>
+          </property>
+          <property name="orientation">
+           <enum>Qt::Vertical</enum>
+          </property>
+         </widget>
+        </item>
+        <item>
+         <layout class="QVBoxLayout" name="verticalLayout_3">
+          <item>
+           <widget class="QLabel" name="label_7">
+            <property name="text">
+             <string>Top</string>
+            </property>
+           </widget>
+          </item>
+          <item>
+           <spacer name="verticalSpacer">
+            <property name="orientation">
+             <enum>Qt::Vertical</enum>
+            </property>
+            <property name="sizeHint" stdset="0">
+             <size>
+              <width>20</width>
+              <height>40</height>
+             </size>
+            </property>
+           </spacer>
+          </item>
+          <item>
+           <widget class="QLabel" name="label_8">
+            <property name="text">
+             <string>Bottom</string>
+            </property>
+           </widget>
+          </item>
+         </layout>
+        </item>
+       </layout>
+      </item>
+      <item row="2" column="0" colspan="2">
+       <widget class="QCheckBox" name="kcfg_WindowTitle">
+        <property name="text">
+         <string>Display window &amp;titles</string>
+        </property>
+        <property name="shortcut">
+         <string/>
+        </property>
+       </widget>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <widget class="QGroupBox" name="groupBox_2">
+     <property name="title">
+      <string>Activation</string>
+     </property>
+     <layout class="QGridLayout" name="gridLayout_2">
+      <item row="0" column="0" colspan="2">
+       <widget class="KShortcutsEditor" name="shortcutEditor" native="true">
+        <property name="sizePolicy">
+         <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
+          <horstretch>0</horstretch>
+          <verstretch>0</verstretch>
+         </sizepolicy>
+        </property>
+        <property name="actionTypes">
+            <enum>KShortcutsEditor::GlobalAction</enum>
+        </property>
+       </widget>
+      </item>
+     </layout>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <customwidgets>
+  <customwidget>
+   <class>KShortcutsEditor</class>
+   <extends>QWidget</extends>
+   <header location="global">KShortcutsEditor</header>
+   <container>1</container>
+  </customwidget>
+ </customwidgets>
+ <tabstops>
+  <tabstop>kcfg_Duration</tabstop>
+ </tabstops>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/src/effects/flipswitch/flipswitchconfig.kcfgc b/src/effects/flipswitch/flipswitchconfig.kcfgc
new file mode 100644
index 000000000..15fb71053
--- /dev/null
+++ b/src/effects/flipswitch/flipswitchconfig.kcfgc
@@ -0,0 +1,5 @@
+File=flipswitch.kcfg
+ClassName=FlipSwitchConfig
+NameSpace=KWin
+Singleton=true
+Mutators=true
diff --git a/src/effects/shaders.qrc b/src/effects/shaders.qrc
index b93081caa..a196dd895 100644
--- a/src/effects/shaders.qrc
+++ b/src/effects/shaders.qrc
@@ -1,10 +1,20 @@
 <!DOCTYPE RCC><RCC version="1.0">
 <qresource prefix="/effect-shaders-1.10">
+  <file alias="coverswitch-reflection.glsl">coverswitch/shaders/1.10/coverswitch-reflection.glsl</file>
+  <file alias="cube-cap.glsl">cube/data/1.10/cube-cap.glsl</file>
+  <file alias="cube-reflection.glsl">cube/data/1.10/cube-reflection.glsl</file>
+  <file alias="cylinder.vert">cube/data/1.10/cylinder.vert</file>
+  <file alias="sphere.vert">cube/data/1.10/sphere.vert</file>
   <file alias="invert.frag">invert/data/1.10/invert.frag</file>
   <file alias="lookingglass.frag">lookingglass/data/1.10/lookingglass.frag</file>
   <file alias="blinking-startup-fragment.glsl">startupfeedback/data/1.10/blinking-startup-fragment.glsl</file>
 </qresource>
 <qresource prefix="/effect-shaders-1.40">
+  <file alias="coverswitch-reflection.glsl">coverswitch/shaders/1.40/coverswitch-reflection.glsl</file>
+  <file alias="cube-cap.glsl">cube/data/1.40/cube-cap.glsl</file>
+  <file alias="cube-reflection.glsl">cube/data/1.40/cube-reflection.glsl</file>
+  <file alias="cylinder.vert">cube/data/1.40/cylinder.vert</file>
+  <file alias="sphere.vert">cube/data/1.40/sphere.vert</file>
   <file alias="invert.frag">invert/data/1.40/invert.frag</file>
   <file alias="lookingglass.frag">lookingglass/data/1.40/lookingglass.frag</file>
   <file alias="blinking-startup-fragment.glsl">startupfeedback/data/1.40/blinking-startup-fragment.glsl</file>
diff --git a/src/kcmkwin/kwinscreenedges/kwinscreenedgesettings.kcfg b/src/kcmkwin/kwinscreenedges/kwinscreenedgesettings.kcfg
index c8a2a2c25..bbf567704 100644
--- a/src/kcmkwin/kwinscreenedges/kwinscreenedgesettings.kcfg
+++ b/src/kcmkwin/kwinscreenedges/kwinscreenedgesettings.kcfg
@@ -66,6 +66,17 @@
             <default>ElectricNone</default>
         </entry>
     </group>
+    <group name="Effect-Cube">
+        <entry name="BorderActivateCube" key="BorderActivate" type="IntList">
+            <default>ElectricNone</default>
+        </entry>
+        <entry key="BorderActivateCylinder" type="IntList">
+            <default>ElectricNone</default>
+        </entry>
+        <entry key="BorderActivateSphere" type="IntList">
+            <default>ElectricNone</default>
+        </entry>
+    </group>
     <group name="Effect-Overview">
         <entry name="BorderActivateOverview" key="BorderActivate" type="IntList">
             <default>ElectricNone</default>
diff --git a/src/kcmkwin/kwinscreenedges/kwintouchscreensettings.kcfg b/src/kcmkwin/kwinscreenedges/kwintouchscreensettings.kcfg
index 41d550f94..3c3f16b56 100644
--- a/src/kcmkwin/kwinscreenedges/kwintouchscreensettings.kcfg
+++ b/src/kcmkwin/kwinscreenedges/kwintouchscreensettings.kcfg
@@ -34,6 +34,17 @@
             <default>ElectricNone</default>
         </entry>
     </group>
+    <group name="Effect-Cube">
+        <entry name="TouchBorderActivateCube" key="TouchBorderActivate" type="IntList">
+            <default>ElectricNone</default>
+        </entry>
+        <entry key="TouchBorderActivateCylinder" type="IntList">
+            <default>ElectricNone</default>
+        </entry>
+        <entry key="TouchBorderActivateSphere" type="IntList">
+            <default>ElectricNone</default>
+        </entry>
+    </group>
     <group name="Effect-Overview">
         <entry name="TouchBorderActivateOverview" key="TouchBorderActivate" type="IntList">
             <default>ElectricNone</default>
diff --git a/src/kcmkwin/kwinscreenedges/main.cpp b/src/kcmkwin/kwinscreenedges/main.cpp
index d019eb1bd..e911e3cc9 100644
--- a/src/kcmkwin/kwinscreenedges/main.cpp
+++ b/src/kcmkwin/kwinscreenedges/main.cpp
@@ -93,6 +93,7 @@ void KWinScreenEdgesConfig::save()
     interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::Overview));
     interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::PresentWindows));
     interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::DesktopGrid));
+    interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::Cube));
 
     KCModule::save();
 }
@@ -135,6 +136,10 @@ void KWinScreenEdgesConfig::monitorInit()
     m_form->monitorAddItem(i18n("%1 - Current Desktop", presentWindowsName));
     m_form->monitorAddItem(i18n("%1 - Current Application", presentWindowsName));
     m_form->monitorAddItem(BuiltInEffects::effectData(BuiltInEffect::DesktopGrid).displayName);
+    const QString cubeName = BuiltInEffects::effectData(BuiltInEffect::Cube).displayName;
+    m_form->monitorAddItem(i18n("%1 - Cube", cubeName));
+    m_form->monitorAddItem(i18n("%1 - Cylinder", cubeName));
+    m_form->monitorAddItem(i18n("%1 - Sphere", cubeName));
 
     m_form->monitorAddItem(i18n("Toggle window switching"));
     m_form->monitorAddItem(i18n("Toggle alternative window switching"));
@@ -187,6 +192,11 @@ void KWinScreenEdgesConfig::monitorLoadSettings()
     // Desktop Grid
     m_form->monitorChangeEdge(m_data->settings()->borderActivateDesktopGrid(), DesktopGrid);
 
+    // Desktop Cube
+    m_form->monitorChangeEdge(m_data->settings()->borderActivateCube(), Cube);
+    m_form->monitorChangeEdge(m_data->settings()->borderActivateCylinder(), Cylinder);
+    m_form->monitorChangeEdge(m_data->settings()->borderActivateSphere(), Sphere);
+
     // TabBox
     m_form->monitorChangeEdge(m_data->settings()->borderActivateTabBox(), TabBox);
     // Alternative TabBox
@@ -228,6 +238,11 @@ void KWinScreenEdgesConfig::monitorLoadDefaultSettings()
     // Desktop Grid
     m_form->monitorChangeDefaultEdge(m_data->settings()->defaultBorderActivateDesktopGridValue(), DesktopGrid);
 
+    // Desktop Cube
+    m_form->monitorChangeDefaultEdge(m_data->settings()->defaultBorderActivateCubeValue(), Cube);
+    m_form->monitorChangeDefaultEdge(m_data->settings()->defaultBorderActivateCylinderValue(), Cylinder);
+    m_form->monitorChangeDefaultEdge(m_data->settings()->defaultBorderActivateSphereValue(), Sphere);
+
     // TabBox
     m_form->monitorChangeDefaultEdge(m_data->settings()->defaultBorderActivateTabBoxValue(), TabBox);
     // Alternative TabBox
@@ -259,6 +274,11 @@ void KWinScreenEdgesConfig::monitorSaveSettings()
     // Desktop Grid
     m_data->settings()->setBorderActivateDesktopGrid(m_form->monitorCheckEffectHasEdge(DesktopGrid));
 
+    // Desktop Cube
+    m_data->settings()->setBorderActivateCube(m_form->monitorCheckEffectHasEdge(Cube));
+    m_data->settings()->setBorderActivateCylinder(m_form->monitorCheckEffectHasEdge(Cylinder));
+    m_data->settings()->setBorderActivateSphere(m_form->monitorCheckEffectHasEdge(Sphere));
+
     // TabBox
     m_data->settings()->setBorderActivateTabBox(m_form->monitorCheckEffectHasEdge(TabBox));
     m_data->settings()->setBorderAlternativeActivate(m_form->monitorCheckEffectHasEdge(TabBoxAlternative));
@@ -291,6 +311,12 @@ void KWinScreenEdgesConfig::monitorShowEvent()
     enabled = effectEnabled(BuiltInEffect::Overview, config);
     m_form->monitorItemSetEnabled(Overview, enabled);
 
+    // Desktop Cube
+    enabled = effectEnabled(BuiltInEffect::Cube, config);
+    m_form->monitorItemSetEnabled(Cube, enabled);
+    m_form->monitorItemSetEnabled(Cylinder, enabled);
+    m_form->monitorItemSetEnabled(Sphere, enabled);
+
     // tabbox, depends on reasonable focus policy.
     KConfigGroup config2(m_config, "Windows");
     QString focusPolicy = config2.readEntry("FocusPolicy", QString());
diff --git a/src/kcmkwin/kwinscreenedges/main.h b/src/kcmkwin/kwinscreenedges/main.h
index 1f4906958..dd713c992 100644
--- a/src/kcmkwin/kwinscreenedges/main.h
+++ b/src/kcmkwin/kwinscreenedges/main.h
@@ -53,6 +53,9 @@ private:
         PresentWindowsCurrent,
         PresentWindowsClass,
         DesktopGrid,
+        Cube,
+        Cylinder,
+        Sphere,
         TabBox,
         TabBoxAlternative,
         Overview,
diff --git a/src/kcmkwin/kwinscreenedges/touch.cpp b/src/kcmkwin/kwinscreenedges/touch.cpp
index 5e06e2886..e3755f8ae 100644
--- a/src/kcmkwin/kwinscreenedges/touch.cpp
+++ b/src/kcmkwin/kwinscreenedges/touch.cpp
@@ -86,6 +86,7 @@ void KWinScreenEdgesConfig::save()
     interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::Overview));
     interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::PresentWindows));
     interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::DesktopGrid));
+    interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::Cube));
 
     KCModule::save();
 }
@@ -133,6 +134,10 @@ void KWinScreenEdgesConfig::monitorInit()
     m_form->monitorAddItem(i18n("%1 - Current Desktop", presentWindowsName));
     m_form->monitorAddItem(i18n("%1 - Current Application", presentWindowsName));
     m_form->monitorAddItem(BuiltInEffects::effectData(BuiltInEffect::DesktopGrid).displayName);
+    const QString cubeName = BuiltInEffects::effectData(BuiltInEffect::Cube).displayName;
+    m_form->monitorAddItem(i18n("%1 - Cube", cubeName));
+    m_form->monitorAddItem(i18n("%1 - Cylinder", cubeName));
+    m_form->monitorAddItem(i18n("%1 - Sphere", cubeName));
 
     m_form->monitorAddItem(i18n("Toggle window switching"));
     m_form->monitorAddItem(i18n("Toggle alternative window switching"));
@@ -179,6 +184,13 @@ void KWinScreenEdgesConfig::monitorLoadSettings()
     // Desktop Grid BorderActivate
     m_form->monitorChangeEdge(m_data->settings()->touchBorderActivateDesktopGrid(), DesktopGrid);
 
+    // Desktop Cube BorderActivate
+    m_form->monitorChangeEdge(m_data->settings()->touchBorderActivateCube(), Cube);
+    // Desktop Cube BorderActivateCylinder
+    m_form->monitorChangeEdge(m_data->settings()->touchBorderActivateCylinder(), Cylinder);
+    // Desktop Cube BorderActivateSphere
+    m_form->monitorChangeEdge(m_data->settings()->touchBorderActivateSphere(), Sphere);
+
     // TabBox BorderActivate
     m_form->monitorChangeEdge(m_data->settings()->touchBorderActivateTabBox(), TabBox);
     // Alternative TabBox
@@ -211,6 +223,13 @@ void KWinScreenEdgesConfig::monitorLoadDefaultSettings()
     // Desktop Grid BorderActivate
     m_form->monitorChangeDefaultEdge(m_data->settings()->defaultTouchBorderActivateDesktopGridValue(), DesktopGrid);
 
+    // Desktop Cube BorderActivate
+    m_form->monitorChangeDefaultEdge(m_data->settings()->defaultTouchBorderActivateCubeValue(), Cube);
+    // Desktop Cube BorderActivateCylinder
+    m_form->monitorChangeDefaultEdge(m_data->settings()->defaultTouchBorderActivateCylinderValue(), Cylinder);
+    // Desktop Cube BorderActivateSphere
+    m_form->monitorChangeDefaultEdge(m_data->settings()->defaultTouchBorderActivateSphereValue(), Sphere);
+
     // TabBox BorderActivate
     m_form->monitorChangeDefaultEdge(m_data->settings()->defaultTouchBorderActivateTabBoxValue(), TabBox);
     // Alternative TabBox
@@ -238,6 +257,11 @@ void KWinScreenEdgesConfig::monitorSaveSettings()
     // Desktop Grid
     m_data->settings()->setTouchBorderActivateDesktopGrid(m_form->monitorCheckEffectHasEdge(DesktopGrid));
 
+    // Desktop Cube
+    m_data->settings()->setTouchBorderActivateCube(m_form->monitorCheckEffectHasEdge(Cube));
+    m_data->settings()->setTouchBorderActivateCylinder(m_form->monitorCheckEffectHasEdge(Cylinder));
+    m_data->settings()->setTouchBorderActivateSphere(m_form->monitorCheckEffectHasEdge(Sphere));
+
     // TabBox
     m_data->settings()->setTouchBorderActivateTabBox(m_form->monitorCheckEffectHasEdge(TabBox));
     m_data->settings()->setTouchBorderAlternativeActivate(m_form->monitorCheckEffectHasEdge(TabBoxAlternative));
@@ -270,6 +294,12 @@ void KWinScreenEdgesConfig::monitorShowEvent()
     enabled = effectEnabled(BuiltInEffect::Overview, config);
     m_form->monitorItemSetEnabled(Overview, enabled);
 
+    // Desktop Cube
+    enabled = effectEnabled(BuiltInEffect::Cube, config);
+    m_form->monitorItemSetEnabled(Cube, enabled);
+    m_form->monitorItemSetEnabled(Cylinder, enabled);
+    m_form->monitorItemSetEnabled(Sphere, enabled);
+
     // tabbox, depends on reasonable focus policy.
     KConfigGroup config2(m_config, "Windows");
     QString focusPolicy = config2.readEntry("FocusPolicy", QString());
diff --git a/src/kcmkwin/kwinscreenedges/touch.h b/src/kcmkwin/kwinscreenedges/touch.h
index 0036f0f3b..e19972339 100644
--- a/src/kcmkwin/kwinscreenedges/touch.h
+++ b/src/kcmkwin/kwinscreenedges/touch.h
@@ -53,6 +53,9 @@ private:
         PresentWindowsCurrent,
         PresentWindowsClass,
         DesktopGrid,
+        Cube,
+        Cylinder,
+        Sphere,
         TabBox,
         TabBoxAlternative,
         Overview,
diff --git a/src/kcmkwin/kwinscripts/CMakeLists.txt b/src/kcmkwin/kwinscripts/CMakeLists.txt
index 40c5a210e..3e9535455 100644
--- a/src/kcmkwin/kwinscripts/CMakeLists.txt
+++ b/src/kcmkwin/kwinscripts/CMakeLists.txt
@@ -19,6 +19,7 @@ target_link_libraries(kcm_kwin_scripts
 
     KF5::I18n
     KF5::KCMUtils
+    KF5::KIOCore
     KF5::NewStuff
     KF5::Package
 )
diff --git a/src/kcmkwin/kwintabbox/kwinpluginssettings.kcfg b/src/kcmkwin/kwintabbox/kwinpluginssettings.kcfg
index d337bc81e..66d5b40fc 100644
--- a/src/kcmkwin/kwintabbox/kwinpluginssettings.kcfg
+++ b/src/kcmkwin/kwintabbox/kwinpluginssettings.kcfg
@@ -5,6 +5,12 @@
        http://www.kde.org/standards/kcfg/1.0/kcfg.xsd" >
     <kcfgfile name="kwinrc" />
     <group name="Plugins">
+        <entry key="coverswitchEnabled" type="Bool">
+            <default code="true">BuiltInEffects::enabledByDefault(BuiltInEffect::CoverSwitch)</default>
+        </entry>
+        <entry key="flipswitchEnabled" type="Bool">
+            <default code="true">BuiltInEffects::enabledByDefault(BuiltInEffect::FlipSwitch)</default>
+        </entry>
         <entry key="highlightwindowEnabled" type="Bool">
             <default code="true">BuiltInEffects::enabledByDefault(BuiltInEffect::HighlightWindow)</default>
         </entry>
diff --git a/src/kcmkwin/kwintabbox/kwintabboxdata.cpp b/src/kcmkwin/kwintabbox/kwintabboxdata.cpp
index 74f96922e..f9e5cc8ff 100644
--- a/src/kcmkwin/kwintabbox/kwintabboxdata.cpp
+++ b/src/kcmkwin/kwintabbox/kwintabboxdata.cpp
@@ -22,10 +22,14 @@ KWinTabboxData::KWinTabboxData(QObject *parent, const QVariantList &args)
     : KCModuleData(parent, args)
     , m_tabBoxConfig(new TabBoxSettings(QStringLiteral("TabBox"), this))
     , m_tabBoxAlternativeConfig(new TabBoxSettings(QStringLiteral("TabBoxAlternative"), this))
+    , m_coverSwitchConfig(new SwitchEffectSettings(QStringLiteral("Effect-CoverSwitch"), this))
+    , m_flipSwitchConfig(new SwitchEffectSettings(QStringLiteral("Effect-FlipSwitch"), this))
     , m_pluginsConfig(new PluginsSettings(this))
 {
     registerSkeleton(m_tabBoxConfig);
     registerSkeleton(m_tabBoxAlternativeConfig);
+    registerSkeleton(m_coverSwitchConfig);
+    registerSkeleton(m_flipSwitchConfig);
 }
 
 TabBoxSettings *KWinTabboxData::tabBoxConfig() const
@@ -38,6 +42,16 @@ TabBoxSettings *KWinTabboxData::tabBoxAlternativeConfig() const
     return m_tabBoxAlternativeConfig;
 }
 
+SwitchEffectSettings *KWinTabboxData::coverSwitchConfig() const
+{
+    return m_coverSwitchConfig;
+}
+
+SwitchEffectSettings *KWinTabboxData::flipSwitchConfig() const
+{
+    return m_flipSwitchConfig;
+}
+
 PluginsSettings *KWinTabboxData::pluginsConfig() const
 {
     return m_pluginsConfig;
diff --git a/src/kcmkwin/kwintabbox/kwintabboxdata.h b/src/kcmkwin/kwintabbox/kwintabboxdata.h
index 38edfd8c3..b478cc410 100644
--- a/src/kcmkwin/kwintabbox/kwintabboxdata.h
+++ b/src/kcmkwin/kwintabbox/kwintabboxdata.h
@@ -31,11 +31,15 @@ public:
 
     TabBoxSettings *tabBoxConfig() const;
     TabBoxSettings *tabBoxAlternativeConfig() const;
+    SwitchEffectSettings *coverSwitchConfig() const;
+    SwitchEffectSettings *flipSwitchConfig() const;
     PluginsSettings *pluginsConfig() const;
 
 private:
     TabBoxSettings *m_tabBoxConfig;
     TabBoxSettings *m_tabBoxAlternativeConfig;
+    SwitchEffectSettings *m_coverSwitchConfig;
+    SwitchEffectSettings *m_flipSwitchConfig;
     PluginsSettings *m_pluginsConfig;
 };
 
diff --git a/src/kcmkwin/kwintabbox/main.cpp b/src/kcmkwin/kwintabbox/main.cpp
index 338886f1c..2a7aaba47 100644
--- a/src/kcmkwin/kwintabbox/main.cpp
+++ b/src/kcmkwin/kwintabbox/main.cpp
@@ -135,6 +135,10 @@ static QList<KPackage::Package> availableLnFPackages()
 
 void KWinTabBoxConfig::initLayoutLists()
 {
+    // search the effect names
+    m_coverSwitch = BuiltInEffects::effectData(BuiltInEffect::CoverSwitch).name;
+    m_flipSwitch = BuiltInEffects::effectData(BuiltInEffect::FlipSwitch).name;
+
     QList<KPluginMetaData> offers = KPackage::PackageLoader::self()->listPackages("KWin/WindowSwitcher");
     QStringList layoutNames, layoutPlugins, layoutPaths;
 
@@ -173,6 +177,16 @@ void KWinTabBoxConfig::initLayoutLists()
     for (int i=0; i<2; ++i) {
         QStandardItemModel *model = new QStandardItemModel;
 
+        QStandardItem *coverItem = new QStandardItem(BuiltInEffects::effectData(BuiltInEffect::CoverSwitch).displayName);
+        coverItem->setData(m_coverSwitch, Qt::UserRole);
+        coverItem->setData(false, KWinTabBoxConfigForm::AddonEffect);
+        model->appendRow(coverItem);
+
+        QStandardItem *flipItem = new QStandardItem(BuiltInEffects::effectData(BuiltInEffect::FlipSwitch).displayName);
+        flipItem->setData(m_flipSwitch, Qt::UserRole);
+        flipItem->setData(false, KWinTabBoxConfigForm::AddonEffect);
+        model->appendRow(flipItem);
+
         for (int j = 0; j < layoutNames.count(); ++j) {
             QStandardItem *item = new QStandardItem(layoutNames[j]);
             item->setData(layoutPlugins[j], Qt::UserRole);
@@ -288,8 +302,28 @@ void KWinTabBoxConfig::load()
     updateUiFromConfig(m_primaryTabBoxUi, m_data->tabBoxConfig());
     updateUiFromConfig(m_alternativeTabBoxUi , m_data->tabBoxAlternativeConfig());
 
+    m_data->coverSwitchConfig()->load();
+    m_data->flipSwitchConfig()->load();
+
     m_data->pluginsConfig()->load();
 
+    if (m_data->pluginsConfig()->coverswitchEnabled()) {
+        if (m_data->coverSwitchConfig()->tabBox()) {
+            m_primaryTabBoxUi->setLayoutName(m_coverSwitch);
+        }
+        if (m_data->coverSwitchConfig()->tabBoxAlternative()) {
+            m_alternativeTabBoxUi->setLayoutName(m_coverSwitch);
+        }
+    }
+    if (m_data->pluginsConfig()->flipswitchEnabled()) {
+        if (m_data->flipSwitchConfig()->tabBox()) {
+            m_primaryTabBoxUi->setLayoutName(m_flipSwitch);
+        }
+        if (m_data->flipSwitchConfig()->tabBoxAlternative()) {
+            m_alternativeTabBoxUi->setLayoutName(m_flipSwitch);
+        }
+    }
+
     m_primaryTabBoxUi->loadShortcuts();
     m_alternativeTabBoxUi->loadShortcuts();
 
@@ -300,11 +334,29 @@ void KWinTabBoxConfig::save()
 {
     // effects
     const bool highlightWindows = m_primaryTabBoxUi->highlightWindows() || m_alternativeTabBoxUi->highlightWindows();
+    const bool coverSwitch = m_primaryTabBoxUi->showTabBox()
+            && m_primaryTabBoxUi->effectComboCurrentData().toString() == m_coverSwitch;
+    const bool flipSwitch = m_primaryTabBoxUi->showTabBox()
+            && m_primaryTabBoxUi->effectComboCurrentData().toString() == m_flipSwitch;
+    const bool coverSwitchAlternative = m_alternativeTabBoxUi->showTabBox()
+            && m_alternativeTabBoxUi->effectComboCurrentData().toString() == m_coverSwitch;
+    const bool flipSwitchAlternative = m_alternativeTabBoxUi->showTabBox()
+            && m_alternativeTabBoxUi->effectComboCurrentData().toString() == m_flipSwitch;
 
     // activate effects if they are used otherwise deactivate them.
+    m_data->pluginsConfig()->setCoverswitchEnabled(coverSwitch || coverSwitchAlternative);
+    m_data->pluginsConfig()->setFlipswitchEnabled(flipSwitch || flipSwitchAlternative);
     m_data->pluginsConfig()->setHighlightwindowEnabled(highlightWindows);
     m_data->pluginsConfig()->save();
 
+    m_data->coverSwitchConfig()->setTabBox(coverSwitch);
+    m_data->coverSwitchConfig()->setTabBoxAlternative(coverSwitchAlternative);
+    m_data->coverSwitchConfig()->save();
+
+    m_data->flipSwitchConfig()->setTabBox(flipSwitch);
+    m_data->flipSwitchConfig()->setTabBoxAlternative(flipSwitchAlternative);
+    m_data->flipSwitchConfig()->save();
+
     updateConfigFromUi(m_primaryTabBoxUi, m_data->tabBoxConfig());
     updateConfigFromUi(m_alternativeTabBoxUi, m_data->tabBoxAlternativeConfig());
 
@@ -317,10 +369,19 @@ void KWinTabBoxConfig::save()
     // Reload KWin.
     QDBusMessage message = QDBusMessage::createSignal("/KWin", "org.kde.KWin", "reloadConfig");
     QDBusConnection::sessionBus().send(message);
+    // and reconfigure the effects
+    OrgKdeKwinEffectsInterface interface(QStringLiteral("org.kde.KWin"),
+                                             QStringLiteral("/Effects"),
+                                             QDBusConnection::sessionBus());
+    interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::CoverSwitch));
+    interface.reconfigureEffect(BuiltInEffects::nameForEffect(BuiltInEffect::FlipSwitch));
 }
 
 void KWinTabBoxConfig::defaults()
 {
+    m_data->coverSwitchConfig()->setDefaults();
+    m_data->flipSwitchConfig()->setDefaults();
+
     updateUiFromDefaultConfig(m_primaryTabBoxUi, m_data->tabBoxConfig());
     updateUiFromDefaultConfig(m_alternativeTabBoxUi, m_data->tabBoxAlternativeConfig());
 
diff --git a/src/kcmkwin/kwintabbox/main.h b/src/kcmkwin/kwintabbox/main.h
index 63c66bcad..0a5de9ea6 100644
--- a/src/kcmkwin/kwintabbox/main.h
+++ b/src/kcmkwin/kwintabbox/main.h
@@ -62,6 +62,10 @@ private:
     KSharedConfigPtr m_config;
 
     TabBox::KWinTabboxData *m_data;
+
+    // Builtin effects' names
+    QString m_coverSwitch;
+    QString m_flipSwitch;
 };
 
 } // namespace
